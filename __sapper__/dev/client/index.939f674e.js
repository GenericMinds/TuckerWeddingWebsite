import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, g as add_location, h as insert_dev, j as append_dev, n as noop, t as text, k as space, l as create_component, m as claim_text, o as claim_space, p as claim_component, q as mount_component, r as set_data_dev, u as transition_in, w as transition_out, x as destroy_component, y as create_slot, z as createEventDispatcher, A as onMount, B as listen_dev, C as update_slot, D as run_all, E as validate_each_argument, F as destroy_each, G as null_to_empty, H as group_outros, I as check_outros, J as binding_callbacks, K as svg_element, L as assign, M as get_spread_update, N as get_spread_object, O as empty, P as add_render_callback, Q as set_input_value, R as select_option, T as prop_dev, U as select_value, V as listen, W as bubble, X as compute_rest_props, Y as exclude_internal_props, Z as current_component, _ as set_attributes, $ as toggle_class, a0 as action_destroyer, a1 as set_svg_attributes, a2 as xlink_attr, a3 as is_function, a4 as identity, a5 as create_bidirectional_transition, a6 as bind, a7 as add_flush_callback, a8 as globals, a9 as onDestroy, aa as beforeUpdate, ab as tick, ac as now, ad as loop } from './client.e73ec8c3.js';

/* src\routes\_components\HeadingDecorator.svelte generated by Svelte v3.23.2 */

const file = "src\\routes\\_components\\HeadingDecorator.svelte";

function create_fragment(ctx) {
	let div;
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { alt: true, src: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "alt", "Heading Decoration");
			if (img.src !== (img_src_value = "./HeadingDecorator.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "class", "svelte-hhkc6p");
			add_location(img, file, 1, 4, 11);
			attr_dev(div, "class", "svelte-hhkc6p");
			add_location(div, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeadingDecorator> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HeadingDecorator", $$slots, []);
	return [];
}

class HeadingDecorator extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HeadingDecorator",
			options,
			id: create_fragment.name
		});
	}
}

/* src\routes\_components\SectionHeader.svelte generated by Svelte v3.23.2 */
const file$1 = "src\\routes\\_components\\SectionHeader.svelte";

function create_fragment$1(ctx) {
	let div;
	let h1;
	let t0;
	let t1;
	let headingdecorator;
	let current;
	headingdecorator = new HeadingDecorator({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			create_component(headingdecorator.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			claim_component(headingdecorator.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$1, 5, 4, 128);
			attr_dev(div, "class", "svelte-o9o53l");
			add_location(div, file$1, 4, 0, 117);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t0);
			append_dev(div, t1);
			mount_component(headingdecorator, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(headingdecorator.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(headingdecorator.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(headingdecorator);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { title } = $$props;
	const writable_props = ["title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SectionHeader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("SectionHeader", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
	};

	$$self.$capture_state = () => ({ HeadingDecorator, title });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title];
}

class SectionHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { title: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SectionHeader",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
			console.warn("<SectionHeader> was created without expected prop 'title'");
		}
	}

	get title() {
		throw new Error("<SectionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<SectionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_components\Jumbotron.svelte generated by Svelte v3.23.2 */

const file$2 = "src\\routes\\_components\\Jumbotron.svelte";

function create_fragment$2(ctx) {
	let div;
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "LisaTimMainPhoto.jpg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "Lisa and Tim posing during a hike in the woods.");
			attr_dev(img, "class", "svelte-oc3l9e");
			add_location(img, file$2, 0, 5, 5);
			attr_dev(div, "class", "svelte-oc3l9e");
			add_location(div, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Jumbotron> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Jumbotron", $$slots, []);
	return [];
}

class Jumbotron extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Jumbotron",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src\routes\_components\Story.svelte generated by Svelte v3.23.2 */
const file$3 = "src\\routes\\_components\\Story.svelte";

function create_fragment$3(ctx) {
	let section;
	let sectionheader;
	let t0;
	let div;
	let p0;
	let span;
	let t1;
	let t2;
	let t3;
	let p1;
	let t4;
	let t5;
	let p2;
	let t6;
	let t7;
	let p3;
	let t8;
	let t9;
	let p4;
	let t10;
	let t11;
	let p5;
	let t12;
	let t13;
	let p6;
	let t14;
	let t15;
	let p7;
	let t16;
	let t17;
	let p8;
	let t18;
	let t19;
	let p9;
	let t20;
	let current;

	sectionheader = new SectionHeader({
			props: { title: "Our Story" },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(sectionheader.$$.fragment);
			t0 = space();
			div = element("div");
			p0 = element("p");
			span = element("span");
			t1 = text("Once upon a time...");
			t2 = text(" there was a king and a viking princess. They did not know it, but the gods had set the table for them to be together.");
			t3 = space();
			p1 = element("p");
			t4 = text("As the gods planned out their destiny, they couldn't quite agree on the path these two should take to get there. One of the gods set up their first meeting. As they were both looking to learn more about the world around them, they attended the Academy at the same time. The first god set it up so that they lived in close proximity. Once the other gods noticed, they intervened and kept them from meeting each other. It was not their time yet.");
			t5 = space();
			p2 = element("p");
			t6 = text("Both the king and the viking princess went on to have families of their own. Another one of the gods thought that this was the time and moved them to the same town. Both of their families grew up at the same time. The king had two daughters and the viking princess had two sons and two daughters. The kids grew up with each other and became friends. The eldest viking son and the eldest princess of the king both pursued the bardic arts together. The youngest viking daughter and the youngest princess of the king battled for the raiders through volley after volley of balls flung by the invading armies. Through all of this the other gods decided it was not time for the king and the viking princess to meet, and kept them apart. It was not their time yet.");
			t7 = space();
			p3 = element("p");
			t8 = text("A third god decided to make his move and arranged it so the viking princess joined the Parent Teacher Student Guild along with the Queen. Both were valiant champions in making sure the children of the kingdom were getting the appropriate education. Throughout their many meetings and public events, the other gods decided to intervene and not allow the king and viking princess to cross paths. It was not their time yet.");
			t9 = space();
			p4 = element("p");
			t10 = text("The viking princess pursued her advancement in the Parent Teacher Student Guild with fervor and eventually reached the rank of Teacher of The Native Tongue. A fourth god decided this would be the perfect time to introduce the king and the viking princess. This god arranged for the king's youngest princess to become an apprentice of the viking princess. Alas, the other gods intervened yet again and did not let their paths cross. It was not their time yet.");
			t11 = space();
			p5 = element("p");
			t12 = text("Living within the same kingdom, they were often in the market at the same time. Neither taking notice of each other. The gods had again decided to keep them away from each other. It was not their time yet.");
			t13 = space();
			p6 = element("p");
			t14 = text("By this point in time, both had moved on from their previous relationships. While there were times where they were happy, they knew deep down that something was missing. Their sons and daughters had grown up and had families of their own. The gods finally decided it was time.");
			t15 = space();
			p7 = element("p");
			t16 = text("One fateful day, they aligned the stars to allow them to meet. The king was discussing life with a noble friend of his in the market when the viking princess entered. Their paths would have crossed yet again without interaction, but the gods had carefully laid out this moment. The noble that the king was talking to happened to also be the brother in law of the eldest viking daughter. The noble noticed the viking princess and decided to make an introduction. After the noble left, they continued their shopping, glancing at each other through the market stalls. The strands of fate spinning stronger and stronger with each passing. Humans tend to be unpredictable and resist their destinies. The viking princess abruptly left the market without talking with the king further.");
			t17 = space();
			p8 = element("p");
			t18 = text("The gods didn't like this. They filled her head with doubt and her heart with excitement. She knew she veered from their plans and decided to take her shot. She sent out messengers to find the king. They eventually tracked him down and arranged for them to meet again. A quick meeting at the tavern turned into a long conversations leading into the dead of night, yet somehow time felt like it was standing still. Everything was falling into place and the match felt like a perfect fit. But as a human himself, the king was stubborn and decided he wasn't ready for his destiny.");
			t19 = space();
			p9 = element("p");
			t20 = text("The gods didn't like this. One day as the king was at the theater watching the newest play, he took note of one of the characters. This character was a viking. He thought back to the viking princess and began to doubt his choices. The king decided to give it another chance. This time when they met, they were both ready to embrace their destinies.");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(sectionheader.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p0 = claim_element(div_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			span = claim_element(p0_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, "Once upon a time...");
			span_nodes.forEach(detach_dev);
			t2 = claim_text(p0_nodes, " there was a king and a viking princess. They did not know it, but the gods had set the table for them to be together.");
			p0_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			t4 = claim_text(p1_nodes, "As the gods planned out their destiny, they couldn't quite agree on the path these two should take to get there. One of the gods set up their first meeting. As they were both looking to learn more about the world around them, they attended the Academy at the same time. The first god set it up so that they lived in close proximity. Once the other gods noticed, they intervened and kept them from meeting each other. It was not their time yet.");
			p1_nodes.forEach(detach_dev);
			t5 = claim_space(div_nodes);
			p2 = claim_element(div_nodes, "P", { class: true });
			var p2_nodes = children(p2);
			t6 = claim_text(p2_nodes, "Both the king and the viking princess went on to have families of their own. Another one of the gods thought that this was the time and moved them to the same town. Both of their families grew up at the same time. The king had two daughters and the viking princess had two sons and two daughters. The kids grew up with each other and became friends. The eldest viking son and the eldest princess of the king both pursued the bardic arts together. The youngest viking daughter and the youngest princess of the king battled for the raiders through volley after volley of balls flung by the invading armies. Through all of this the other gods decided it was not time for the king and the viking princess to meet, and kept them apart. It was not their time yet.");
			p2_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			p3 = claim_element(div_nodes, "P", { class: true });
			var p3_nodes = children(p3);
			t8 = claim_text(p3_nodes, "A third god decided to make his move and arranged it so the viking princess joined the Parent Teacher Student Guild along with the Queen. Both were valiant champions in making sure the children of the kingdom were getting the appropriate education. Throughout their many meetings and public events, the other gods decided to intervene and not allow the king and viking princess to cross paths. It was not their time yet.");
			p3_nodes.forEach(detach_dev);
			t9 = claim_space(div_nodes);
			p4 = claim_element(div_nodes, "P", { class: true });
			var p4_nodes = children(p4);
			t10 = claim_text(p4_nodes, "The viking princess pursued her advancement in the Parent Teacher Student Guild with fervor and eventually reached the rank of Teacher of The Native Tongue. A fourth god decided this would be the perfect time to introduce the king and the viking princess. This god arranged for the king's youngest princess to become an apprentice of the viking princess. Alas, the other gods intervened yet again and did not let their paths cross. It was not their time yet.");
			p4_nodes.forEach(detach_dev);
			t11 = claim_space(div_nodes);
			p5 = claim_element(div_nodes, "P", { class: true });
			var p5_nodes = children(p5);
			t12 = claim_text(p5_nodes, "Living within the same kingdom, they were often in the market at the same time. Neither taking notice of each other. The gods had again decided to keep them away from each other. It was not their time yet.");
			p5_nodes.forEach(detach_dev);
			t13 = claim_space(div_nodes);
			p6 = claim_element(div_nodes, "P", { class: true });
			var p6_nodes = children(p6);
			t14 = claim_text(p6_nodes, "By this point in time, both had moved on from their previous relationships. While there were times where they were happy, they knew deep down that something was missing. Their sons and daughters had grown up and had families of their own. The gods finally decided it was time.");
			p6_nodes.forEach(detach_dev);
			t15 = claim_space(div_nodes);
			p7 = claim_element(div_nodes, "P", { class: true });
			var p7_nodes = children(p7);
			t16 = claim_text(p7_nodes, "One fateful day, they aligned the stars to allow them to meet. The king was discussing life with a noble friend of his in the market when the viking princess entered. Their paths would have crossed yet again without interaction, but the gods had carefully laid out this moment. The noble that the king was talking to happened to also be the brother in law of the eldest viking daughter. The noble noticed the viking princess and decided to make an introduction. After the noble left, they continued their shopping, glancing at each other through the market stalls. The strands of fate spinning stronger and stronger with each passing. Humans tend to be unpredictable and resist their destinies. The viking princess abruptly left the market without talking with the king further.");
			p7_nodes.forEach(detach_dev);
			t17 = claim_space(div_nodes);
			p8 = claim_element(div_nodes, "P", { class: true });
			var p8_nodes = children(p8);
			t18 = claim_text(p8_nodes, "The gods didn't like this. They filled her head with doubt and her heart with excitement. She knew she veered from their plans and decided to take her shot. She sent out messengers to find the king. They eventually tracked him down and arranged for them to meet again. A quick meeting at the tavern turned into a long conversations leading into the dead of night, yet somehow time felt like it was standing still. Everything was falling into place and the match felt like a perfect fit. But as a human himself, the king was stubborn and decided he wasn't ready for his destiny.");
			p8_nodes.forEach(detach_dev);
			t19 = claim_space(div_nodes);
			p9 = claim_element(div_nodes, "P", { class: true });
			var p9_nodes = children(p9);
			t20 = claim_text(p9_nodes, "The gods didn't like this. One day as the king was at the theater watching the newest play, he took note of one of the characters. This character was a viking. He thought back to the viking princess and began to doubt his choices. The king decided to give it another chance. This time when they met, they were both ready to embrace their destinies.");
			p9_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1um8qdl");
			add_location(span, file$3, 7, 11, 169);
			attr_dev(p0, "class", "svelte-1um8qdl");
			add_location(p0, file$3, 7, 8, 166);
			attr_dev(p1, "class", "svelte-1um8qdl");
			add_location(p1, file$3, 8, 8, 333);
			attr_dev(p2, "class", "svelte-1um8qdl");
			add_location(p2, file$3, 9, 8, 793);
			attr_dev(p3, "class", "svelte-1um8qdl");
			add_location(p3, file$3, 10, 8, 1567);
			attr_dev(p4, "class", "svelte-1um8qdl");
			add_location(p4, file$3, 11, 8, 2004);
			attr_dev(p5, "class", "svelte-1um8qdl");
			add_location(p5, file$3, 12, 8, 2479);
			attr_dev(p6, "class", "svelte-1um8qdl");
			add_location(p6, file$3, 13, 8, 2701);
			attr_dev(p7, "class", "svelte-1um8qdl");
			add_location(p7, file$3, 14, 8, 2994);
			attr_dev(p8, "class", "svelte-1um8qdl");
			add_location(p8, file$3, 15, 8, 3789);
			attr_dev(p9, "class", "svelte-1um8qdl");
			add_location(p9, file$3, 16, 8, 4383);
			attr_dev(div, "class", "svelte-1um8qdl");
			add_location(div, file$3, 6, 4, 151);
			attr_dev(section, "class", "story");
			add_location(section, file$3, 4, 0, 80);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(sectionheader, section, null);
			append_dev(section, t0);
			append_dev(section, div);
			append_dev(div, p0);
			append_dev(p0, span);
			append_dev(span, t1);
			append_dev(p0, t2);
			append_dev(div, t3);
			append_dev(div, p1);
			append_dev(p1, t4);
			append_dev(div, t5);
			append_dev(div, p2);
			append_dev(p2, t6);
			append_dev(div, t7);
			append_dev(div, p3);
			append_dev(p3, t8);
			append_dev(div, t9);
			append_dev(div, p4);
			append_dev(p4, t10);
			append_dev(div, t11);
			append_dev(div, p5);
			append_dev(p5, t12);
			append_dev(div, t13);
			append_dev(div, p6);
			append_dev(p6, t14);
			append_dev(div, t15);
			append_dev(div, p7);
			append_dev(p7, t16);
			append_dev(div, t17);
			append_dev(div, p8);
			append_dev(p8, t18);
			append_dev(div, t19);
			append_dev(div, p9);
			append_dev(p9, t20);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(sectionheader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sectionheader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(sectionheader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Story> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Story", $$slots, []);
	$$self.$capture_state = () => ({ SectionHeader });
	return [];
}

class Story extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Story",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src\routes\_components\Blended.svelte generated by Svelte v3.23.2 */
const file$4 = "src\\routes\\_components\\Blended.svelte";

function create_fragment$4(ctx) {
	let section;
	let sectionheader;
	let t0;
	let div;
	let p0;
	let t1;
	let t2;
	let p1;
	let t3;
	let t4;
	let p2;
	let t5;
	let t6;
	let p3;
	let t7;
	let t8;
	let br0;
	let t9;
	let p4;
	let t10;
	let t11;
	let p5;
	let t12;
	let t13;
	let p6;
	let t14;
	let t15;
	let p7;
	let t16;
	let t17;
	let br1;
	let t18;
	let p8;
	let t19;
	let t20;
	let p9;
	let t21;
	let t22;
	let p10;
	let t23;
	let t24;
	let p11;
	let t25;
	let t26;
	let br2;
	let t27;
	let p12;
	let t28;
	let t29;
	let p13;
	let t30;
	let t31;
	let p14;
	let t32;
	let t33;
	let p15;
	let t34;
	let t35;
	let br3;
	let t36;
	let p16;
	let t37;
	let t38;
	let p17;
	let t39;
	let t40;
	let p18;
	let t41;
	let t42;
	let p19;
	let t43;
	let current;

	sectionheader = new SectionHeader({
			props: { title: "Blended Family Recipe" },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(sectionheader.$$.fragment);
			t0 = space();
			div = element("div");
			p0 = element("p");
			t1 = text("Put a good and honest man");
			t2 = space();
			p1 = element("p");
			t3 = text("into a mixing pan.");
			t4 = space();
			p2 = element("p");
			t5 = text("Combine one loving woman");
			t6 = space();
			p3 = element("p");
			t7 = text("and blend well with the man.");
			t8 = space();
			br0 = element("br");
			t9 = space();
			p4 = element("p");
			t10 = text("Add the children of the man,");
			t11 = space();
			p5 = element("p");
			t12 = text("and the woman's children too.");
			t13 = space();
			p6 = element("p");
			t14 = text("Mix them all together");
			t15 = space();
			p7 = element("p");
			t16 = text("as you would a pot of stew.");
			t17 = space();
			br1 = element("br");
			t18 = space();
			p8 = element("p");
			t19 = text("Slowly stir in patience.");
			t20 = space();
			p9 = element("p");
			t21 = text("It will really help a lot.");
			t22 = space();
			p10 = element("p");
			t23 = text("If you're not sure how much,");
			t24 = space();
			p11 = element("p");
			t25 = text("throw in all you've got.");
			t26 = space();
			br2 = element("br");
			t27 = space();
			p12 = element("p");
			t28 = text("Then, six cups of sweetener");
			t29 = space();
			p13 = element("p");
			t30 = text("and fourteen cups of love.");
			t31 = space();
			p14 = element("p");
			t32 = text("Sprinkle in some blessings");
			t33 = space();
			p15 = element("p");
			t34 = text("from the heavens high above.");
			t35 = space();
			br3 = element("br");
			t36 = space();
			p16 = element("p");
			t37 = text("When the mixture is complete,");
			t38 = space();
			p17 = element("p");
			t39 = text("with great joy you will see...");
			t40 = space();
			p18 = element("p");
			t41 = text("creation of our awesome,");
			t42 = space();
			p19 = element("p");
			t43 = text("loving blended family.");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(sectionheader.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", {});
			var div_nodes = children(div);
			p0 = claim_element(div_nodes, "P", {});
			var p0_nodes = children(p0);
			t1 = claim_text(p0_nodes, "Put a good and honest man");
			p0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			t3 = claim_text(p1_nodes, "into a mixing pan.");
			p1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			p2 = claim_element(div_nodes, "P", {});
			var p2_nodes = children(p2);
			t5 = claim_text(p2_nodes, "Combine one loving woman");
			p2_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			p3 = claim_element(div_nodes, "P", {});
			var p3_nodes = children(p3);
			t7 = claim_text(p3_nodes, "and blend well with the man.");
			p3_nodes.forEach(detach_dev);
			t8 = claim_space(div_nodes);
			br0 = claim_element(div_nodes, "BR", {});
			t9 = claim_space(div_nodes);
			p4 = claim_element(div_nodes, "P", {});
			var p4_nodes = children(p4);
			t10 = claim_text(p4_nodes, "Add the children of the man,");
			p4_nodes.forEach(detach_dev);
			t11 = claim_space(div_nodes);
			p5 = claim_element(div_nodes, "P", {});
			var p5_nodes = children(p5);
			t12 = claim_text(p5_nodes, "and the woman's children too.");
			p5_nodes.forEach(detach_dev);
			t13 = claim_space(div_nodes);
			p6 = claim_element(div_nodes, "P", {});
			var p6_nodes = children(p6);
			t14 = claim_text(p6_nodes, "Mix them all together");
			p6_nodes.forEach(detach_dev);
			t15 = claim_space(div_nodes);
			p7 = claim_element(div_nodes, "P", {});
			var p7_nodes = children(p7);
			t16 = claim_text(p7_nodes, "as you would a pot of stew.");
			p7_nodes.forEach(detach_dev);
			t17 = claim_space(div_nodes);
			br1 = claim_element(div_nodes, "BR", {});
			t18 = claim_space(div_nodes);
			p8 = claim_element(div_nodes, "P", {});
			var p8_nodes = children(p8);
			t19 = claim_text(p8_nodes, "Slowly stir in patience.");
			p8_nodes.forEach(detach_dev);
			t20 = claim_space(div_nodes);
			p9 = claim_element(div_nodes, "P", {});
			var p9_nodes = children(p9);
			t21 = claim_text(p9_nodes, "It will really help a lot.");
			p9_nodes.forEach(detach_dev);
			t22 = claim_space(div_nodes);
			p10 = claim_element(div_nodes, "P", {});
			var p10_nodes = children(p10);
			t23 = claim_text(p10_nodes, "If you're not sure how much,");
			p10_nodes.forEach(detach_dev);
			t24 = claim_space(div_nodes);
			p11 = claim_element(div_nodes, "P", {});
			var p11_nodes = children(p11);
			t25 = claim_text(p11_nodes, "throw in all you've got.");
			p11_nodes.forEach(detach_dev);
			t26 = claim_space(div_nodes);
			br2 = claim_element(div_nodes, "BR", {});
			t27 = claim_space(div_nodes);
			p12 = claim_element(div_nodes, "P", {});
			var p12_nodes = children(p12);
			t28 = claim_text(p12_nodes, "Then, six cups of sweetener");
			p12_nodes.forEach(detach_dev);
			t29 = claim_space(div_nodes);
			p13 = claim_element(div_nodes, "P", {});
			var p13_nodes = children(p13);
			t30 = claim_text(p13_nodes, "and fourteen cups of love.");
			p13_nodes.forEach(detach_dev);
			t31 = claim_space(div_nodes);
			p14 = claim_element(div_nodes, "P", {});
			var p14_nodes = children(p14);
			t32 = claim_text(p14_nodes, "Sprinkle in some blessings");
			p14_nodes.forEach(detach_dev);
			t33 = claim_space(div_nodes);
			p15 = claim_element(div_nodes, "P", {});
			var p15_nodes = children(p15);
			t34 = claim_text(p15_nodes, "from the heavens high above.");
			p15_nodes.forEach(detach_dev);
			t35 = claim_space(div_nodes);
			br3 = claim_element(div_nodes, "BR", {});
			t36 = claim_space(div_nodes);
			p16 = claim_element(div_nodes, "P", {});
			var p16_nodes = children(p16);
			t37 = claim_text(p16_nodes, "When the mixture is complete,");
			p16_nodes.forEach(detach_dev);
			t38 = claim_space(div_nodes);
			p17 = claim_element(div_nodes, "P", {});
			var p17_nodes = children(p17);
			t39 = claim_text(p17_nodes, "with great joy you will see...");
			p17_nodes.forEach(detach_dev);
			t40 = claim_space(div_nodes);
			p18 = claim_element(div_nodes, "P", {});
			var p18_nodes = children(p18);
			t41 = claim_text(p18_nodes, "creation of our awesome,");
			p18_nodes.forEach(detach_dev);
			t42 = claim_space(div_nodes);
			p19 = claim_element(div_nodes, "P", {});
			var p19_nodes = children(p19);
			t43 = claim_text(p19_nodes, "loving blended family.");
			p19_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p0, file$4, 7, 8, 181);
			add_location(p1, file$4, 8, 8, 223);
			add_location(p2, file$4, 9, 8, 258);
			add_location(p3, file$4, 10, 8, 299);
			add_location(br0, file$4, 11, 8, 344);
			add_location(p4, file$4, 12, 8, 359);
			add_location(p5, file$4, 13, 8, 404);
			add_location(p6, file$4, 14, 8, 450);
			add_location(p7, file$4, 15, 8, 488);
			add_location(br1, file$4, 16, 8, 532);
			add_location(p8, file$4, 17, 8, 547);
			add_location(p9, file$4, 18, 8, 588);
			add_location(p10, file$4, 19, 8, 631);
			add_location(p11, file$4, 20, 8, 676);
			add_location(br2, file$4, 21, 8, 717);
			add_location(p12, file$4, 22, 8, 732);
			add_location(p13, file$4, 23, 8, 776);
			add_location(p14, file$4, 24, 8, 819);
			add_location(p15, file$4, 25, 8, 862);
			add_location(br3, file$4, 26, 8, 907);
			add_location(p16, file$4, 27, 8, 922);
			add_location(p17, file$4, 28, 8, 968);
			add_location(p18, file$4, 29, 8, 1015);
			add_location(p19, file$4, 30, 8, 1056);
			add_location(div, file$4, 6, 4, 166);
			attr_dev(section, "class", "blended");
			add_location(section, file$4, 4, 0, 81);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(sectionheader, section, null);
			append_dev(section, t0);
			append_dev(section, div);
			append_dev(div, p0);
			append_dev(p0, t1);
			append_dev(div, t2);
			append_dev(div, p1);
			append_dev(p1, t3);
			append_dev(div, t4);
			append_dev(div, p2);
			append_dev(p2, t5);
			append_dev(div, t6);
			append_dev(div, p3);
			append_dev(p3, t7);
			append_dev(div, t8);
			append_dev(div, br0);
			append_dev(div, t9);
			append_dev(div, p4);
			append_dev(p4, t10);
			append_dev(div, t11);
			append_dev(div, p5);
			append_dev(p5, t12);
			append_dev(div, t13);
			append_dev(div, p6);
			append_dev(p6, t14);
			append_dev(div, t15);
			append_dev(div, p7);
			append_dev(p7, t16);
			append_dev(div, t17);
			append_dev(div, br1);
			append_dev(div, t18);
			append_dev(div, p8);
			append_dev(p8, t19);
			append_dev(div, t20);
			append_dev(div, p9);
			append_dev(p9, t21);
			append_dev(div, t22);
			append_dev(div, p10);
			append_dev(p10, t23);
			append_dev(div, t24);
			append_dev(div, p11);
			append_dev(p11, t25);
			append_dev(div, t26);
			append_dev(div, br2);
			append_dev(div, t27);
			append_dev(div, p12);
			append_dev(p12, t28);
			append_dev(div, t29);
			append_dev(div, p13);
			append_dev(p13, t30);
			append_dev(div, t31);
			append_dev(div, p14);
			append_dev(p14, t32);
			append_dev(div, t33);
			append_dev(div, p15);
			append_dev(p15, t34);
			append_dev(div, t35);
			append_dev(div, br3);
			append_dev(div, t36);
			append_dev(div, p16);
			append_dev(p16, t37);
			append_dev(div, t38);
			append_dev(div, p17);
			append_dev(p17, t39);
			append_dev(div, t40);
			append_dev(div, p18);
			append_dev(p18, t41);
			append_dev(div, t42);
			append_dev(div, p19);
			append_dev(p19, t43);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(sectionheader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sectionheader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(sectionheader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Blended> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Blended", $$slots, []);
	$$self.$capture_state = () => ({ SectionHeader });
	return [];
}

class Blended extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Blended",
			options,
			id: create_fragment$4.name
		});
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var siema_min = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}("undefined"!=typeof self?self:commonjsGlobal,function(){return function(e){function t(r){if(i[r])return i[r].exports;var n=i[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var i={};return t.m=e,t.c=i,t.d=function(e,i,r){t.o(e,i)||Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:r});},t.n=function(e){var i=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(i,"a",i),i},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=0)}([function(e,t,i){function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=function(){function e(e,t){for(var i=0;i<t.length;i++){var r=t[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}return function(t,i,r){return i&&e(t.prototype,i),r&&e(t,r),t}}(),l=function(){function e(t){var i=this;if(r(this,e),this.config=e.mergeSettings(t),this.selector="string"==typeof this.config.selector?document.querySelector(this.config.selector):this.config.selector,null===this.selector)throw new Error("Something wrong with your selector 😭");this.resolveSlidesNumber(),this.selectorWidth=this.selector.offsetWidth,this.innerElements=[].slice.call(this.selector.children),this.currentSlide=this.config.loop?this.config.startIndex%this.innerElements.length:Math.max(0,Math.min(this.config.startIndex,this.innerElements.length-this.perPage)),this.transformProperty=e.webkitOrNot(),["resizeHandler","touchstartHandler","touchendHandler","touchmoveHandler","mousedownHandler","mouseupHandler","mouseleaveHandler","mousemoveHandler","clickHandler"].forEach(function(e){i[e]=i[e].bind(i);}),this.init();}return s(e,[{key:"attachEvents",value:function(){window.addEventListener("resize",this.resizeHandler),this.config.draggable&&(this.pointerDown=!1,this.drag={startX:0,endX:0,startY:0,letItGo:null,preventClick:!1},this.selector.addEventListener("touchstart",this.touchstartHandler),this.selector.addEventListener("touchend",this.touchendHandler),this.selector.addEventListener("touchmove",this.touchmoveHandler),this.selector.addEventListener("mousedown",this.mousedownHandler),this.selector.addEventListener("mouseup",this.mouseupHandler),this.selector.addEventListener("mouseleave",this.mouseleaveHandler),this.selector.addEventListener("mousemove",this.mousemoveHandler),this.selector.addEventListener("click",this.clickHandler));}},{key:"detachEvents",value:function(){window.removeEventListener("resize",this.resizeHandler),this.selector.removeEventListener("touchstart",this.touchstartHandler),this.selector.removeEventListener("touchend",this.touchendHandler),this.selector.removeEventListener("touchmove",this.touchmoveHandler),this.selector.removeEventListener("mousedown",this.mousedownHandler),this.selector.removeEventListener("mouseup",this.mouseupHandler),this.selector.removeEventListener("mouseleave",this.mouseleaveHandler),this.selector.removeEventListener("mousemove",this.mousemoveHandler),this.selector.removeEventListener("click",this.clickHandler);}},{key:"init",value:function(){this.attachEvents(),this.selector.style.overflow="hidden",this.selector.style.direction=this.config.rtl?"rtl":"ltr",this.buildSliderFrame(),this.config.onInit.call(this);}},{key:"buildSliderFrame",value:function(){var e=this.selectorWidth/this.perPage,t=this.config.loop?this.innerElements.length+2*this.perPage:this.innerElements.length;this.sliderFrame=document.createElement("div"),this.sliderFrame.style.width=e*t+"px",this.enableTransition(),this.config.draggable&&(this.selector.style.cursor="-webkit-grab");var i=document.createDocumentFragment();if(this.config.loop)for(var r=this.innerElements.length-this.perPage;r<this.innerElements.length;r++){var n=this.buildSliderFrameItem(this.innerElements[r].cloneNode(!0));i.appendChild(n);}for(var s=0;s<this.innerElements.length;s++){var l=this.buildSliderFrameItem(this.innerElements[s]);i.appendChild(l);}if(this.config.loop)for(var o=0;o<this.perPage;o++){var a=this.buildSliderFrameItem(this.innerElements[o].cloneNode(!0));i.appendChild(a);}this.sliderFrame.appendChild(i),this.selector.innerHTML="",this.selector.appendChild(this.sliderFrame),this.slideToCurrent();}},{key:"buildSliderFrameItem",value:function(e){var t=document.createElement("div");return t.style.cssFloat=this.config.rtl?"right":"left",t.style.float=this.config.rtl?"right":"left",t.style.width=(this.config.loop?100/(this.innerElements.length+2*this.perPage):100/this.innerElements.length)+"%",t.appendChild(e),t}},{key:"resolveSlidesNumber",value:function(){if("number"==typeof this.config.perPage)this.perPage=this.config.perPage;else if("object"===n(this.config.perPage)){this.perPage=1;for(var e in this.config.perPage)window.innerWidth>=e&&(this.perPage=this.config.perPage[e]);}}},{key:"prev",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments[1];if(!(this.innerElements.length<=this.perPage)){var i=this.currentSlide;if(this.config.loop){if(this.currentSlide-e<0){this.disableTransition();var r=this.currentSlide+this.innerElements.length,n=this.perPage,s=r+n,l=(this.config.rtl?1:-1)*s*(this.selectorWidth/this.perPage),o=this.config.draggable?this.drag.endX-this.drag.startX:0;this.sliderFrame.style[this.transformProperty]="translate3d("+(l+o)+"px, 0, 0)",this.currentSlide=r-e;}else this.currentSlide=this.currentSlide-e;}else this.currentSlide=Math.max(this.currentSlide-e,0);i!==this.currentSlide&&(this.slideToCurrent(this.config.loop),this.config.onChange.call(this),t&&t.call(this));}}},{key:"next",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments[1];if(!(this.innerElements.length<=this.perPage)){var i=this.currentSlide;if(this.config.loop){if(this.currentSlide+e>this.innerElements.length-this.perPage){this.disableTransition();var r=this.currentSlide-this.innerElements.length,n=this.perPage,s=r+n,l=(this.config.rtl?1:-1)*s*(this.selectorWidth/this.perPage),o=this.config.draggable?this.drag.endX-this.drag.startX:0;this.sliderFrame.style[this.transformProperty]="translate3d("+(l+o)+"px, 0, 0)",this.currentSlide=r+e;}else this.currentSlide=this.currentSlide+e;}else this.currentSlide=Math.min(this.currentSlide+e,this.innerElements.length-this.perPage);i!==this.currentSlide&&(this.slideToCurrent(this.config.loop),this.config.onChange.call(this),t&&t.call(this));}}},{key:"disableTransition",value:function(){this.sliderFrame.style.webkitTransition="all 0ms "+this.config.easing,this.sliderFrame.style.transition="all 0ms "+this.config.easing;}},{key:"enableTransition",value:function(){this.sliderFrame.style.webkitTransition="all "+this.config.duration+"ms "+this.config.easing,this.sliderFrame.style.transition="all "+this.config.duration+"ms "+this.config.easing;}},{key:"goTo",value:function(e,t){if(!(this.innerElements.length<=this.perPage)){var i=this.currentSlide;this.currentSlide=this.config.loop?e%this.innerElements.length:Math.min(Math.max(e,0),this.innerElements.length-this.perPage),i!==this.currentSlide&&(this.slideToCurrent(),this.config.onChange.call(this),t&&t.call(this));}}},{key:"slideToCurrent",value:function(e){var t=this,i=this.config.loop?this.currentSlide+this.perPage:this.currentSlide,r=(this.config.rtl?1:-1)*i*(this.selectorWidth/this.perPage);e?requestAnimationFrame(function(){requestAnimationFrame(function(){t.enableTransition(),t.sliderFrame.style[t.transformProperty]="translate3d("+r+"px, 0, 0)";});}):this.sliderFrame.style[this.transformProperty]="translate3d("+r+"px, 0, 0)";}},{key:"updateAfterDrag",value:function(){var e=(this.config.rtl?-1:1)*(this.drag.endX-this.drag.startX),t=Math.abs(e),i=this.config.multipleDrag?Math.ceil(t/(this.selectorWidth/this.perPage)):1,r=e>0&&this.currentSlide-i<0,n=e<0&&this.currentSlide+i>this.innerElements.length-this.perPage;e>0&&t>this.config.threshold&&this.innerElements.length>this.perPage?this.prev(i):e<0&&t>this.config.threshold&&this.innerElements.length>this.perPage&&this.next(i),this.slideToCurrent(r||n);}},{key:"resizeHandler",value:function(){this.resolveSlidesNumber(),this.currentSlide+this.perPage>this.innerElements.length&&(this.currentSlide=this.innerElements.length<=this.perPage?0:this.innerElements.length-this.perPage),this.selectorWidth=this.selector.offsetWidth,this.buildSliderFrame();}},{key:"clearDrag",value:function(){this.drag={startX:0,endX:0,startY:0,letItGo:null,preventClick:this.drag.preventClick};}},{key:"touchstartHandler",value:function(e){-1!==["TEXTAREA","OPTION","INPUT","SELECT"].indexOf(e.target.nodeName)||(e.stopPropagation(),this.pointerDown=!0,this.drag.startX=e.touches[0].pageX,this.drag.startY=e.touches[0].pageY);}},{key:"touchendHandler",value:function(e){e.stopPropagation(),this.pointerDown=!1,this.enableTransition(),this.drag.endX&&this.updateAfterDrag(),this.clearDrag();}},{key:"touchmoveHandler",value:function(e){if(e.stopPropagation(),null===this.drag.letItGo&&(this.drag.letItGo=Math.abs(this.drag.startY-e.touches[0].pageY)<Math.abs(this.drag.startX-e.touches[0].pageX)),this.pointerDown&&this.drag.letItGo){e.preventDefault(),this.drag.endX=e.touches[0].pageX,this.sliderFrame.style.webkitTransition="all 0ms "+this.config.easing,this.sliderFrame.style.transition="all 0ms "+this.config.easing;var t=this.config.loop?this.currentSlide+this.perPage:this.currentSlide,i=t*(this.selectorWidth/this.perPage),r=this.drag.endX-this.drag.startX,n=this.config.rtl?i+r:i-r;this.sliderFrame.style[this.transformProperty]="translate3d("+(this.config.rtl?1:-1)*n+"px, 0, 0)";}}},{key:"mousedownHandler",value:function(e){-1!==["TEXTAREA","OPTION","INPUT","SELECT"].indexOf(e.target.nodeName)||(e.preventDefault(),e.stopPropagation(),this.pointerDown=!0,this.drag.startX=e.pageX);}},{key:"mouseupHandler",value:function(e){e.stopPropagation(),this.pointerDown=!1,this.selector.style.cursor="-webkit-grab",this.enableTransition(),this.drag.endX&&this.updateAfterDrag(),this.clearDrag();}},{key:"mousemoveHandler",value:function(e){if(e.preventDefault(),this.pointerDown){"A"===e.target.nodeName&&(this.drag.preventClick=!0),this.drag.endX=e.pageX,this.selector.style.cursor="-webkit-grabbing",this.sliderFrame.style.webkitTransition="all 0ms "+this.config.easing,this.sliderFrame.style.transition="all 0ms "+this.config.easing;var t=this.config.loop?this.currentSlide+this.perPage:this.currentSlide,i=t*(this.selectorWidth/this.perPage),r=this.drag.endX-this.drag.startX,n=this.config.rtl?i+r:i-r;this.sliderFrame.style[this.transformProperty]="translate3d("+(this.config.rtl?1:-1)*n+"px, 0, 0)";}}},{key:"mouseleaveHandler",value:function(e){this.pointerDown&&(this.pointerDown=!1,this.selector.style.cursor="-webkit-grab",this.drag.endX=e.pageX,this.drag.preventClick=!1,this.enableTransition(),this.updateAfterDrag(),this.clearDrag());}},{key:"clickHandler",value:function(e){this.drag.preventClick&&e.preventDefault(),this.drag.preventClick=!1;}},{key:"remove",value:function(e,t){if(e<0||e>=this.innerElements.length)throw new Error("Item to remove doesn't exist 😭");var i=e<this.currentSlide,r=this.currentSlide+this.perPage-1===e;(i||r)&&this.currentSlide--,this.innerElements.splice(e,1),this.buildSliderFrame(),t&&t.call(this);}},{key:"insert",value:function(e,t,i){if(t<0||t>this.innerElements.length+1)throw new Error("Unable to inset it at this index 😭");if(-1!==this.innerElements.indexOf(e))throw new Error("The same item in a carousel? Really? Nope 😭");var r=t<=this.currentSlide>0&&this.innerElements.length;this.currentSlide=r?this.currentSlide+1:this.currentSlide,this.innerElements.splice(t,0,e),this.buildSliderFrame(),i&&i.call(this);}},{key:"prepend",value:function(e,t){this.insert(e,0),t&&t.call(this);}},{key:"append",value:function(e,t){this.insert(e,this.innerElements.length+1),t&&t.call(this);}},{key:"destroy",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments[1];if(this.detachEvents(),this.selector.style.cursor="auto",e){for(var i=document.createDocumentFragment(),r=0;r<this.innerElements.length;r++)i.appendChild(this.innerElements[r]);this.selector.innerHTML="",this.selector.appendChild(i),this.selector.removeAttribute("style");}t&&t.call(this);}}],[{key:"mergeSettings",value:function(e){var t={selector:".siema",duration:200,easing:"ease-out",perPage:1,startIndex:0,draggable:!0,multipleDrag:!0,threshold:20,loop:!1,rtl:!1,onInit:function(){},onChange:function(){}},i=e;for(var r in i)t[r]=i[r];return t}},{key:"webkitOrNot",value:function(){return "string"==typeof document.documentElement.style.transform?"transform":"WebkitTransform"}}]),e}();t.default=l,e.exports=t.default;}])});
});

var Siema = /*@__PURE__*/unwrapExports(siema_min);

/* node_modules\@beyonk\svelte-carousel\src\Carousel.svelte generated by Svelte v3.23.2 */
const file$5 = "node_modules\\@beyonk\\svelte-carousel\\src\\Carousel.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	child_ctx[33] = i;
	return child_ctx;
}

const get_right_control_slot_changes = dirty => ({});
const get_right_control_slot_context = ctx => ({});
const get_left_control_slot_changes = dirty => ({});
const get_left_control_slot_context = ctx => ({});

// (6:1) {#if controls}
function create_if_block_1(ctx) {
	let button0;
	let t;
	let button1;
	let current;
	let mounted;
	let dispose;
	const left_control_slot_template = /*$$slots*/ ctx[23]["left-control"];
	const left_control_slot = create_slot(left_control_slot_template, ctx, /*$$scope*/ ctx[22], get_left_control_slot_context);
	const right_control_slot_template = /*$$slots*/ ctx[23]["right-control"];
	const right_control_slot = create_slot(right_control_slot_template, ctx, /*$$scope*/ ctx[22], get_right_control_slot_context);

	const block = {
		c: function create() {
			button0 = element("button");
			if (left_control_slot) left_control_slot.c();
			t = space();
			button1 = element("button");
			if (right_control_slot) right_control_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			button0 = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
			var button0_nodes = children(button0);
			if (left_control_slot) left_control_slot.l(button0_nodes);
			button0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			button1 = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
			var button1_nodes = children(button1);
			if (right_control_slot) right_control_slot.l(button1_nodes);
			button1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "class", "left svelte-1d83jxb");
			attr_dev(button0, "aria-label", "left");
			add_location(button0, file$5, 6, 1, 105);
			attr_dev(button1, "class", "right svelte-1d83jxb");
			attr_dev(button1, "aria-label", "right");
			add_location(button1, file$5, 9, 1, 209);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button0, anchor);

			if (left_control_slot) {
				left_control_slot.m(button0, null);
			}

			insert_dev(target, t, anchor);
			insert_dev(target, button1, anchor);

			if (right_control_slot) {
				right_control_slot.m(button1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*left*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*right*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (left_control_slot) {
				if (left_control_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(left_control_slot, left_control_slot_template, ctx, /*$$scope*/ ctx[22], dirty, get_left_control_slot_changes, get_left_control_slot_context);
				}
			}

			if (right_control_slot) {
				if (right_control_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(right_control_slot, right_control_slot_template, ctx, /*$$scope*/ ctx[22], dirty, get_right_control_slot_changes, get_right_control_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(left_control_slot, local);
			transition_in(right_control_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(left_control_slot, local);
			transition_out(right_control_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button0);
			if (left_control_slot) left_control_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(button1);
			if (right_control_slot) right_control_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(6:1) {#if controls}",
		ctx
	});

	return block;
}

// (14:4) {#if dots}
function create_if_block(ctx) {
	let ul;
	let each_value = { length: /*totalDots*/ ctx[9] };
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-1d83jxb");
			add_location(ul, file$5, 14, 1, 339);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*isDotActive, currentIndex, go, currentPerPage, totalDots*/ 868) {
				each_value = { length: /*totalDots*/ ctx[9] };
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(14:4) {#if dots}",
		ctx
	});

	return block;
}

// (16:2) {#each {length: totalDots} as _, i}
function create_each_block(ctx) {
	let li;
	let li_class_value;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[25](/*i*/ ctx[33], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			children(li).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*isDotActive*/ ctx[2](/*currentIndex*/ ctx[6], /*i*/ ctx[33])
			? "active"
			: "") + " svelte-1d83jxb"));

			add_location(li, file$5, 16, 2, 384);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*currentIndex*/ 64 && li_class_value !== (li_class_value = "" + (null_to_empty(/*isDotActive*/ ctx[2](/*currentIndex*/ ctx[6], /*i*/ ctx[33])
			? "active"
			: "") + " svelte-1d83jxb"))) {
				attr_dev(li, "class", li_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(16:2) {#each {length: totalDots} as _, i}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div1;
	let div0;
	let t0;
	let t1;
	let current;
	const default_slot_template = /*$$slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);
	let if_block0 = /*controls*/ ctx[1] && create_if_block_1(ctx);
	let if_block1 = /*dots*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "slides");
			add_location(div0, file$5, 2, 1, 25);
			attr_dev(div1, "class", "carousel svelte-1d83jxb");
			add_location(div1, file$5, 1, 0, 1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[24](div0);
			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}

			if (/*controls*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*controls*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*dots*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[24](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { perPage = 3 } = $$props;
	let { loop = true } = $$props;
	let { autoplay = 0 } = $$props;
	let { duration = 200 } = $$props;
	let { easing = "ease-out" } = $$props;
	let { startIndex = 0 } = $$props;
	let { draggable = true } = $$props;
	let { multipleDrag = true } = $$props;
	let { dots = true } = $$props;
	let { controls = true } = $$props;
	let { threshold = 20 } = $$props;
	let { rtl = false } = $$props;
	let currentIndex = startIndex;
	let siema;
	let controller;
	let timer;
	const dispatch = createEventDispatcher();

	onMount(() => {
		$$invalidate(26, controller = new Siema({
				selector: siema,
				perPage: typeof perPage === "object" ? perPage : Number(perPage),
				loop,
				duration,
				easing,
				startIndex,
				draggable,
				multipleDrag,
				threshold,
				rtl,
				onChange: handleChange
			}));

		if (autoplay) {
			timer = setInterval(right, autoplay);
		}

		return () => {
			autoplay && clearInterval(timer);
			controller.destroy();
		};
	});

	function isDotActive(currentIndex, dotIndex) {
		if (currentIndex < 0) currentIndex = pips.length + currentIndex;
		return currentIndex >= dotIndex * currentPerPage && currentIndex < dotIndex * currentPerPage + currentPerPage;
	}

	function left() {
		controller.prev();
	}

	function right() {
		controller.next();
	}

	function go(index) {
		controller.goTo(index);
	}

	function pause() {
		clearInterval(timer);
	}

	function resume() {
		if (autoplay) {
			timer = setInterval(right, autoplay);
		}
	}

	function handleChange(event) {
		$$invalidate(6, currentIndex = controller.currentSlide);

		dispatch("change", {
			currentSlide: controller.currentSlide,
			slideCount: controller.innerElements.length
		});
	}

	const writable_props = [
		"perPage",
		"loop",
		"autoplay",
		"duration",
		"easing",
		"startIndex",
		"draggable",
		"multipleDrag",
		"dots",
		"controls",
		"threshold",
		"rtl"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Carousel> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Carousel", $$slots, ['default','left-control','right-control']);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			siema = $$value;
			$$invalidate(7, siema);
		});
	}

	const click_handler = i => go(i * currentPerPage);

	$$self.$set = $$props => {
		if ("perPage" in $$props) $$invalidate(10, perPage = $$props.perPage);
		if ("loop" in $$props) $$invalidate(11, loop = $$props.loop);
		if ("autoplay" in $$props) $$invalidate(12, autoplay = $$props.autoplay);
		if ("duration" in $$props) $$invalidate(13, duration = $$props.duration);
		if ("easing" in $$props) $$invalidate(14, easing = $$props.easing);
		if ("startIndex" in $$props) $$invalidate(15, startIndex = $$props.startIndex);
		if ("draggable" in $$props) $$invalidate(16, draggable = $$props.draggable);
		if ("multipleDrag" in $$props) $$invalidate(17, multipleDrag = $$props.multipleDrag);
		if ("dots" in $$props) $$invalidate(0, dots = $$props.dots);
		if ("controls" in $$props) $$invalidate(1, controls = $$props.controls);
		if ("threshold" in $$props) $$invalidate(18, threshold = $$props.threshold);
		if ("rtl" in $$props) $$invalidate(19, rtl = $$props.rtl);
		if ("$$scope" in $$props) $$invalidate(22, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Siema,
		onMount,
		createEventDispatcher,
		perPage,
		loop,
		autoplay,
		duration,
		easing,
		startIndex,
		draggable,
		multipleDrag,
		dots,
		controls,
		threshold,
		rtl,
		currentIndex,
		siema,
		controller,
		timer,
		dispatch,
		isDotActive,
		left,
		right,
		go,
		pause,
		resume,
		handleChange,
		pips,
		currentPerPage,
		totalDots
	});

	$$self.$inject_state = $$props => {
		if ("perPage" in $$props) $$invalidate(10, perPage = $$props.perPage);
		if ("loop" in $$props) $$invalidate(11, loop = $$props.loop);
		if ("autoplay" in $$props) $$invalidate(12, autoplay = $$props.autoplay);
		if ("duration" in $$props) $$invalidate(13, duration = $$props.duration);
		if ("easing" in $$props) $$invalidate(14, easing = $$props.easing);
		if ("startIndex" in $$props) $$invalidate(15, startIndex = $$props.startIndex);
		if ("draggable" in $$props) $$invalidate(16, draggable = $$props.draggable);
		if ("multipleDrag" in $$props) $$invalidate(17, multipleDrag = $$props.multipleDrag);
		if ("dots" in $$props) $$invalidate(0, dots = $$props.dots);
		if ("controls" in $$props) $$invalidate(1, controls = $$props.controls);
		if ("threshold" in $$props) $$invalidate(18, threshold = $$props.threshold);
		if ("rtl" in $$props) $$invalidate(19, rtl = $$props.rtl);
		if ("currentIndex" in $$props) $$invalidate(6, currentIndex = $$props.currentIndex);
		if ("siema" in $$props) $$invalidate(7, siema = $$props.siema);
		if ("controller" in $$props) $$invalidate(26, controller = $$props.controller);
		if ("timer" in $$props) timer = $$props.timer;
		if ("pips" in $$props) pips = $$props.pips;
		if ("currentPerPage" in $$props) $$invalidate(8, currentPerPage = $$props.currentPerPage);
		if ("totalDots" in $$props) $$invalidate(9, totalDots = $$props.totalDots);
	};

	let pips;
	let currentPerPage;
	let totalDots;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*controller*/ 67108864) {
			 pips = controller ? controller.innerElements : [];
		}

		if ($$self.$$.dirty[0] & /*controller, perPage*/ 67109888) {
			 $$invalidate(8, currentPerPage = controller ? controller.perPage : perPage);
		}

		if ($$self.$$.dirty[0] & /*controller, currentPerPage*/ 67109120) {
			 $$invalidate(9, totalDots = controller
			? Math.ceil(controller.innerElements.length / currentPerPage)
			: []);
		}
	};

	return [
		dots,
		controls,
		isDotActive,
		left,
		right,
		go,
		currentIndex,
		siema,
		currentPerPage,
		totalDots,
		perPage,
		loop,
		autoplay,
		duration,
		easing,
		startIndex,
		draggable,
		multipleDrag,
		threshold,
		rtl,
		pause,
		resume,
		$$scope,
		$$slots,
		div0_binding,
		click_handler
	];
}

class Carousel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				perPage: 10,
				loop: 11,
				autoplay: 12,
				duration: 13,
				easing: 14,
				startIndex: 15,
				draggable: 16,
				multipleDrag: 17,
				dots: 0,
				controls: 1,
				threshold: 18,
				rtl: 19,
				isDotActive: 2,
				left: 3,
				right: 4,
				go: 5,
				pause: 20,
				resume: 21
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Carousel",
			options,
			id: create_fragment$5.name
		});
	}

	get perPage() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set perPage(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loop() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loop(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoplay() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoplay(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get easing() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set easing(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startIndex() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startIndex(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get draggable() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set draggable(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multipleDrag() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multipleDrag(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dots() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dots(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get controls() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set controls(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get threshold() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set threshold(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rtl() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rtl(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isDotActive() {
		return this.$$.ctx[2];
	}

	set isDotActive(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		return this.$$.ctx[3];
	}

	set left(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		return this.$$.ctx[4];
	}

	set right(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get go() {
		return this.$$.ctx[5];
	}

	set go(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pause() {
		return this.$$.ctx[20];
	}

	set pause(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resume() {
		return this.$$.ctx[21];
	}

	set resume(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-feather-icons\src\icons\ChevronLeftIcon.svelte generated by Svelte v3.23.2 */

const file$6 = "node_modules\\svelte-feather-icons\\src\\icons\\ChevronLeftIcon.svelte";

function create_fragment$6(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					fill: true,
					viewBox: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			polyline = claim_element(svg_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "15 18 9 12 15 6");
			add_location(polyline, file$6, 12, 237, 493);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", "2");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-left " + /*customClass*/ ctx[1]);
			add_location(svg, file$6, 12, 0, 256);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-chevron-left " + /*customClass*/ ctx[1])) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	const writable_props = ["size", "class"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChevronLeftIcon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ChevronLeftIcon", $$slots, []);

	$$self.$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
	};

	$$self.$capture_state = () => ({ size, customClass });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, customClass];
}

class ChevronLeftIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { size: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronLeftIcon",
			options,
			id: create_fragment$6.name
		});
	}

	get size() {
		throw new Error("<ChevronLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<ChevronLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ChevronLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ChevronLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-feather-icons\src\icons\ChevronRightIcon.svelte generated by Svelte v3.23.2 */

const file$7 = "node_modules\\svelte-feather-icons\\src\\icons\\ChevronRightIcon.svelte";

function create_fragment$7(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					fill: true,
					viewBox: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			polyline = claim_element(svg_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "9 18 15 12 9 6");
			add_location(polyline, file$7, 12, 238, 494);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", "2");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-right " + /*customClass*/ ctx[1]);
			add_location(svg, file$7, 12, 0, 256);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-chevron-right " + /*customClass*/ ctx[1])) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	const writable_props = ["size", "class"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChevronRightIcon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ChevronRightIcon", $$slots, []);

	$$self.$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
	};

	$$self.$capture_state = () => ({ size, customClass });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, customClass];
}

class ChevronRightIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { size: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronRightIcon",
			options,
			id: create_fragment$7.name
		});
	}

	get size() {
		throw new Error("<ChevronRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<ChevronRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ChevronRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ChevronRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_components\Clan.svelte generated by Svelte v3.23.2 */
const file$8 = "src\\routes\\_components\\Clan.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (43:12) <span class="control" slot="left-control">
function create_left_control_slot(ctx) {
	let span;
	let chevronlefticon;
	let current;
	chevronlefticon = new ChevronLeftIcon({ $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(chevronlefticon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true, slot: true });
			var span_nodes = children(span);
			claim_component(chevronlefticon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "control svelte-2hkkbd");
			attr_dev(span, "slot", "left-control");
			add_location(span, file$8, 42, 12, 2059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(chevronlefticon, span, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(chevronlefticon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(chevronlefticon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(chevronlefticon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_left_control_slot.name,
		type: "slot",
		source: "(43:12) <span class=\\\"control\\\" slot=\\\"left-control\\\">",
		ctx
	});

	return block;
}

// (46:12) {#each photos as photo}
function create_each_block_1(ctx) {
	let div;
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*photo*/ ctx[5])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "pic");
			attr_dev(img, "class", "svelte-2hkkbd");
			add_location(img, file$8, 47, 16, 2255);
			attr_dev(div, "class", "slide-content svelte-2hkkbd");
			add_location(div, file$8, 46, 12, 2210);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(46:12) {#each photos as photo}",
		ctx
	});

	return block;
}

// (51:12) <span class="control" slot="right-control">
function create_right_control_slot(ctx) {
	let span;
	let chevronrighticon;
	let current;
	chevronrighticon = new ChevronRightIcon({ $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(chevronrighticon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true, slot: true });
			var span_nodes = children(span);
			claim_component(chevronrighticon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "control svelte-2hkkbd");
			attr_dev(span, "slot", "right-control");
			add_location(span, file$8, 50, 12, 2337);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(chevronrighticon, span, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(chevronrighticon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(chevronrighticon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(chevronrighticon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_right_control_slot.name,
		type: "slot",
		source: "(51:12) <span class=\\\"control\\\" slot=\\\"right-control\\\">",
		ctx
	});

	return block;
}

// (42:8) <Carousel {...carousel}>
function create_default_slot(ctx) {
	let t0;
	let t1;
	let each_value_1 = /*photos*/ ctx[1];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
		},
		l: function claim(nodes) {
			t0 = claim_space(nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*photos*/ 2) {
				each_value_1 = /*photos*/ ctx[1];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(t1.parentNode, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(42:8) <Carousel {...carousel}>",
		ctx
	});

	return block;
}

// (41:8) {#each carousels as carousel}
function create_each_block$1(ctx) {
	let carousel;
	let t0;
	let br0;
	let t1;
	let br1;
	let current;
	const carousel_spread_levels = [/*carousel*/ ctx[2]];

	let carousel_props = {
		$$slots: {
			default: [create_default_slot],
			"right-control": [create_right_control_slot],
			"left-control": [create_left_control_slot]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < carousel_spread_levels.length; i += 1) {
		carousel_props = assign(carousel_props, carousel_spread_levels[i]);
	}

	carousel = new Carousel({ props: carousel_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(carousel.$$.fragment);
			t0 = space();
			br0 = element("br");
			t1 = space();
			br1 = element("br");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(carousel.$$.fragment, nodes);
			t0 = claim_space(nodes);
			br0 = claim_element(nodes, "BR", {});
			t1 = claim_space(nodes);
			br1 = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			add_location(br0, file$8, 54, 8, 2470);
			add_location(br1, file$8, 55, 8, 2485);
		},
		m: function mount(target, anchor) {
			mount_component(carousel, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, br1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const carousel_changes = (dirty & /*carousels*/ 1)
			? get_spread_update(carousel_spread_levels, [get_spread_object(/*carousel*/ ctx[2])])
			: {};

			if (dirty & /*$$scope*/ 256) {
				carousel_changes.$$scope = { dirty, ctx };
			}

			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(carousel, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(41:8) {#each carousels as carousel}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let section;
	let sectionheader;
	let t;
	let div;
	let current;

	sectionheader = new SectionHeader({
			props: { title: "Our Clan" },
			$$inline: true
		});

	let each_value = /*carousels*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			section = element("section");
			create_component(sectionheader.$$.fragment);
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(sectionheader.$$.fragment, section_nodes);
			t = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "demo svelte-2hkkbd");
			add_location(div, file$8, 39, 4, 1954);
			attr_dev(section, "class", "clan");
			add_location(section, file$8, 37, 0, 1885);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(sectionheader, section, null);
			append_dev(section, t);
			append_dev(section, div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*carousels, photos*/ 3) {
				each_value = /*carousels*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sectionheader.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(sectionheader.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(sectionheader);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let carousels = [{ perPage: 1 }];

	let photos = [
		"https://lisaandtimpictures.s3.amazonaws.com/GrandchildrenWithBarb.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/Cheese.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/MovingDay.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/FireAndIce.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/WithLiam.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/Lake.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/WithNora.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/Masks.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/CarenaAndDog.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/Masks2.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/RhiannahAndAdam.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/SportsBar.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/SummerAndClan.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/StPatricksDay.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/ToryAndCarenaAndBri.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/ToryAndClan.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/AustinAndClan.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/Grandchildren.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/ShannonAndClan.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/WithRhiannah.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/LisaAndAdam.jpg",
		"https://lisaandtimpictures.s3.amazonaws.com/NanaAndPoppop.jpg"
	];

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Clan> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Clan", $$slots, []);

	$$self.$capture_state = () => ({
		SectionHeader,
		Carousel,
		ChevronLeftIcon,
		ChevronRightIcon,
		carousels,
		photos
	});

	$$self.$inject_state = $$props => {
		if ("carousels" in $$props) $$invalidate(0, carousels = $$props.carousels);
		if ("photos" in $$props) $$invalidate(1, photos = $$props.photos);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [carousels, photos];
}

class Clan extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Clan",
			options,
			id: create_fragment$8.name
		});
	}
}

/* src\routes\_components\ToastForm.svelte generated by Svelte v3.23.2 */
const file$9 = "src\\routes\\_components\\ToastForm.svelte";

// (40:12) {:else}
function create_else_block_1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Propose a Toast...");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Propose a Toast...");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "heading svelte-vdh3ji");
			add_location(p, file$9, 40, 16, 1232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(40:12) {:else}",
		ctx
	});

	return block;
}

// (38:12) {#if isEdittingToast}
function create_if_block_3(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Editting Toast...");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Editting Toast...");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "heading svelte-vdh3ji");
			add_location(p, file$9, 38, 16, 1153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(38:12) {#if isEdittingToast}",
		ctx
	});

	return block;
}

// (68:8) {#if !isLoggedIn}
function create_if_block_2(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Log in with Facebook to Propose");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Log in with Facebook to Propose");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "facebook-button svelte-vdh3ji");
			add_location(button, file$9, 68, 12, 2573);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*logIn*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(68:8) {#if !isLoggedIn}",
		ctx
	});

	return block;
}

// (71:8) {#if isLoggedIn}
function create_if_block$1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*isEdittingToast*/ ctx[2]) return create_if_block_1$1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(71:8) {#if isLoggedIn}",
		ctx
	});

	return block;
}

// (74:12) {:else}
function create_else_block(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Propose!");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Propose!");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "propose-button svelte-vdh3ji");
			add_location(button, file$9, 74, 16, 2865);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*proposeToast*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(74:12) {:else}",
		ctx
	});

	return block;
}

// (72:12) {#if isEdittingToast}
function create_if_block_1$1(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Update!");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Update!");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "propose-button svelte-vdh3ji");
			add_location(button, file$9, 72, 16, 2756);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*updateToast*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(72:12) {#if isEdittingToast}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let section;
	let div5;
	let div0;
	let t0;
	let input;
	let input_disabled_value;
	let t1;
	let div4;
	let div1;
	let select0;
	let option0;
	let t2;
	let option1;
	let t3;
	let option2;
	let t4;
	let option3;
	let t5;
	let option4;
	let t6;
	let option5;
	let t7;
	let option6;
	let t8;
	let option7;
	let t9;
	let select0_disabled_value;
	let t10;
	let div2;
	let t11;
	let t12;
	let div3;
	let select1;
	let option8;
	let t13;
	let option9;
	let t14;
	let select1_disabled_value;
	let t15;
	let textarea;
	let textarea_disabled_value;
	let t16;
	let br;
	let t17;
	let t18;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*isEdittingToast*/ ctx[2]) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = !/*isLoggedIn*/ ctx[1] && create_if_block_2(ctx);
	let if_block2 = /*isLoggedIn*/ ctx[1] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			section = element("section");
			div5 = element("div");
			div0 = element("div");
			if_block0.c();
			t0 = space();
			input = element("input");
			t1 = space();
			div4 = element("div");
			div1 = element("div");
			select0 = element("select");
			option0 = element("option");
			t2 = text("Father");
			option1 = element("option");
			t3 = text("Mother");
			option2 = element("option");
			t4 = text("Brother");
			option3 = element("option");
			t5 = text("Sister");
			option4 = element("option");
			t6 = text("Son");
			option5 = element("option");
			t7 = text("Daughter");
			option6 = element("option");
			t8 = text("Relative");
			option7 = element("option");
			t9 = text("Friend");
			t10 = space();
			div2 = element("div");
			t11 = text("of the");
			t12 = space();
			div3 = element("div");
			select1 = element("select");
			option8 = element("option");
			t13 = text("Groom");
			option9 = element("option");
			t14 = text("Bride");
			t15 = space();
			textarea = element("textarea");
			t16 = space();
			br = element("br");
			t17 = space();
			if (if_block1) if_block1.c();
			t18 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div5 = claim_element(section_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div0 = claim_element(div5_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div5_nodes);

			input = claim_element(div5_nodes, "INPUT", {
				type: true,
				disabled: true,
				placeholder: true,
				class: true
			});

			t1 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			select0 = claim_element(div1_nodes, "SELECT", { disabled: true, class: true });
			var select0_nodes = children(select0);
			option0 = claim_element(select0_nodes, "OPTION", { value: true, selected: true });
			var option0_nodes = children(option0);
			t2 = claim_text(option0_nodes, "Father");
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(select0_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t3 = claim_text(option1_nodes, "Mother");
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(select0_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t4 = claim_text(option2_nodes, "Brother");
			option2_nodes.forEach(detach_dev);
			option3 = claim_element(select0_nodes, "OPTION", { value: true });
			var option3_nodes = children(option3);
			t5 = claim_text(option3_nodes, "Sister");
			option3_nodes.forEach(detach_dev);
			option4 = claim_element(select0_nodes, "OPTION", { value: true });
			var option4_nodes = children(option4);
			t6 = claim_text(option4_nodes, "Son");
			option4_nodes.forEach(detach_dev);
			option5 = claim_element(select0_nodes, "OPTION", { value: true });
			var option5_nodes = children(option5);
			t7 = claim_text(option5_nodes, "Daughter");
			option5_nodes.forEach(detach_dev);
			option6 = claim_element(select0_nodes, "OPTION", { value: true });
			var option6_nodes = children(option6);
			t8 = claim_text(option6_nodes, "Relative");
			option6_nodes.forEach(detach_dev);
			option7 = claim_element(select0_nodes, "OPTION", { value: true });
			var option7_nodes = children(option7);
			t9 = claim_text(option7_nodes, "Friend");
			option7_nodes.forEach(detach_dev);
			select0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t10 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t11 = claim_text(div2_nodes, "of the");
			div2_nodes.forEach(detach_dev);
			t12 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			select1 = claim_element(div3_nodes, "SELECT", { disabled: true, class: true });
			var select1_nodes = children(select1);
			option8 = claim_element(select1_nodes, "OPTION", { value: true, selected: true });
			var option8_nodes = children(option8);
			t13 = claim_text(option8_nodes, "Groom");
			option8_nodes.forEach(detach_dev);
			option9 = claim_element(select1_nodes, "OPTION", { value: true });
			var option9_nodes = children(option9);
			t14 = claim_text(option9_nodes, "Bride");
			option9_nodes.forEach(detach_dev);
			select1_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t15 = claim_space(div5_nodes);

			textarea = claim_element(div5_nodes, "TEXTAREA", {
				disabled: true,
				rows: true,
				placeholder: true,
				class: true
			});

			children(textarea).forEach(detach_dev);
			t16 = claim_space(div5_nodes);
			br = claim_element(div5_nodes, "BR", {});
			t17 = claim_space(div5_nodes);
			if (if_block1) if_block1.l(div5_nodes);
			t18 = claim_space(div5_nodes);
			if (if_block2) if_block2.l(div5_nodes);
			div5_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "header svelte-vdh3ji");
			add_location(div0, file$9, 36, 8, 1080);
			attr_dev(input, "type", "text");
			input.disabled = input_disabled_value = !/*isLoggedIn*/ ctx[1];
			attr_dev(input, "placeholder", "Name");
			attr_dev(input, "class", "svelte-vdh3ji");
			add_location(input, file$9, 43, 8, 1318);
			option0.__value = "Father";
			option0.value = option0.__value;
			option0.selected = true;
			add_location(option0, file$9, 47, 16, 1581);
			option1.__value = "Mother";
			option1.value = option1.__value;
			add_location(option1, file$9, 48, 16, 1646);
			option2.__value = "Brother";
			option2.value = option2.__value;
			add_location(option2, file$9, 49, 16, 1702);
			option3.__value = "Sister";
			option3.value = option3.__value;
			add_location(option3, file$9, 50, 16, 1760);
			option4.__value = "Son";
			option4.value = option4.__value;
			add_location(option4, file$9, 51, 16, 1816);
			option5.__value = "Daughter";
			option5.value = option5.__value;
			add_location(option5, file$9, 52, 16, 1866);
			option6.__value = "Relative";
			option6.value = option6.__value;
			add_location(option6, file$9, 53, 16, 1926);
			option7.__value = "Friend";
			option7.value = option7.__value;
			add_location(option7, file$9, 54, 16, 1986);
			select0.disabled = select0_disabled_value = !/*isLoggedIn*/ ctx[1];
			attr_dev(select0, "class", "svelte-vdh3ji");
			if (/*toast*/ ctx[0].toasterRelationship === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[8].call(select0));
			add_location(select0, file$9, 46, 12, 1493);
			attr_dev(div1, "class", "selectstuff svelte-vdh3ji");
			add_location(div1, file$9, 45, 8, 1454);
			attr_dev(div2, "class", "selectstuff svelte-vdh3ji");
			add_location(div2, file$9, 57, 8, 2073);
			option8.__value = "Groom";
			option8.value = option8.__value;
			option8.selected = true;
			add_location(option8, file$9, 60, 16, 2246);
			option9.__value = "Bride";
			option9.value = option9.__value;
			add_location(option9, file$9, 61, 16, 2309);
			select1.disabled = select1_disabled_value = !/*isLoggedIn*/ ctx[1];
			attr_dev(select1, "class", "svelte-vdh3ji");
			if (/*toast*/ ctx[0].toasterAssociation === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[9].call(select1));
			add_location(select1, file$9, 59, 12, 2159);
			attr_dev(div3, "class", "selectstuff svelte-vdh3ji");
			add_location(div3, file$9, 58, 8, 2120);
			attr_dev(div4, "class", "container svelte-vdh3ji");
			add_location(div4, file$9, 44, 8, 1421);
			textarea.disabled = textarea_disabled_value = !/*isLoggedIn*/ ctx[1];
			attr_dev(textarea, "rows", "7");
			attr_dev(textarea, "placeholder", "Message");
			attr_dev(textarea, "class", "svelte-vdh3ji");
			add_location(textarea, file$9, 65, 8, 2410);
			add_location(br, file$9, 66, 8, 2527);
			attr_dev(div5, "class", "form svelte-vdh3ji");
			add_location(div5, file$9, 35, 4, 1052);
			attr_dev(section, "class", "propose");
			add_location(section, file$9, 34, 0, 1021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div5);
			append_dev(div5, div0);
			if_block0.m(div0, null);
			append_dev(div5, t0);
			append_dev(div5, input);
			set_input_value(input, /*toast*/ ctx[0].toasterName);
			append_dev(div5, t1);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div1, select0);
			append_dev(select0, option0);
			append_dev(option0, t2);
			append_dev(select0, option1);
			append_dev(option1, t3);
			append_dev(select0, option2);
			append_dev(option2, t4);
			append_dev(select0, option3);
			append_dev(option3, t5);
			append_dev(select0, option4);
			append_dev(option4, t6);
			append_dev(select0, option5);
			append_dev(option5, t7);
			append_dev(select0, option6);
			append_dev(option6, t8);
			append_dev(select0, option7);
			append_dev(option7, t9);
			select_option(select0, /*toast*/ ctx[0].toasterRelationship);
			append_dev(div4, t10);
			append_dev(div4, div2);
			append_dev(div2, t11);
			append_dev(div4, t12);
			append_dev(div4, div3);
			append_dev(div3, select1);
			append_dev(select1, option8);
			append_dev(option8, t13);
			append_dev(select1, option9);
			append_dev(option9, t14);
			select_option(select1, /*toast*/ ctx[0].toasterAssociation);
			append_dev(div5, t15);
			append_dev(div5, textarea);
			set_input_value(textarea, /*toast*/ ctx[0].toastContent);
			append_dev(div5, t16);
			append_dev(div5, br);
			append_dev(div5, t17);
			if (if_block1) if_block1.m(div5, null);
			append_dev(div5, t18);
			if (if_block2) if_block2.m(div5, null);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
					listen_dev(select0, "change", /*select0_change_handler*/ ctx[8]),
					listen_dev(select1, "change", /*select1_change_handler*/ ctx[9]),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[10])
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div0, null);
				}
			}

			if (dirty & /*isLoggedIn*/ 2 && input_disabled_value !== (input_disabled_value = !/*isLoggedIn*/ ctx[1])) {
				prop_dev(input, "disabled", input_disabled_value);
			}

			if (dirty & /*toast*/ 1 && input.value !== /*toast*/ ctx[0].toasterName) {
				set_input_value(input, /*toast*/ ctx[0].toasterName);
			}

			if (dirty & /*isLoggedIn*/ 2 && select0_disabled_value !== (select0_disabled_value = !/*isLoggedIn*/ ctx[1])) {
				prop_dev(select0, "disabled", select0_disabled_value);
			}

			if (dirty & /*toast*/ 1) {
				select_option(select0, /*toast*/ ctx[0].toasterRelationship);
			}

			if (dirty & /*isLoggedIn*/ 2 && select1_disabled_value !== (select1_disabled_value = !/*isLoggedIn*/ ctx[1])) {
				prop_dev(select1, "disabled", select1_disabled_value);
			}

			if (dirty & /*toast*/ 1) {
				select_option(select1, /*toast*/ ctx[0].toasterAssociation);
			}

			if (dirty & /*isLoggedIn*/ 2 && textarea_disabled_value !== (textarea_disabled_value = !/*isLoggedIn*/ ctx[1])) {
				prop_dev(textarea, "disabled", textarea_disabled_value);
			}

			if (dirty & /*toast*/ 1) {
				set_input_value(textarea, /*toast*/ ctx[0].toastContent);
			}

			if (!/*isLoggedIn*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(div5, t18);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*isLoggedIn*/ ctx[1]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$1(ctx);
					if_block2.c();
					if_block2.m(div5, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	
	const dispatch = createEventDispatcher();
	let { isLoggedIn } = $$props;
	let { facebookUserId } = $$props;
	let { toast } = $$props;
	let { isEdittingToast } = $$props;

	async function proposeToast() {
		if (toast.toasterName == "" || toast.toastContent == "") {
			return;
		}

		$$invalidate(0, toast.toasterFacebookId = facebookUserId, toast);

		await fetch("/api/toastController", {
			method: "POST",
			body: JSON.stringify({ toast }),
			headers: { "Content-type": "application/json" }
		}).then(response => window.location.reload());
	}

	

	async function updateToast() {
		if (toast.toasterName == "" || toast.toastContent == "") {
			return;
		}

		await fetch("/api/toastController", {
			method: "PUT",
			body: JSON.stringify({ toast }),
			headers: { "Content-type": "application/json" }
		}).then(response => window.location.reload());
	}

	function logIn() {
		dispatch("toggleLogIn");
	}

	const writable_props = ["isLoggedIn", "facebookUserId", "toast", "isEdittingToast"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToastForm> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ToastForm", $$slots, []);

	function input_input_handler() {
		toast.toasterName = this.value;
		$$invalidate(0, toast);
	}

	function select0_change_handler() {
		toast.toasterRelationship = select_value(this);
		$$invalidate(0, toast);
	}

	function select1_change_handler() {
		toast.toasterAssociation = select_value(this);
		$$invalidate(0, toast);
	}

	function textarea_input_handler() {
		toast.toastContent = this.value;
		$$invalidate(0, toast);
	}

	$$self.$set = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(1, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(6, facebookUserId = $$props.facebookUserId);
		if ("toast" in $$props) $$invalidate(0, toast = $$props.toast);
		if ("isEdittingToast" in $$props) $$invalidate(2, isEdittingToast = $$props.isEdittingToast);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		dispatch,
		isLoggedIn,
		facebookUserId,
		toast,
		isEdittingToast,
		proposeToast,
		updateToast,
		logIn
	});

	$$self.$inject_state = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(1, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(6, facebookUserId = $$props.facebookUserId);
		if ("toast" in $$props) $$invalidate(0, toast = $$props.toast);
		if ("isEdittingToast" in $$props) $$invalidate(2, isEdittingToast = $$props.isEdittingToast);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		toast,
		isLoggedIn,
		isEdittingToast,
		proposeToast,
		updateToast,
		logIn,
		facebookUserId,
		input_input_handler,
		select0_change_handler,
		select1_change_handler,
		textarea_input_handler
	];
}

class ToastForm extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			isLoggedIn: 1,
			facebookUserId: 6,
			toast: 0,
			isEdittingToast: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToastForm",
			options,
			id: create_fragment$9.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isLoggedIn*/ ctx[1] === undefined && !("isLoggedIn" in props)) {
			console.warn("<ToastForm> was created without expected prop 'isLoggedIn'");
		}

		if (/*facebookUserId*/ ctx[6] === undefined && !("facebookUserId" in props)) {
			console.warn("<ToastForm> was created without expected prop 'facebookUserId'");
		}

		if (/*toast*/ ctx[0] === undefined && !("toast" in props)) {
			console.warn("<ToastForm> was created without expected prop 'toast'");
		}

		if (/*isEdittingToast*/ ctx[2] === undefined && !("isEdittingToast" in props)) {
			console.warn("<ToastForm> was created without expected prop 'isEdittingToast'");
		}
	}

	get isLoggedIn() {
		throw new Error("<ToastForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoggedIn(value) {
		throw new Error("<ToastForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facebookUserId() {
		throw new Error("<ToastForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facebookUserId(value) {
		throw new Error("<ToastForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toast() {
		throw new Error("<ToastForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toast(value) {
		throw new Error("<ToastForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isEdittingToast() {
		throw new Error("<ToastForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isEdittingToast(value) {
		throw new Error("<ToastForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function getEventsAction(component) {
    return node => {
      const events = Object.keys(component.$$.callbacks);
      const listeners = [];

      events.forEach(
          event => listeners.push(
              listen(node, event, e =>  bubble(component, e))
            )
        );
  
      return {
        destroy: () => {
            listeners.forEach(
                listener => listener()
            );
        }
      }
    };
}

/* node_modules\svelte-chota\cmp\Card.svelte generated by Svelte v3.23.2 */
const file$a = "node_modules\\svelte-chota\\cmp\\Card.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (12:0) {#if is_header}
function create_if_block_1$2(ctx) {
	let header;
	let current;
	const header_slot_template = /*$$slots*/ ctx[5].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[4], get_header_slot_context);

	const block = {
		c: function create() {
			header = element("header");
			if (header_slot) header_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", {});
			var header_nodes = children(header);
			if (header_slot) header_slot.l(header_nodes);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(header, file$a, 12, 1, 392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);

			if (header_slot) {
				header_slot.m(header, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(12:0) {#if is_header}",
		ctx
	});

	return block;
}

// (18:0) {#if is_footer}
function create_if_block$2(ctx) {
	let footer;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[5].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[4], get_footer_slot_context);

	const block = {
		c: function create() {
			footer = element("footer");
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", {});
			var footer_nodes = children(footer);
			if (footer_slot) footer_slot.l(footer_nodes);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(footer, file$a, 18, 1, 485);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);

			if (footer_slot) {
				footer_slot.m(footer, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (footer_slot) {
				if (footer_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(18:0) {#if is_footer}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div;
	let t0;
	let t1;
	let events_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*is_header*/ ctx[1] && create_if_block_1$2(ctx);
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let if_block1 = /*is_footer*/ ctx[2] && create_if_block$2(ctx);
	let div_levels = [/*$$restProps*/ ctx[3]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			toggle_class(div, "card", 1);
			add_location(div, file$a, 10, 0, 326);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[0].call(null, div));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*is_header*/ ctx[1]) if_block0.p(ctx, dirty);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (/*is_footer*/ ctx[2]) if_block1.p(ctx, dirty);
			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			toggle_class(div, "card", 1);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	const events = getEventsAction(current_component);
	let is_header = $$props.$$slots && $$props.$$slots.header !== undefined;
	let is_footer = $$props.$$slots && $$props.$$slots.footer !== undefined;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Card", $$slots, ['header','default','footer']);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getEventsAction,
		current_component,
		events,
		is_header,
		is_footer
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("is_header" in $$props) $$invalidate(1, is_header = $$new_props.is_header);
		if ("is_footer" in $$props) $$invalidate(2, is_footer = $$new_props.is_footer);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [events, is_header, is_footer, $$restProps, $$scope, $$slots];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment$a.name
		});
	}
}

/* node_modules\svelte-chota\cmp\Icon.svelte generated by Svelte v3.23.2 */
const file$b = "node_modules\\svelte-chota\\cmp\\Icon.svelte";

// (80:0) {:else}
function create_else_block$1(ctx) {
	let svg;
	let events_action;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*spin*/ ctx[0] !== false) return create_if_block_2$1;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);
	let svg_levels = [{ viewBox: "0 0 24 24" }, { style: /*style*/ ctx[6] }, /*$$restProps*/ ctx[9]];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { viewBox: true, style: true }, 1);
			var svg_nodes = children(svg);
			if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			toggle_class(svg, "svelte-ns2tqd", true);
			add_location(svg, file$b, 80, 1, 2115);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if_block.m(svg, null);

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[8].call(null, svg));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ viewBox: "0 0 24 24" },
				dirty & /*style*/ 64 && { style: /*style*/ ctx[6] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
			]));

			toggle_class(svg, "svelte-ns2tqd", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(80:0) {:else}",
		ctx
	});

	return block;
}

// (76:14) 
function create_if_block_1$3(ctx) {
	let svg;
	let use_1;
	let events_action;
	let mounted;
	let dispose;
	let svg_levels = [{ viewBox: "0 0 24 24" }, { style: /*style*/ ctx[6] }, /*$$restProps*/ ctx[9]];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			use_1 = svg_element("use");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { viewBox: true, style: true }, 1);
			var svg_nodes = children(svg);

			use_1 = claim_element(
				svg_nodes,
				"use",
				{
					"xlink:href": true,
					style: true,
					class: true
				},
				1
			);

			children(use_1).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			xlink_attr(use_1, "xlink:href", /*use*/ ctx[2]);
			attr_dev(use_1, "style", /*aniStyle*/ ctx[7]);
			attr_dev(use_1, "class", "svelte-ns2tqd");
			toggle_class(use_1, "spinCW", /*spinCW*/ ctx[4]);
			toggle_class(use_1, "spinCCW", /*spinCCW*/ ctx[5]);
			add_location(use_1, file$b, 77, 2, 2025);
			set_svg_attributes(svg, svg_data);
			toggle_class(svg, "svelte-ns2tqd", true);
			add_location(svg, file$b, 76, 1, 1961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, use_1);

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[8].call(null, svg));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*use*/ 4) {
				xlink_attr(use_1, "xlink:href", /*use*/ ctx[2]);
			}

			if (dirty & /*aniStyle*/ 128) {
				attr_dev(use_1, "style", /*aniStyle*/ ctx[7]);
			}

			if (dirty & /*spinCW*/ 16) {
				toggle_class(use_1, "spinCW", /*spinCW*/ ctx[4]);
			}

			if (dirty & /*spinCCW*/ 32) {
				toggle_class(use_1, "spinCCW", /*spinCCW*/ ctx[5]);
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ viewBox: "0 0 24 24" },
				dirty & /*style*/ 64 && { style: /*style*/ ctx[6] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
			]));

			toggle_class(svg, "svelte-ns2tqd", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(76:14) ",
		ctx
	});

	return block;
}

// (72:0) {#if url}
function create_if_block$3(ctx) {
	let span;
	let img;
	let img_src_value;
	let events_action;
	let mounted;
	let dispose;
	let span_levels = [{ style: /*style*/ ctx[6] }, /*$$restProps*/ ctx[9]];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);

			img = claim_element(span_nodes, "IMG", {
				src: true,
				alt: true,
				width: true,
				height: true,
				style: true,
				class: true
			});

			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*url*/ ctx[3])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "width", "100%");
			attr_dev(img, "height", "100%");
			attr_dev(img, "style", /*aniStyle*/ ctx[7]);
			attr_dev(img, "class", "svelte-ns2tqd");
			toggle_class(img, "spinCW", /*spinCW*/ ctx[4]);
			toggle_class(img, "spinCCW", /*spinCCW*/ ctx[5]);
			add_location(img, file$b, 73, 2, 1838);
			set_attributes(span, span_data);
			toggle_class(span, "svelte-ns2tqd", true);
			add_location(span, file$b, 72, 1, 1793);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, img);

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[8].call(null, span));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*url*/ 8 && img.src !== (img_src_value = /*url*/ ctx[3])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*aniStyle*/ 128) {
				attr_dev(img, "style", /*aniStyle*/ ctx[7]);
			}

			if (dirty & /*spinCW*/ 16) {
				toggle_class(img, "spinCW", /*spinCW*/ ctx[4]);
			}

			if (dirty & /*spinCCW*/ 32) {
				toggle_class(img, "spinCCW", /*spinCCW*/ ctx[5]);
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*style*/ 64 && { style: /*style*/ ctx[6] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
			]));

			toggle_class(span, "svelte-ns2tqd", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(72:0) {#if url}",
		ctx
	});

	return block;
}

// (86:1) {:else}
function create_else_block_1$1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", /*path*/ ctx[1]);
			add_location(path_1, file$b, 86, 2, 2293);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*path*/ 2) {
				attr_dev(path_1, "d", /*path*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(86:1) {:else}",
		ctx
	});

	return block;
}

// (82:1) {#if spin !== false}
function create_if_block_2$1(ctx) {
	let g;
	let path_1;

	const block = {
		c: function create() {
			g = svg_element("g");
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			g = claim_element(nodes, "g", { style: true, class: true }, 1);
			var g_nodes = children(g);
			path_1 = claim_element(g_nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", /*path*/ ctx[1]);
			add_location(path_1, file$b, 83, 3, 2252);
			attr_dev(g, "style", /*aniStyle*/ ctx[7]);
			attr_dev(g, "class", "svelte-ns2tqd");
			toggle_class(g, "spinCW", /*spinCW*/ ctx[4]);
			toggle_class(g, "spinCCW", /*spinCCW*/ ctx[5]);
			add_location(g, file$b, 82, 2, 2201);
		},
		m: function mount(target, anchor) {
			insert_dev(target, g, anchor);
			append_dev(g, path_1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*path*/ 2) {
				attr_dev(path_1, "d", /*path*/ ctx[1]);
			}

			if (dirty & /*aniStyle*/ 128) {
				attr_dev(g, "style", /*aniStyle*/ ctx[7]);
			}

			if (dirty & /*spinCW*/ 16) {
				toggle_class(g, "spinCW", /*spinCW*/ ctx[4]);
			}

			if (dirty & /*spinCCW*/ 32) {
				toggle_class(g, "spinCCW", /*spinCCW*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(82:1) {#if spin !== false}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*url*/ ctx[3]) return create_if_block$3;
		if (/*use*/ ctx[2]) return create_if_block_1$3;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["src","size","color","flipH","flipV","rotate","spin"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	const events = getEventsAction(current_component);
	let { src = null } = $$props;
	let { size = 1 } = $$props;
	let { color = null } = $$props;
	let { flipH = null } = $$props;
	let { flipV = null } = $$props;
	let { rotate = 0 } = $$props;
	let { spin = false } = $$props;
	let path = false;
	let use = false;
	let url = false;

	// size
	if (Number(size)) size = Number(size);

	// styles
	const getStyles = () => {
		const transform = [];
		const styles = [];

		if (size !== null) {
			const width = typeof size === "string" ? size : `${size * 1.5}rem`;
			styles.push(["width", width]);
			styles.push(["height", width]);
		}

		styles.push(["fill", color !== null ? color : "currentColor"]);

		if (flipH) {
			transform.push("scaleX(-1)");
		}

		if (flipV) {
			transform.push("scaleY(-1)");
		}

		if (rotate != 0) {
			transform.push(`rotate(${rotate}deg)`);
		}

		if (transform.length > 0) {
			styles.push(["transform", transform.join(" ")]);
			styles.push(["transform-origin", "center"]);
		}

		return styles.reduce(
			(cur, item) => {
				return `${cur} ${item[0]}:${item[1]};`;
			},
			""
		);
	};

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Icon", $$slots, []);

	$$self.$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("src" in $$new_props) $$invalidate(11, src = $$new_props.src);
		if ("size" in $$new_props) $$invalidate(10, size = $$new_props.size);
		if ("color" in $$new_props) $$invalidate(12, color = $$new_props.color);
		if ("flipH" in $$new_props) $$invalidate(13, flipH = $$new_props.flipH);
		if ("flipV" in $$new_props) $$invalidate(14, flipV = $$new_props.flipV);
		if ("rotate" in $$new_props) $$invalidate(15, rotate = $$new_props.rotate);
		if ("spin" in $$new_props) $$invalidate(0, spin = $$new_props.spin);
	};

	$$self.$capture_state = () => ({
		getEventsAction,
		current_component,
		events,
		src,
		size,
		color,
		flipH,
		flipV,
		rotate,
		spin,
		path,
		use,
		url,
		getStyles,
		inverse,
		spintime,
		spinCW,
		spinCCW,
		style,
		aniStyle
	});

	$$self.$inject_state = $$new_props => {
		if ("src" in $$props) $$invalidate(11, src = $$new_props.src);
		if ("size" in $$props) $$invalidate(10, size = $$new_props.size);
		if ("color" in $$props) $$invalidate(12, color = $$new_props.color);
		if ("flipH" in $$props) $$invalidate(13, flipH = $$new_props.flipH);
		if ("flipV" in $$props) $$invalidate(14, flipV = $$new_props.flipV);
		if ("rotate" in $$props) $$invalidate(15, rotate = $$new_props.rotate);
		if ("spin" in $$props) $$invalidate(0, spin = $$new_props.spin);
		if ("path" in $$props) $$invalidate(1, path = $$new_props.path);
		if ("use" in $$props) $$invalidate(2, use = $$new_props.use);
		if ("url" in $$props) $$invalidate(3, url = $$new_props.url);
		if ("inverse" in $$props) $$invalidate(16, inverse = $$new_props.inverse);
		if ("spintime" in $$props) $$invalidate(17, spintime = $$new_props.spintime);
		if ("spinCW" in $$props) $$invalidate(4, spinCW = $$new_props.spinCW);
		if ("spinCCW" in $$props) $$invalidate(5, spinCCW = $$new_props.spinCCW);
		if ("style" in $$props) $$invalidate(6, style = $$new_props.style);
		if ("aniStyle" in $$props) $$invalidate(7, aniStyle = $$new_props.aniStyle);
	};

	let inverse;
	let spintime;
	let spinCW;
	let spinCCW;
	let style;
	let aniStyle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*src*/ 2048) {
			//Icon source
			 if (!!src && src.toLowerCase().trim().endsWith(".svg")) {
				$$invalidate(3, url = src);
				$$invalidate(1, path = $$invalidate(2, use = false));
			} else if (!!src && src.toLowerCase().trim().includes(".svg#")) {
				$$invalidate(2, use = src);
				$$invalidate(3, url = $$invalidate(1, path = false));
			} else if (!!src) {
				$$invalidate(1, path = src);
				$$invalidate(3, url = $$invalidate(2, use = false));
			}
		}

		if ($$self.$$.dirty & /*spin*/ 1) {
			// SPIN properties
			 $$invalidate(16, inverse = typeof spin !== "boolean" && spin < 0 ? true : false);
		}

		if ($$self.$$.dirty & /*spin*/ 1) {
			 $$invalidate(17, spintime = Math.abs(spin === true ? 2 : spin));
		}

		if ($$self.$$.dirty & /*spin, inverse*/ 65537) {
			 $$invalidate(4, spinCW = !!spin && !inverse);
		}

		if ($$self.$$.dirty & /*spin, inverse*/ 65537) {
			 $$invalidate(5, spinCCW = !!spin && inverse);
		}

		if ($$self.$$.dirty & /*size, color, flipH, flipV, rotate*/ 62464) {
			 $$invalidate(6, style = getStyles());
		}

		if ($$self.$$.dirty & /*spin, spintime*/ 131073) {
			 $$invalidate(7, aniStyle = !!spin ? `animation-duration: ${spintime}s` : undefined);
		}
	};

	return [
		spin,
		path,
		use,
		url,
		spinCW,
		spinCCW,
		style,
		aniStyle,
		events,
		$$restProps,
		size,
		src,
		color,
		flipH,
		flipV,
		rotate
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			src: 11,
			size: 10,
			color: 12,
			flipH: 13,
			flipV: 14,
			rotate: 15,
			spin: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$b.name
		});
	}

	get src() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flipH() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flipH(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flipV() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flipV(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rotate() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rotate(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spin() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spin(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-chota\cmp\Button.svelte generated by Svelte v3.23.2 */
const file$c = "node_modules\\svelte-chota\\cmp\\Button.svelte";

// (87:0) {:else}
function create_else_block$2(ctx) {
	let details;
	let summary;
	let t0;

	let t1_value = (/*dropdown*/ ctx[11] !== true
	? /*dropdown*/ ctx[11]
	: "") + "";

	let t1;
	let t2;
	let events_action;
	let t3;
	let card;
	let dropdownAction_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[9] && create_if_block_4(ctx);
	let if_block1 = /*iconRight*/ ctx[10] && create_if_block_3$1(ctx);
	let summary_levels = [/*$$restProps*/ ctx[17]];
	let summary_data = {};

	for (let i = 0; i < summary_levels.length; i += 1) {
		summary_data = assign(summary_data, summary_levels[i]);
	}

	card = new Card({
			props: {
				style: "z-index:1",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(card.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", {});
			var summary_nodes = children(summary);
			if (if_block0) if_block0.l(summary_nodes);
			t0 = claim_space(summary_nodes);
			t1 = claim_text(summary_nodes, t1_value);
			t2 = claim_space(summary_nodes);
			if (if_block1) if_block1.l(summary_nodes);
			summary_nodes.forEach(detach_dev);
			t3 = claim_space(details_nodes);
			claim_component(card.$$.fragment, details_nodes);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(summary, summary_data);
			toggle_class(summary, "button", 1);
			toggle_class(summary, "outline", /*outline*/ ctx[1]);
			toggle_class(summary, "primary", /*primary*/ ctx[2]);
			toggle_class(summary, "secondary", /*secondary*/ ctx[3]);
			toggle_class(summary, "dark", /*dark*/ ctx[4]);
			toggle_class(summary, "error", /*error*/ ctx[5]);
			toggle_class(summary, "success", /*success*/ ctx[6]);
			toggle_class(summary, "clear", /*clear*/ ctx[7]);
			toggle_class(summary, "loading", /*loading*/ ctx[8]);
			toggle_class(summary, "icon", /*clIcon*/ ctx[14]);
			toggle_class(summary, "icon-only", /*clIcononly*/ ctx[15]);
			toggle_class(summary, "svelte-1o5ccdl", true);
			add_location(summary, file$c, 88, 4, 2367);
			attr_dev(details, "class", "dropdown");
			add_location(details, file$c, 87, 2, 2295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			if (if_block0) if_block0.m(summary, null);
			append_dev(summary, t0);
			append_dev(summary, t1);
			append_dev(summary, t2);
			if (if_block1) if_block1.m(summary, null);
			append_dev(details, t3);
			mount_component(card, details, null);
			details.open = /*open*/ ctx[0];
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(events_action = /*events*/ ctx[16].call(null, summary)),
					listen_dev(details, "toggle", /*details_toggle_handler*/ ctx[19]),
					action_destroyer(dropdownAction_action = dropdownAction.call(null, details, /*autoclose*/ ctx[12]))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(summary, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*dropdown*/ 2048) && t1_value !== (t1_value = (/*dropdown*/ ctx[11] !== true
			? /*dropdown*/ ctx[11]
			: "") + "")) set_data_dev(t1, t1_value);

			if (/*iconRight*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*iconRight*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(summary, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(summary, summary_data = get_spread_update(summary_levels, [dirty & /*$$restProps*/ 131072 && /*$$restProps*/ ctx[17]]));
			toggle_class(summary, "button", 1);
			toggle_class(summary, "outline", /*outline*/ ctx[1]);
			toggle_class(summary, "primary", /*primary*/ ctx[2]);
			toggle_class(summary, "secondary", /*secondary*/ ctx[3]);
			toggle_class(summary, "dark", /*dark*/ ctx[4]);
			toggle_class(summary, "error", /*error*/ ctx[5]);
			toggle_class(summary, "success", /*success*/ ctx[6]);
			toggle_class(summary, "clear", /*clear*/ ctx[7]);
			toggle_class(summary, "loading", /*loading*/ ctx[8]);
			toggle_class(summary, "icon", /*clIcon*/ ctx[14]);
			toggle_class(summary, "icon-only", /*clIcononly*/ ctx[15]);
			toggle_class(summary, "svelte-1o5ccdl", true);
			const card_changes = {};

			if (dirty & /*$$scope*/ 1048576) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);

			if (dirty & /*open*/ 1) {
				details.open = /*open*/ ctx[0];
			}

			if (dropdownAction_action && is_function(dropdownAction_action.update) && dirty & /*autoclose*/ 4096) dropdownAction_action.update.call(null, /*autoclose*/ ctx[12]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(card);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(87:0) {:else}",
		ctx
	});

	return block;
}

// (64:0) {#if dropdown === false}
function create_if_block$4(ctx) {
	let button;
	let t0;
	let t1;
	let events_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[9] && create_if_block_2$2(ctx);
	const default_slot_template = /*$$slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let if_block1 = /*iconRight*/ ctx[10] && create_if_block_1$4(ctx);

	let button_levels = [
		/*$$restProps*/ ctx[17],
		{
			type: /*submit*/ ctx[13] ? "submit" : null
		}
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true });
			var button_nodes = children(button);
			if (if_block0) if_block0.l(button_nodes);
			t0 = claim_space(button_nodes);
			if (default_slot) default_slot.l(button_nodes);
			t1 = claim_space(button_nodes);
			if (if_block1) if_block1.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(button, button_data);
			toggle_class(button, "button", 1);
			toggle_class(button, "outline", /*outline*/ ctx[1]);
			toggle_class(button, "primary", /*primary*/ ctx[2]);
			toggle_class(button, "secondary", /*secondary*/ ctx[3]);
			toggle_class(button, "dark", /*dark*/ ctx[4]);
			toggle_class(button, "error", /*error*/ ctx[5]);
			toggle_class(button, "success", /*success*/ ctx[6]);
			toggle_class(button, "clear", /*clear*/ ctx[7]);
			toggle_class(button, "loading", /*loading*/ ctx[8]);
			toggle_class(button, "icon", /*clIcon*/ ctx[14]);
			toggle_class(button, "icon-only", /*clIcononly*/ ctx[15]);
			toggle_class(button, "svelte-1o5ccdl", true);
			add_location(button, file$c, 64, 0, 1789);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append_dev(button, t0);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append_dev(button, t1);
			if (if_block1) if_block1.m(button, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[16].call(null, button));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (/*iconRight*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*iconRight*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 131072 && /*$$restProps*/ ctx[17],
				dirty & /*submit*/ 8192 && {
					type: /*submit*/ ctx[13] ? "submit" : null
				}
			]));

			toggle_class(button, "button", 1);
			toggle_class(button, "outline", /*outline*/ ctx[1]);
			toggle_class(button, "primary", /*primary*/ ctx[2]);
			toggle_class(button, "secondary", /*secondary*/ ctx[3]);
			toggle_class(button, "dark", /*dark*/ ctx[4]);
			toggle_class(button, "error", /*error*/ ctx[5]);
			toggle_class(button, "success", /*success*/ ctx[6]);
			toggle_class(button, "clear", /*clear*/ ctx[7]);
			toggle_class(button, "loading", /*loading*/ ctx[8]);
			toggle_class(button, "icon", /*clIcon*/ ctx[14]);
			toggle_class(button, "icon-only", /*clIcononly*/ ctx[15]);
			toggle_class(button, "svelte-1o5ccdl", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(64:0) {#if dropdown === false}",
		ctx
	});

	return block;
}

// (106:4) {#if icon}
function create_if_block_4(ctx) {
	let span;
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: { src: /*icon*/ ctx[9], size: "24px" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon_1.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "lefticon svelte-1o5ccdl");
			add_location(span, file$c, 105, 15, 2712);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon_1, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*icon*/ 512) icon_1_changes.src = /*icon*/ ctx[9];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(106:4) {#if icon}",
		ctx
	});

	return block;
}

// (108:4) {#if iconRight}
function create_if_block_3$1(ctx) {
	let span;
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: { src: /*iconRight*/ ctx[10], size: "24px" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon_1.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "righticon svelte-1o5ccdl");
			add_location(span, file$c, 107, 20, 2844);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon_1, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*iconRight*/ 1024) icon_1_changes.src = /*iconRight*/ ctx[10];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(108:4) {#if iconRight}",
		ctx
	});

	return block;
}

// (110:4) <Card style="z-index:1">
function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(110:4) <Card style=\\\"z-index:1\\\">",
		ctx
	});

	return block;
}

// (83:0) {#if icon}
function create_if_block_2$2(ctx) {
	let span;
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: { src: /*icon*/ ctx[9], size: "24px" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon_1.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "lefticon svelte-1o5ccdl");
			add_location(span, file$c, 82, 11, 2103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon_1, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*icon*/ 512) icon_1_changes.src = /*icon*/ ctx[9];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(83:0) {#if icon}",
		ctx
	});

	return block;
}

// (85:0) {#if iconRight}
function create_if_block_1$4(ctx) {
	let span;
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: { src: /*iconRight*/ ctx[10], size: "24px" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon_1.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "righticon svelte-1o5ccdl");
			add_location(span, file$c, 84, 16, 2201);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon_1, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*iconRight*/ 1024) icon_1_changes.src = /*iconRight*/ ctx[10];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(85:0) {#if iconRight}",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*dropdown*/ ctx[11] === false) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function dropdownAction(node, param) {
	let autoclose = param;
	let button = node.getElementsByTagName("summary")[0];

	const clickOutside = () => {
		if (!!node.open) node.open = false;
	};

	const clickButton = e => {
		e.stopPropagation();
	};

	const clickInDD = e => {
		e.stopPropagation();
		if (autoclose) node.open = false;
	};

	node.addEventListener("click", clickInDD);
	button.addEventListener("click", clickButton);
	window.addEventListener("click", clickOutside);

	return {
		update: param => autoclose = param,
		destroy: () => {
			window.removeEventListener("click", clickOutside);
			node.removeEventListener("click", clickInDD);
			button.removeEventListener("click", clickButton);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"outline","primary","secondary","dark","error","success","clear","loading","icon","iconRight","dropdown","open","autoclose","submit"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { outline = null } = $$props;
	let { primary = null } = $$props;
	let { secondary = null } = $$props;
	let { dark = null } = $$props;
	let { error = null } = $$props;
	let { success = null } = $$props;
	let { clear = null } = $$props;
	let { loading = null } = $$props;
	let { icon = null } = $$props;
	let { iconRight = null } = $$props;
	let { dropdown = false } = $$props;
	let { open = false } = $$props;
	let { autoclose = false } = $$props;
	let { submit = false } = $$props;
	const events = getEventsAction(current_component);
	const hasSlot = $$props.$$slots && $$props.$$slots !== undefined;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Button", $$slots, ['default']);

	function details_toggle_handler() {
		open = this.open;
		$$invalidate(0, open);
	}

	$$self.$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("outline" in $$new_props) $$invalidate(1, outline = $$new_props.outline);
		if ("primary" in $$new_props) $$invalidate(2, primary = $$new_props.primary);
		if ("secondary" in $$new_props) $$invalidate(3, secondary = $$new_props.secondary);
		if ("dark" in $$new_props) $$invalidate(4, dark = $$new_props.dark);
		if ("error" in $$new_props) $$invalidate(5, error = $$new_props.error);
		if ("success" in $$new_props) $$invalidate(6, success = $$new_props.success);
		if ("clear" in $$new_props) $$invalidate(7, clear = $$new_props.clear);
		if ("loading" in $$new_props) $$invalidate(8, loading = $$new_props.loading);
		if ("icon" in $$new_props) $$invalidate(9, icon = $$new_props.icon);
		if ("iconRight" in $$new_props) $$invalidate(10, iconRight = $$new_props.iconRight);
		if ("dropdown" in $$new_props) $$invalidate(11, dropdown = $$new_props.dropdown);
		if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
		if ("autoclose" in $$new_props) $$invalidate(12, autoclose = $$new_props.autoclose);
		if ("submit" in $$new_props) $$invalidate(13, submit = $$new_props.submit);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getEventsAction,
		current_component,
		Card,
		Icon,
		outline,
		primary,
		secondary,
		dark,
		error,
		success,
		clear,
		loading,
		icon,
		iconRight,
		dropdown,
		open,
		autoclose,
		submit,
		events,
		hasSlot,
		dropdownAction,
		clIcon,
		clIcononly
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
		if ("outline" in $$props) $$invalidate(1, outline = $$new_props.outline);
		if ("primary" in $$props) $$invalidate(2, primary = $$new_props.primary);
		if ("secondary" in $$props) $$invalidate(3, secondary = $$new_props.secondary);
		if ("dark" in $$props) $$invalidate(4, dark = $$new_props.dark);
		if ("error" in $$props) $$invalidate(5, error = $$new_props.error);
		if ("success" in $$props) $$invalidate(6, success = $$new_props.success);
		if ("clear" in $$props) $$invalidate(7, clear = $$new_props.clear);
		if ("loading" in $$props) $$invalidate(8, loading = $$new_props.loading);
		if ("icon" in $$props) $$invalidate(9, icon = $$new_props.icon);
		if ("iconRight" in $$props) $$invalidate(10, iconRight = $$new_props.iconRight);
		if ("dropdown" in $$props) $$invalidate(11, dropdown = $$new_props.dropdown);
		if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
		if ("autoclose" in $$props) $$invalidate(12, autoclose = $$new_props.autoclose);
		if ("submit" in $$props) $$invalidate(13, submit = $$new_props.submit);
		if ("clIcon" in $$props) $$invalidate(14, clIcon = $$new_props.clIcon);
		if ("clIcononly" in $$props) $$invalidate(15, clIcononly = $$new_props.clIcononly);
	};

	let clIcon;
	let clIcononly;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon, iconRight*/ 1536) {
			 $$invalidate(14, clIcon = (icon !== null || iconRight !== null) && hasSlot);
		}

		if ($$self.$$.dirty & /*dropdown, icon*/ 2560) {
			 $$invalidate(15, clIcononly = dropdown
			? icon !== null && dropdown === true
			: icon !== null && !hasSlot);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		open,
		outline,
		primary,
		secondary,
		dark,
		error,
		success,
		clear,
		loading,
		icon,
		iconRight,
		dropdown,
		autoclose,
		submit,
		clIcon,
		clIcononly,
		events,
		$$restProps,
		$$slots,
		details_toggle_handler,
		$$scope
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			outline: 1,
			primary: 2,
			secondary: 3,
			dark: 4,
			error: 5,
			success: 6,
			clear: 7,
			loading: 8,
			icon: 9,
			iconRight: 10,
			dropdown: 11,
			open: 0,
			autoclose: 12,
			submit: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$c.name
		});
	}

	get outline() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get primary() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set primary(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get secondary() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set secondary(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get success() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set success(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clear(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconRight() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconRight(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropdown() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropdown(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoclose() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoclose(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/
function backInOut(t) {
    const s = 1.70158 * 1.525;
    if ((t *= 2) < 1)
        return 0.5 * (t * t * ((s + 1) * t - s));
    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}
function backIn(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
}
function backOut(t) {
    const s = 1.70158;
    return --t * t * ((s + 1) * t + s) + 1;
}
function bounceOut(t) {
    const a = 4.0 / 11.0;
    const b = 8.0 / 11.0;
    const c = 9.0 / 10.0;
    const ca = 4356.0 / 361.0;
    const cb = 35442.0 / 1805.0;
    const cc = 16061.0 / 1805.0;
    const t2 = t * t;
    return t < a
        ? 7.5625 * t2
        : t < b
            ? 9.075 * t2 - 9.9 * t + 3.4
            : t < c
                ? ca * t2 - cb * t + cc
                : 10.8 * t * t - 20.52 * t + 10.72;
}
function bounceInOut(t) {
    return t < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}
function bounceIn(t) {
    return 1.0 - bounceOut(1.0 - t);
}
function circInOut(t) {
    if ((t *= 2) < 1)
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}
function circIn(t) {
    return 1.0 - Math.sqrt(1.0 - t * t);
}
function circOut(t) {
    return Math.sqrt(1 - --t * t);
}
function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicIn(t) {
    return t * t * t;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function elasticInOut(t) {
    return t < 0.5
        ? 0.5 *
            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *
            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
        : 0.5 *
            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *
            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +
            1.0;
}
function elasticIn(t) {
    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}
function elasticOut(t) {
    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);
}
function expoInOut(t) {
    return t === 0.0 || t === 1.0
        ? t
        : t < 0.5
            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)
            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}
function expoIn(t) {
    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}
function expoOut(t) {
    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}
function quadInOut(t) {
    t /= 0.5;
    if (t < 1)
        return 0.5 * t * t;
    t--;
    return -0.5 * (t * (t - 2) - 1);
}
function quadIn(t) {
    return t * t;
}
function quadOut(t) {
    return -t * (t - 2.0);
}
function quartInOut(t) {
    return t < 0.5
        ? +8.0 * Math.pow(t, 4.0)
        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}
function quartIn(t) {
    return Math.pow(t, 4.0);
}
function quartOut(t) {
    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}
function quintInOut(t) {
    if ((t *= 2) < 1)
        return 0.5 * t * t * t * t * t;
    return 0.5 * ((t -= 2) * t * t * t * t + 2);
}
function quintIn(t) {
    return t * t * t * t * t;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}
function sineInOut(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
}
function sineIn(t) {
    const v = Math.cos(t * Math.PI * 0.5);
    if (Math.abs(v) < 1e-14)
        return 1;
    else
        return 1 - v;
}
function sineOut(t) {
    return Math.sin((t * Math.PI) / 2);
}

var easings = /*#__PURE__*/Object.freeze({
    __proto__: null,
    backIn: backIn,
    backInOut: backInOut,
    backOut: backOut,
    bounceIn: bounceIn,
    bounceInOut: bounceInOut,
    bounceOut: bounceOut,
    circIn: circIn,
    circInOut: circInOut,
    circOut: circOut,
    cubicIn: cubicIn,
    cubicInOut: cubicInOut,
    cubicOut: cubicOut,
    elasticIn: elasticIn,
    elasticInOut: elasticInOut,
    elasticOut: elasticOut,
    expoIn: expoIn,
    expoInOut: expoInOut,
    expoOut: expoOut,
    quadIn: quadIn,
    quadInOut: quadInOut,
    quadOut: quadOut,
    quartIn: quartIn,
    quartInOut: quartInOut,
    quartOut: quartOut,
    quintIn: quintIn,
    quintInOut: quintInOut,
    quintOut: quintOut,
    sineIn: sineIn,
    sineInOut: sineInOut,
    sineOut: sineOut,
    linear: identity
});

function fade(node, { delay = 0, duration = 400, easing = identity }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules\svelte-chota\cmp\Modal.svelte generated by Svelte v3.23.2 */
const file$d = "node_modules\\svelte-chota\\cmp\\Modal.svelte";

// (15:0) {#if open}
function create_if_block$5(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let events_action;
	let div2_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div1_levels = [/*$$restProps*/ ctx[2]];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", {});
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "background svelte-4lwi8h");
			add_location(div0, file$d, 16, 4, 485);
			set_attributes(div1, div1_data);
			toggle_class(div1, "modal", 1);
			toggle_class(div1, "svelte-4lwi8h", true);
			add_location(div1, file$d, 17, 4, 542);
			attr_dev(div2, "class", "container svelte-4lwi8h");
			add_location(div2, file$d, 15, 0, 421);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t);
			append_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler*/ ctx[5], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[1].call(null, div1))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]]));
			toggle_class(div1, "modal", 1);
			toggle_class(div1, "svelte-4lwi8h", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(15:0) {#if open}",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*open*/ ctx[0] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*open*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*open*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["open"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { open = false } = $$props;
	const events = getEventsAction(current_component);
	let is_header = $$props.$$slots && $$props.$$slots.header !== undefined;
	let is_footer = $$props.$$slots && $$props.$$slots.footer !== undefined;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Modal", $$slots, ['default']);
	const click_handler = e => $$invalidate(0, open = false);

	$$self.$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getEventsAction,
		fade,
		current_component,
		open,
		events,
		is_header,
		is_footer
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
		if ("is_header" in $$props) is_header = $$new_props.is_header;
		if ("is_footer" in $$props) is_footer = $$new_props.is_footer;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [open, events, $$restProps, $$scope, $$slots, click_handler];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { open: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$d.name
		});
	}

	get open() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_components\ToastsList.svelte generated by Svelte v3.23.2 */
const file$e = "src\\routes\\_components\\ToastsList.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (39:12) {#if isLoggedIn && isAuthor(toast.toasterFacebookId)}
function create_if_block$6(ctx) {
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let modal;
	let updating_open;
	let current;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[6](/*toast*/ ctx[11], ...args);
	}

	button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_1*/ ctx[7]);

	function modal_open_binding(value) {
		/*modal_open_binding*/ ctx[9].call(null, value);
	}

	let modal_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	if (/*open*/ ctx[1] !== void 0) {
		modal_props.open = /*open*/ ctx[1];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "open", modal_open_binding));

	const block = {
		c: function create() {
			button0 = element("button");
			t0 = text("Edit");
			t1 = space();
			create_component(button1.$$.fragment);
			t2 = space();
			create_component(modal.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button0 = claim_element(nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "Edit");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(button1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(modal.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "class", "svelte-8pk0lh");
			add_location(button0, file$e, 39, 16, 1321);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button0, anchor);
			append_dev(button0, t0);
			insert_dev(target, t1, anchor);
			mount_component(button1, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(modal, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button0, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const modal_changes = {};

			if (dirty & /*$$scope, open, toasts*/ 16390) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 2) {
				updating_open = true;
				modal_changes.open = /*open*/ ctx[1];
				add_flush_callback(() => updating_open = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button1.$$.fragment, local);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button1.$$.fragment, local);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button0);
			if (detaching) detach_dev(t1);
			destroy_component(button1, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(modal, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(39:12) {#if isLoggedIn && isAuthor(toast.toasterFacebookId)}",
		ctx
	});

	return block;
}

// (41:16) <Button on:click={e => open=true}>
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(41:16) <Button on:click={e => open=true}>",
		ctx
	});

	return block;
}

// (45:24) <Button on:click={deleteToast(toast.toastId)}>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(45:24) <Button on:click={deleteToast(toast.toastId)}>",
		ctx
	});

	return block;
}

// (46:24) <Button on:click={e => open=false}>
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cancel");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(46:24) <Button on:click={e => open=false}>",
		ctx
	});

	return block;
}

// (43:20) <Card>
function create_default_slot_1(ctx) {
	let t0;
	let button0;
	let t1;
	let button1;
	let current;

	button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", function () {
		if (is_function(deleteToast(/*toast*/ ctx[11].toastId))) deleteToast(/*toast*/ ctx[11].toastId).apply(this, arguments);
	});

	button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_2*/ ctx[8]);

	const block = {
		c: function create() {
			t0 = text("Are you sure you want to delete this toast?\r\n                        ");
			create_component(button0.$$.fragment);
			t1 = space();
			create_component(button1.$$.fragment);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Are you sure you want to delete this toast?\r\n                        ");
			claim_component(button0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(button1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(button0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button0_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(43:20) <Card>",
		ctx
	});

	return block;
}

// (42:16) <Modal bind:open>
function create_default_slot$2(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty & /*$$scope, open, toasts*/ 16390) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(42:16) <Modal bind:open>",
		ctx
	});

	return block;
}

// (36:8) {#each toasts as toast}
function create_each_block$2(ctx) {
	let p0;
	let t0_value = /*toast*/ ctx[11].toastContent + "";
	let t0;
	let t1;
	let p1;
	let t2;
	let t3_value = /*toast*/ ctx[11].toasterName + "";
	let t3;
	let t4;
	let t5_value = /*toast*/ ctx[11].toasterRelationship + "";
	let t5;
	let t6;
	let t7_value = /*toast*/ ctx[11].toasterAssociation + "";
	let t7;
	let t8;
	let show_if = /*isLoggedIn*/ ctx[0] && /*isAuthor*/ ctx[3](/*toast*/ ctx[11].toasterFacebookId);
	let t9;
	let current;
	let if_block = show_if && create_if_block$6(ctx);

	const block = {
		c: function create() {
			p0 = element("p");
			t0 = text(t0_value);
			t1 = space();
			p1 = element("p");
			t2 = text("- ");
			t3 = text(t3_value);
			t4 = text(", ");
			t5 = text(t5_value);
			t6 = text(" of the ");
			t7 = text(t7_value);
			t8 = space();
			if (if_block) if_block.c();
			t9 = space();
			this.h();
		},
		l: function claim(nodes) {
			p0 = claim_element(nodes, "P", {});
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, t0_value);
			p0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			p1 = claim_element(nodes, "P", {});
			var p1_nodes = children(p1);
			t2 = claim_text(p1_nodes, "- ");
			t3 = claim_text(p1_nodes, t3_value);
			t4 = claim_text(p1_nodes, ", ");
			t5 = claim_text(p1_nodes, t5_value);
			t6 = claim_text(p1_nodes, " of the ");
			t7 = claim_text(p1_nodes, t7_value);
			t8 = claim_space(p1_nodes);
			if (if_block) if_block.l(p1_nodes);
			t9 = claim_space(p1_nodes);
			p1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p0, file$e, 36, 12, 1107);
			add_location(p1, file$e, 37, 12, 1148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p0, anchor);
			append_dev(p0, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, p1, anchor);
			append_dev(p1, t2);
			append_dev(p1, t3);
			append_dev(p1, t4);
			append_dev(p1, t5);
			append_dev(p1, t6);
			append_dev(p1, t7);
			append_dev(p1, t8);
			if (if_block) if_block.m(p1, null);
			append_dev(p1, t9);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*toasts*/ 4) && t0_value !== (t0_value = /*toast*/ ctx[11].toastContent + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*toasts*/ 4) && t3_value !== (t3_value = /*toast*/ ctx[11].toasterName + "")) set_data_dev(t3, t3_value);
			if ((!current || dirty & /*toasts*/ 4) && t5_value !== (t5_value = /*toast*/ ctx[11].toasterRelationship + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty & /*toasts*/ 4) && t7_value !== (t7_value = /*toast*/ ctx[11].toasterAssociation + "")) set_data_dev(t7, t7_value);
			if (dirty & /*isLoggedIn, toasts*/ 5) show_if = /*isLoggedIn*/ ctx[0] && /*isAuthor*/ ctx[3](/*toast*/ ctx[11].toasterFacebookId);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isLoggedIn, toasts*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(p1, t9);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(36:8) {#each toasts as toast}",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let section;
	let sectionheader;
	let t;
	let div;
	let current;

	sectionheader = new SectionHeader({
			props: { title: "Toasts" },
			$$inline: true
		});

	let each_value = /*toasts*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			section = element("section");
			create_component(sectionheader.$$.fragment);
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(sectionheader.$$.fragment, section_nodes);
			t = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-8pk0lh");
			add_location(div, file$e, 34, 4, 1055);
			attr_dev(section, "class", "toasts");
			add_location(section, file$e, 32, 0, 986);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(sectionheader, section, null);
			append_dev(section, t);
			append_dev(section, div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*open, deleteToast, toasts, editToast, isLoggedIn, isAuthor*/ 31) {
				each_value = /*toasts*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sectionheader.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(sectionheader.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(sectionheader);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function deleteToast(toastId) {
	await fetch("/api/toastController", {
		method: "DELETE",
		body: JSON.stringify({ toastId }),
		headers: { "Content-type": "application/json" }
	}).then(response => window.location.reload());
}

function instance$e($$self, $$props, $$invalidate) {
	
	const dispatch = createEventDispatcher();
	let open = false;
	let toasts = [];
	let { isLoggedIn } = $$props;
	let { facebookUserId } = $$props;

	function isAuthor(toasterFacebookId) {
		return facebookUserId === toasterFacebookId;
	}

	function editToast(toast) {
		dispatch("editToast", toast);
	}

	onMount(async () => {
		await fetch("api/toastController", { method: "GET" }).then(toasts => toasts.json()).then(toastsData => {
			$$invalidate(2, toasts = toastsData);
		});
	});

	const writable_props = ["isLoggedIn", "facebookUserId"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToastsList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ToastsList", $$slots, []);

	const click_handler = toast => {
		editToast(toast);
	};

	const click_handler_1 = e => $$invalidate(1, open = true);
	const click_handler_2 = e => $$invalidate(1, open = false);

	function modal_open_binding(value) {
		open = value;
		$$invalidate(1, open);
	}

	$$self.$set = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(5, facebookUserId = $$props.facebookUserId);
	};

	$$self.$capture_state = () => ({
		onMount,
		SectionHeader,
		createEventDispatcher,
		Modal,
		Button,
		Card,
		dispatch,
		open,
		toasts,
		isLoggedIn,
		facebookUserId,
		isAuthor,
		editToast,
		deleteToast
	});

	$$self.$inject_state = $$props => {
		if ("open" in $$props) $$invalidate(1, open = $$props.open);
		if ("toasts" in $$props) $$invalidate(2, toasts = $$props.toasts);
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(5, facebookUserId = $$props.facebookUserId);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		isLoggedIn,
		open,
		toasts,
		isAuthor,
		editToast,
		facebookUserId,
		click_handler,
		click_handler_1,
		click_handler_2,
		modal_open_binding
	];
}

class ToastsList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { isLoggedIn: 0, facebookUserId: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToastsList",
			options,
			id: create_fragment$e.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isLoggedIn*/ ctx[0] === undefined && !("isLoggedIn" in props)) {
			console.warn("<ToastsList> was created without expected prop 'isLoggedIn'");
		}

		if (/*facebookUserId*/ ctx[5] === undefined && !("facebookUserId" in props)) {
			console.warn("<ToastsList> was created without expected prop 'facebookUserId'");
		}
	}

	get isLoggedIn() {
		throw new Error("<ToastsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoggedIn(value) {
		throw new Error("<ToastsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facebookUserId() {
		throw new Error("<ToastsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facebookUserId(value) {
		throw new Error("<ToastsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_components\Toasts.svelte generated by Svelte v3.23.2 */

const { Object: Object_1 } = globals;

function create_fragment$f(ctx) {
	let toastslist;
	let t;
	let toastform;
	let current;

	toastslist = new ToastsList({
			props: {
				facebookUserId: /*facebookUserId*/ ctx[1],
				isLoggedIn: /*isLoggedIn*/ ctx[0]
			},
			$$inline: true
		});

	toastslist.$on("editToast", /*editToast*/ ctx[5]);

	toastform = new ToastForm({
			props: {
				isEdittingToast: /*isEdittingToast*/ ctx[2],
				toast: /*toast*/ ctx[3],
				facebookUserId: /*facebookUserId*/ ctx[1],
				isLoggedIn: /*isLoggedIn*/ ctx[0]
			},
			$$inline: true
		});

	toastform.$on("toggleLogIn", /*forward*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(toastslist.$$.fragment);
			t = space();
			create_component(toastform.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(toastslist.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(toastform.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(toastslist, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(toastform, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const toastslist_changes = {};
			if (dirty & /*facebookUserId*/ 2) toastslist_changes.facebookUserId = /*facebookUserId*/ ctx[1];
			if (dirty & /*isLoggedIn*/ 1) toastslist_changes.isLoggedIn = /*isLoggedIn*/ ctx[0];
			toastslist.$set(toastslist_changes);
			const toastform_changes = {};
			if (dirty & /*isEdittingToast*/ 4) toastform_changes.isEdittingToast = /*isEdittingToast*/ ctx[2];
			if (dirty & /*toast*/ 8) toastform_changes.toast = /*toast*/ ctx[3];
			if (dirty & /*facebookUserId*/ 2) toastform_changes.facebookUserId = /*facebookUserId*/ ctx[1];
			if (dirty & /*isLoggedIn*/ 1) toastform_changes.isLoggedIn = /*isLoggedIn*/ ctx[0];
			toastform.$set(toastform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toastslist.$$.fragment, local);
			transition_in(toastform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toastslist.$$.fragment, local);
			transition_out(toastform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toastslist, detaching);
			if (detaching) detach_dev(t);
			destroy_component(toastform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	
	const dispatch = createEventDispatcher();
	let { isLoggedIn } = $$props;
	let { facebookUserId } = $$props;
	let isEdittingToast = false;

	let toast = {
		toastId: null,
		toasterName: "",
		toasterRelationship: "",
		toasterAssociation: "",
		toastContent: "",
		toasterFacebookId: ""
	};

	function forward() {
		dispatch("toggleLogIn");
	}

	function editToast(event) {
		$$invalidate(3, toast = Object.assign({}, event.detail));
		$$invalidate(2, isEdittingToast = true);
	}

	const writable_props = ["isLoggedIn", "facebookUserId"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Toasts> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Toasts", $$slots, []);

	$$self.$set = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(1, facebookUserId = $$props.facebookUserId);
	};

	$$self.$capture_state = () => ({
		ToastForm,
		ToastsList,
		createEventDispatcher,
		dispatch,
		isLoggedIn,
		facebookUserId,
		isEdittingToast,
		toast,
		forward,
		editToast
	});

	$$self.$inject_state = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(1, facebookUserId = $$props.facebookUserId);
		if ("isEdittingToast" in $$props) $$invalidate(2, isEdittingToast = $$props.isEdittingToast);
		if ("toast" in $$props) $$invalidate(3, toast = $$props.toast);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [isLoggedIn, facebookUserId, isEdittingToast, toast, forward, editToast];
}

class Toasts extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { isLoggedIn: 0, facebookUserId: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toasts",
			options,
			id: create_fragment$f.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isLoggedIn*/ ctx[0] === undefined && !("isLoggedIn" in props)) {
			console.warn("<Toasts> was created without expected prop 'isLoggedIn'");
		}

		if (/*facebookUserId*/ ctx[1] === undefined && !("facebookUserId" in props)) {
			console.warn("<Toasts> was created without expected prop 'facebookUserId'");
		}
	}

	get isLoggedIn() {
		throw new Error("<Toasts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoggedIn(value) {
		throw new Error("<Toasts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facebookUserId() {
		throw new Error("<Toasts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facebookUserId(value) {
		throw new Error("<Toasts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_components\MenuIcon.svelte generated by Svelte v3.23.2 */
const file$f = "src\\routes\\_components\\MenuIcon.svelte";

function create_fragment$g(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "./134216-32.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "hamburger menu");
			attr_dev(img, "class", "svelte-5jqa2s");
			add_location(img, file$f, 8, 0, 213);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*handleToggle*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let isOpen = false;

	function handleToggle() {
		dispatch("handleToggle");
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuIcon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MenuIcon", $$slots, []);

	$$self.$capture_state = () => ({
		createEventDispatcher,
		dispatch,
		isOpen,
		handleToggle
	});

	$$self.$inject_state = $$props => {
		if ("isOpen" in $$props) isOpen = $$props.isOpen;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [handleToggle];
}

class MenuIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MenuIcon",
			options,
			id: create_fragment$g.name
		});
	}
}

var POSITIONS = [
  "bottom-right",
  "bottom-center",
  "bottom-left",
  "top-right",
  "top-center",
  "top-left",
  "right-bottom",
  "right-center",
  "right-top",
  "left-bottom",
  "left-center",
  "left-top"
];

const RIGHT = "right";
const LEFT = "left";
const TOP = "top";
const CENTER = "center";
const BOTTOM = "bottom";

// for SSR
function isBrowser() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

const getNextPosition = (position, dimensions) => {
  const clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight);
  const clientWidth = Math.min(document.body.clientWidth, document.documentElement.clientWidth);
  Object.assign(dimensions, { clientWidth, clientHeight });

  const [mainPosition, secondaryPosition] = position.split('-');
  const nextMainPosition = getMainPosition(mainPosition, dimensions);
  const nextSecondaryPosition = getSecondaryPosition(secondaryPosition, dimensions);

  return `${nextMainPosition}-${nextSecondaryPosition}`;
};

const getMainPosition = (
  position,
  {
    top,
    bottom,
    left,
    right,
    height,
    width,
    clientWidth,
    clientHeight,
  },
) => {

  const fitsOnTop = top > height;
  const fitsOnBottom = bottom + height < clientHeight;

  const fitsOnLeft = left > width;
  const fitsOnRight = right + width < clientWidth;

  const positions = {
    top: () => !fitsOnTop && fitsOnBottom ? BOTTOM : TOP,
    bottom: () => fitsOnTop && !fitsOnBottom ? TOP : BOTTOM,
    left: () => !fitsOnLeft && fitsOnRight ? RIGHT : LEFT,
    right: () => !fitsOnRight && fitsOnLeft ? LEFT : RIGHT,
  };

  return positions[position]();
};

const getSecondaryPosition = (
  position,
  {
    top,
    bottom,
    left,
    right,
    height,
    width,
    clientWidth,
    clientHeight,
  }
) => {
  const parentHeight = bottom - top;
  const parentCenter = top + parentHeight / 2;

  const fitsOnTop = bottom > height;
  const fitsOnBottom = top + height < clientHeight;
  const fitsCenter = (parentCenter - height / 2) > 0 && (parentCenter + height / 2) < clientHeight;
  const fitsOnLeft = right > width;
  const fitsOnRight = left + width < clientWidth;

  const positions = {
    top: () => !fitsOnTop && fitsOnBottom ? BOTTOM : TOP,
    center: () => fitsCenter ? CENTER : positions.top(),
    bottom: () => !fitsOnBottom && fitsOnTop ? TOP : BOTTOM,
    left: () => !fitsOnLeft && fitsOnRight ? RIGHT : LEFT,
    right: () => !fitsOnRight && fitsOnLeft ? LEFT : RIGHT,
  };

  return positions[position]();
};

/* node_modules\svelte-overlay\src\components\Overlay.svelte generated by Svelte v3.23.2 */

const { Error: Error_1, window: window_1 } = globals;
const file$g = "node_modules\\svelte-overlay\\src\\components\\Overlay.svelte";
const get_content_slot_changes = dirty => ({ isOpen: dirty[0] & /*openedState*/ 2048 });

const get_content_slot_context = ctx => ({
	toggle: /*toggle*/ ctx[12],
	isOpen: /*openedState*/ ctx[11],
	open: /*open*/ ctx[13],
	close: /*close*/ ctx[14]
});

const get_parent_slot_changes = dirty => ({ isOpen: dirty[0] & /*openedState*/ 2048 });

const get_parent_slot_context = ctx => ({
	toggle: /*toggle*/ ctx[12],
	isOpen: /*openedState*/ ctx[11],
	open: /*open*/ ctx[13],
	close: /*close*/ ctx[14]
});

// (155:2) {#if openedState}
function create_if_block$7(ctx) {
	let div;
	let div_class_value;
	let current;
	const content_slot_template = /*$$slots*/ ctx[24].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[23], get_content_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (content_slot) content_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (content_slot) content_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`content ${/*currentPosition*/ ctx[2] || ""}`) + " svelte-m0jddf"));
			add_location(div, file$g, 155, 3, 3777);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (content_slot) {
				content_slot.m(div, null);
			}

			/*div_binding*/ ctx[26](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (content_slot) {
				if (content_slot.p && dirty[0] & /*$$scope, openedState*/ 8390656) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_content_slot_changes, get_content_slot_context);
				}
			}

			if (!current || dirty[0] & /*currentPosition*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(`content ${/*currentPosition*/ ctx[2] || ""}`) + " svelte-m0jddf"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (content_slot) content_slot.d(detaching);
			/*div_binding*/ ctx[26](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(155:2) {#if openedState}",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let div1_style_value;
	let div2_class_value;
	let div2_style_value;
	let current;
	let mounted;
	let dispose;
	const parent_slot_template = /*$$slots*/ ctx[24].parent;
	const parent_slot = create_slot(parent_slot_template, ctx, /*$$scope*/ ctx[23], get_parent_slot_context);
	let if_block = /*openedState*/ ctx[11] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			if (parent_slot) parent_slot.c();
			t = space();
			div1 = element("div");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (parent_slot) parent_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "svelte-m0jddf");
			add_location(div0, file$g, 147, 1, 3493);
			attr_dev(div1, "class", "content-wrapper svelte-m0jddf");
			attr_dev(div1, "style", div1_style_value = `top: ${/*topStyle*/ ctx[6]}px; left: ${/*leftStyle*/ ctx[7]}px; width: ${/*widthStyle*/ ctx[8]}px; height: ${/*heightStyle*/ ctx[9]}px; z-index:${/*zIndex*/ ctx[0]};`);
			add_location(div1, file$g, 150, 1, 3597);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(`overlay ${/*className*/ ctx[10]}`) + " svelte-m0jddf"));
			attr_dev(div2, "style", div2_style_value = `z-index:${/*zIndex*/ ctx[0]}; ${/*style*/ ctx[1]}`);
			add_location(div2, file$g, 146, 0, 3398);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);

			if (parent_slot) {
				parent_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[25](div0);
			append_dev(div2, t);
			append_dev(div2, div1);
			if (if_block) if_block.m(div1, null);
			/*div2_binding*/ ctx[27](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window_1, "mousedown", /*handleWindowClick*/ ctx[15], false, false, false),
					listen_dev(window_1, "keydown", /*handleWindowKeyDown*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (parent_slot) {
				if (parent_slot.p && dirty[0] & /*$$scope, openedState*/ 8390656) {
					update_slot(parent_slot, parent_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_parent_slot_changes, get_parent_slot_context);
				}
			}

			if (/*openedState*/ ctx[11]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*openedState*/ 2048) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*topStyle, leftStyle, widthStyle, heightStyle, zIndex*/ 961 && div1_style_value !== (div1_style_value = `top: ${/*topStyle*/ ctx[6]}px; left: ${/*leftStyle*/ ctx[7]}px; width: ${/*widthStyle*/ ctx[8]}px; height: ${/*heightStyle*/ ctx[9]}px; z-index:${/*zIndex*/ ctx[0]};`)) {
				attr_dev(div1, "style", div1_style_value);
			}

			if (!current || dirty[0] & /*className*/ 1024 && div2_class_value !== (div2_class_value = "" + (null_to_empty(`overlay ${/*className*/ ctx[10]}`) + " svelte-m0jddf"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (!current || dirty[0] & /*zIndex, style*/ 3 && div2_style_value !== (div2_style_value = `z-index:${/*zIndex*/ ctx[0]}; ${/*style*/ ctx[1]}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(parent_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(parent_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (parent_slot) parent_slot.d(detaching);
			/*div0_binding*/ ctx[25](null);
			if (if_block) if_block.d();
			/*div2_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"isOpen","updateOnScroll","closeOnScroll","position","closeOnClickOutside","zIndex","onWindowKeyDown","style"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	const DEFAULT_POSITION = POSITIONS[0];
	let { isOpen = false } = $$props;
	let { updateOnScroll = false } = $$props;
	let { closeOnScroll = false } = $$props;
	let { position = DEFAULT_POSITION } = $$props;
	let { closeOnClickOutside = false } = $$props;
	let { zIndex = 1 } = $$props;

	let { onWindowKeyDown = () => {
		
	} } = $$props;

	let { style = "" } = $$props;
	let currentPosition = null;
	let parent;
	let content;
	let target;
	let topStyle = 0;
	let leftStyle = 0;
	let widthStyle = 0;
	let heightStyle = 0;

	function addListeners() {
		if (!isBrowser()) return;
		window.addEventListener("resize", updatePosition);
		if (closeOnScroll) window.addEventListener("scroll", close); else if (updateOnScroll) window.addEventListener("scroll", updatePosition);
	}

	function removeListeners() {
		if (!isBrowser()) return;
		window.removeEventListener("resize", updatePosition);
		window.removeEventListener("scroll", updatePosition);
		window.removeEventListener("scroll", close);
	}

	onMount(() => {
		if (openedState) {
			addListeners();
		}
	});

	onDestroy(() => {
		if (!isBrowser()) return;
		removeListeners();
	});

	beforeUpdate(updatePosition);

	function toggle(value) {
		const prevOpen = isOpen;
		const nextOpen = value === true || value === false ? value : !isOpen;
		if (nextOpen && hasParent && hasContent || !nextOpen) $$invalidate(17, isOpen = nextOpen);

		if (prevOpen !== isOpen) {
			dispatch("toggle", isOpen);

			if (isOpen) {
				addListeners();
				dispatch("open");
			} else {
				dispatch("close");
				removeListeners();
			}
		}
	}

	function open() {
		if (!openedState) toggle(true);
	}

	function close() {
		if (openedState) toggle(false);
	}

	function contains(event) {
		const path = event.path || event.composedPath();
		return path.includes(parent) || path.includes(content);
	}

	function handleWindowClick(event) {
		if (!closeOnClickOutside || !openedState || contains(event)) return;
		close();
	}

	function handleWindowKeyDown(event) {
		if (!onWindowKeyDown || !openedState) return;

		onWindowKeyDown(event, {
			isOpen: openedState,
			open,
			close,
			toggle,
			contains
		});
	}

	async function updatePosition() {
		await tick();
		if (!openedState) return;
		if (!POSITIONS.includes(position)) $$invalidate(18, position = DEFAULT_POSITION);
		const { top, bottom, left, right, width: parentWidth, height: parentHeight } = parent.getBoundingClientRect();
		const { height, width } = content.getBoundingClientRect();
		const dimensions = { top, bottom, left, right, height, width };
		const nextPosition = getNextPosition(position, dimensions);

		if (currentPosition !== nextPosition) {
			$$invalidate(2, currentPosition = nextPosition);
		}

		$$invalidate(6, topStyle = top);
		$$invalidate(7, leftStyle = left);
		$$invalidate(8, widthStyle = parentWidth);
		$$invalidate(9, heightStyle = parentHeight);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Overlay", $$slots, ['parent','content']);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			parent = $$value;
			$$invalidate(3, parent);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			content = $$value;
			$$invalidate(4, content);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			target = $$value;
			$$invalidate(5, target);
		});
	}

	$$self.$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(36, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("isOpen" in $$new_props) $$invalidate(17, isOpen = $$new_props.isOpen);
		if ("updateOnScroll" in $$new_props) $$invalidate(19, updateOnScroll = $$new_props.updateOnScroll);
		if ("closeOnScroll" in $$new_props) $$invalidate(20, closeOnScroll = $$new_props.closeOnScroll);
		if ("position" in $$new_props) $$invalidate(18, position = $$new_props.position);
		if ("closeOnClickOutside" in $$new_props) $$invalidate(21, closeOnClickOutside = $$new_props.closeOnClickOutside);
		if ("zIndex" in $$new_props) $$invalidate(0, zIndex = $$new_props.zIndex);
		if ("onWindowKeyDown" in $$new_props) $$invalidate(22, onWindowKeyDown = $$new_props.onWindowKeyDown);
		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
		if ("$$scope" in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		onMount,
		onDestroy,
		tick,
		createEventDispatcher,
		POSITIONS,
		isBrowser,
		getNextPosition,
		dispatch,
		DEFAULT_POSITION,
		isOpen,
		updateOnScroll,
		closeOnScroll,
		position,
		closeOnClickOutside,
		zIndex,
		onWindowKeyDown,
		style,
		currentPosition,
		parent,
		content,
		target,
		topStyle,
		leftStyle,
		widthStyle,
		heightStyle,
		addListeners,
		removeListeners,
		toggle,
		open,
		close,
		contains,
		handleWindowClick,
		handleWindowKeyDown,
		updatePosition,
		className,
		hasParent,
		hasContent,
		openedState
	});

	$$self.$inject_state = $$new_props => {
		if ("isOpen" in $$props) $$invalidate(17, isOpen = $$new_props.isOpen);
		if ("updateOnScroll" in $$props) $$invalidate(19, updateOnScroll = $$new_props.updateOnScroll);
		if ("closeOnScroll" in $$props) $$invalidate(20, closeOnScroll = $$new_props.closeOnScroll);
		if ("position" in $$props) $$invalidate(18, position = $$new_props.position);
		if ("closeOnClickOutside" in $$props) $$invalidate(21, closeOnClickOutside = $$new_props.closeOnClickOutside);
		if ("zIndex" in $$props) $$invalidate(0, zIndex = $$new_props.zIndex);
		if ("onWindowKeyDown" in $$props) $$invalidate(22, onWindowKeyDown = $$new_props.onWindowKeyDown);
		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
		if ("currentPosition" in $$props) $$invalidate(2, currentPosition = $$new_props.currentPosition);
		if ("parent" in $$props) $$invalidate(3, parent = $$new_props.parent);
		if ("content" in $$props) $$invalidate(4, content = $$new_props.content);
		if ("target" in $$props) $$invalidate(5, target = $$new_props.target);
		if ("topStyle" in $$props) $$invalidate(6, topStyle = $$new_props.topStyle);
		if ("leftStyle" in $$props) $$invalidate(7, leftStyle = $$new_props.leftStyle);
		if ("widthStyle" in $$props) $$invalidate(8, widthStyle = $$new_props.widthStyle);
		if ("heightStyle" in $$props) $$invalidate(9, heightStyle = $$new_props.heightStyle);
		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
		if ("hasParent" in $$props) $$invalidate(28, hasParent = $$new_props.hasParent);
		if ("hasContent" in $$props) $$invalidate(29, hasContent = $$new_props.hasContent);
		if ("openedState" in $$props) $$invalidate(11, openedState = $$new_props.openedState);
	};

	let className;
	let hasParent;
	let hasContent;
	let openedState;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(10, className = $$restProps["class"] || "");

		if ($$self.$$.dirty[0] & /*parent*/ 8) {
			 $$invalidate(28, hasParent = !parent || !!parent.childNodes.length);
		}

		if ($$self.$$.dirty[0] & /*content*/ 16) {
			 $$invalidate(29, hasContent = !content || !!content.childNodes.length);
		}

		if ($$self.$$.dirty[0] & /*hasParent*/ 268435456) {
			 if (!hasParent) throw new Error("parent slot is required");
		}

		if ($$self.$$.dirty[0] & /*hasContent*/ 536870912) {
			 if (!hasContent) throw new Error("content slot is required");
		}

		if ($$self.$$.dirty[0] & /*isOpen, hasParent, hasContent*/ 805437440) {
			 $$invalidate(11, openedState = isOpen && hasParent && hasContent);
		}
	};

	return [
		zIndex,
		style,
		currentPosition,
		parent,
		content,
		target,
		topStyle,
		leftStyle,
		widthStyle,
		heightStyle,
		className,
		openedState,
		toggle,
		open,
		close,
		handleWindowClick,
		handleWindowKeyDown,
		isOpen,
		position,
		updateOnScroll,
		closeOnScroll,
		closeOnClickOutside,
		onWindowKeyDown,
		$$scope,
		$$slots,
		div0_binding,
		div_binding,
		div2_binding
	];
}

class Overlay extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				isOpen: 17,
				updateOnScroll: 19,
				closeOnScroll: 20,
				position: 18,
				closeOnClickOutside: 21,
				zIndex: 0,
				onWindowKeyDown: 22,
				style: 1
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Overlay",
			options,
			id: create_fragment$h.name
		});
	}

	get isOpen() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateOnScroll() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateOnScroll(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnScroll() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnScroll(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnClickOutside() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnClickOutside(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get zIndex() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set zIndex(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onWindowKeyDown() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onWindowKeyDown(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error_1("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error_1("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var _ = {
  $(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector;
  },
  extend(...args) {
    return Object.assign(...args);
  },
  cumulativeOffset(element) {
    let top = 0;
    let left = 0;

    do {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);

    return {
      top: top,
      left: left
    };
  },
  directScroll(element) {
    return element && element !== document && element !== document.body;
  },
  scrollTop(element, value) {
    let inSetter = value !== undefined;
    if (this.directScroll(element)) {
      return inSetter ? (element.scrollTop = value) : element.scrollTop;
    } else {
      return inSetter
        ? (document.documentElement.scrollTop = document.body.scrollTop = value)
        : window.pageYOffset ||
            document.documentElement.scrollTop ||
            document.body.scrollTop ||
            0;
    }
  },
  scrollLeft(element, value) {
    let inSetter = value !== undefined;
    if (this.directScroll(element)) {
      return inSetter ? (element.scrollLeft = value) : element.scrollLeft;
    } else {
      return inSetter
        ? (document.documentElement.scrollLeft = document.body.scrollLeft = value)
        : window.pageXOffset ||
            document.documentElement.scrollLeft ||
            document.body.scrollLeft ||
            0;
    }
  }
};

const defaultOptions = {
  container: "body",
  duration: 500,
  delay: 0,
  offset: 0,
  easing: "cubicInOut",
  onStart: noop,
  onDone: noop,
  onAborting: noop,
  scrollX: false,
  scrollY: true
};

const _scrollTo = options => {
  let {
    offset,
    duration,
    delay,
    easing,
    x=0,
    y=0,
    scrollX,
    scrollY,
    onStart,
    onDone,
    container,
    onAborting,
    element
  } = options;

  if (typeof easing === "string") {
    easing = easings[easing];
  }
  if (typeof offset === "function") {
    offset = offset();
  }

  var cumulativeOffsetContainer = _.cumulativeOffset(container);
  var cumulativeOffsetTarget = element
    ? _.cumulativeOffset(element)
    : { top: y, left: x };

  var initialX = _.scrollLeft(container);
  var initialY = _.scrollTop(container);

  var targetX =
    cumulativeOffsetTarget.left - cumulativeOffsetContainer.left + offset;
  var targetY =
    cumulativeOffsetTarget.top - cumulativeOffsetContainer.top + offset;

  var diffX = targetX - initialX;
	var diffY = targetY - initialY;

  let scrolling = true;
  let started = false;
  let start_time = now() + delay;
  let end_time = start_time + duration;

  function scrollToTopLeft(element, top, left) {
    if (scrollX) _.scrollLeft(element, left);
    if (scrollY) _.scrollTop(element, top);
  }

  function start(delayStart) {
    if (!delayStart) {
      started = true;
      onStart(element, {x, y});
    }
  }

  function tick(progress) {
    scrollToTopLeft(
      container,
      initialY + diffY * progress,
      initialX + diffX * progress
    );
  }

  function stop() {
    scrolling = false;
  }

  loop(now => {
    if (!started && now >= start_time) {
      start(false);
    }

    if (started && now >= end_time) {
      tick(1);
      stop();
      onDone(element, {x, y});
    }

    if (!scrolling) {
      onAborting(element, {x, y});
      return false;
    }
    if (started) {
      const p = now - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t);
    }

    return true;
  });

  start(delay);

  tick(0);

  return stop;
};

const proceedOptions = options => {
	let opts = _.extend({}, defaultOptions, options);
  opts.container = _.$(opts.container);
  opts.element = _.$(opts.element);
  return opts;
};

const scrollContainerHeight = containerElement => {
  if (
    containerElement &&
    containerElement !== document &&
    containerElement !== document.body
  ) {
    return containerElement.scrollHeight - containerElement.offsetHeight;
  } else {
    let body = document.body;
    let html = document.documentElement;

    return Math.max(
      body.scrollHeight,
      body.offsetHeight,
      html.clientHeight,
      html.scrollHeight,
      html.offsetHeight
    );
  }
};

const setGlobalOptions = options => {
	_.extend(defaultOptions, options || {});
};

const scrollTo = options => {
  return _scrollTo(proceedOptions(options));
};

const scrollToBottom = options => {
  options = proceedOptions(options);

  return _scrollTo(
    _.extend(options, {
      element: null,
      y: scrollContainerHeight(options.container)
    })
  );
};

const scrollToTop = options => {
  options = proceedOptions(options);

  return _scrollTo(
    _.extend(options, {
      element: null,
      y: 0
    })
  );
};

const makeScrollToAction = scrollToFunc => {
  return (node, options) => {
    let current = options;
    const handle = e => {
      e.preventDefault();
      scrollToFunc(
        typeof current === "string" ? { element: current } : current
      );
    };
    node.addEventListener("click", handle);
    node.addEventListener("touchstart", handle);
    return {
      update(options) {
        current = options;
      },
      destroy() {
        node.removeEventListener("click", handle);
        node.removeEventListener("touchstart", handle);
      }
    };
  };
};

const scrollto = makeScrollToAction(scrollTo);
const scrolltotop = makeScrollToAction(scrollToTop);
const scrolltobottom = makeScrollToAction(scrollToBottom);

var animateScroll = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setGlobalOptions: setGlobalOptions,
    scrollTo: scrollTo,
    scrollToBottom: scrollToBottom,
    scrollToTop: scrollToTop,
    makeScrollToAction: makeScrollToAction,
    scrollto: scrollto,
    scrolltotop: scrolltotop,
    scrolltobottom: scrolltobottom
});

/* src\routes\_components\Menu.svelte generated by Svelte v3.23.2 */
const file$h = "src\\routes\\_components\\Menu.svelte";

// (21:0) {#if isOpen}
function create_if_block$8(ctx) {
	let div12;
	let ul;
	let li0;
	let div0;
	let img0;
	let img0_src_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let li1;
	let div2;
	let img1;
	let img1_src_value;
	let t3;
	let div3;
	let t4;
	let t5;
	let li2;
	let div4;
	let img2;
	let img2_src_value;
	let t6;
	let div5;
	let t7;
	let t8;
	let li3;
	let div6;
	let img3;
	let img3_src_value;
	let t9;
	let div7;
	let t10;
	let t11;
	let li4;
	let div8;
	let img4;
	let img4_src_value;
	let t12;
	let div9;
	let t13;
	let t14;
	let li5;
	let div10;
	let img5;
	let img5_src_value;
	let t15;
	let div11;
	let t16;
	let t17;
	let mounted;
	let dispose;
	let if_block = /*isLoggedIn*/ ctx[1] && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			div12 = element("div");
			ul = element("ul");
			li0 = element("li");
			div0 = element("div");
			img0 = element("img");
			t0 = space();
			div1 = element("div");
			t1 = text("Home");
			t2 = space();
			li1 = element("li");
			div2 = element("div");
			img1 = element("img");
			t3 = space();
			div3 = element("div");
			t4 = text("Our Story");
			t5 = space();
			li2 = element("li");
			div4 = element("div");
			img2 = element("img");
			t6 = space();
			div5 = element("div");
			t7 = text("Our Clan");
			t8 = space();
			li3 = element("li");
			div6 = element("div");
			img3 = element("img");
			t9 = space();
			div7 = element("div");
			t10 = text("Toasts");
			t11 = space();
			li4 = element("li");
			div8 = element("div");
			img4 = element("img");
			t12 = space();
			div9 = element("div");
			t13 = text("Propose a Toast");
			t14 = space();
			li5 = element("li");
			div10 = element("div");
			img5 = element("img");
			t15 = space();
			div11 = element("div");
			t16 = text("Blended Family");
			t17 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div12 = claim_element(nodes, "DIV", { class: true });
			var div12_nodes = children(div12);
			ul = claim_element(div12_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			div0 = claim_element(li0_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img0 = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(li0_nodes);
			div1 = claim_element(li0_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t1 = claim_text(div1_nodes, "Home");
			div1_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t2 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			div2 = claim_element(li1_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			img1 = claim_element(div2_nodes, "IMG", { src: true, alt: true, class: true });
			div2_nodes.forEach(detach_dev);
			t3 = claim_space(li1_nodes);
			div3 = claim_element(li1_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t4 = claim_text(div3_nodes, "Our Story");
			div3_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t5 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			div4 = claim_element(li2_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			img2 = claim_element(div4_nodes, "IMG", { src: true, alt: true, class: true });
			div4_nodes.forEach(detach_dev);
			t6 = claim_space(li2_nodes);
			div5 = claim_element(li2_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			t7 = claim_text(div5_nodes, "Our Clan");
			div5_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			t8 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			div6 = claim_element(li3_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			img3 = claim_element(div6_nodes, "IMG", { src: true, alt: true, class: true });
			div6_nodes.forEach(detach_dev);
			t9 = claim_space(li3_nodes);
			div7 = claim_element(li3_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			t10 = claim_text(div7_nodes, "Toasts");
			div7_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			t11 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			div8 = claim_element(li4_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			img4 = claim_element(div8_nodes, "IMG", { src: true, alt: true, class: true });
			div8_nodes.forEach(detach_dev);
			t12 = claim_space(li4_nodes);
			div9 = claim_element(li4_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			t13 = claim_text(div9_nodes, "Propose a Toast");
			div9_nodes.forEach(detach_dev);
			li4_nodes.forEach(detach_dev);
			t14 = claim_space(ul_nodes);
			li5 = claim_element(ul_nodes, "LI", { class: true });
			var li5_nodes = children(li5);
			div10 = claim_element(li5_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			img5 = claim_element(div10_nodes, "IMG", { src: true, alt: true, class: true });
			div10_nodes.forEach(detach_dev);
			t15 = claim_space(li5_nodes);
			div11 = claim_element(li5_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			t16 = claim_text(div11_nodes, "Blended Family");
			div11_nodes.forEach(detach_dev);
			li5_nodes.forEach(detach_dev);
			t17 = claim_space(ul_nodes);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			div12_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img0.src !== (img0_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "arrow");
			attr_dev(img0, "class", "svelte-pvkdh9");
			add_location(img0, file$h, 25, 20, 778);
			attr_dev(div0, "class", "arrow svelte-pvkdh9");
			add_location(div0, file$h, 24, 16, 737);
			attr_dev(div1, "class", "section svelte-pvkdh9");
			add_location(div1, file$h, 27, 16, 875);
			attr_dev(li0, "class", "home svelte-pvkdh9");
			add_location(li0, file$h, 23, 12, 652);
			if (img1.src !== (img1_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "arrow");
			attr_dev(img1, "class", "svelte-pvkdh9");
			add_location(img1, file$h, 31, 20, 1053);
			attr_dev(div2, "class", "arrow svelte-pvkdh9");
			add_location(div2, file$h, 30, 16, 1012);
			attr_dev(div3, "class", "section svelte-pvkdh9");
			add_location(div3, file$h, 33, 16, 1150);
			attr_dev(li1, "class", "svelte-pvkdh9");
			add_location(li1, file$h, 29, 12, 939);
			if (img2.src !== (img2_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img2, "src", img2_src_value);
			attr_dev(img2, "alt", "arrow");
			attr_dev(img2, "class", "svelte-pvkdh9");
			add_location(img2, file$h, 37, 20, 1348);
			attr_dev(div4, "class", "arrow svelte-pvkdh9");
			add_location(div4, file$h, 36, 16, 1307);
			attr_dev(div5, "class", "section svelte-pvkdh9");
			add_location(div5, file$h, 39, 16, 1445);
			attr_dev(li2, "class", "svelte-pvkdh9");
			add_location(li2, file$h, 35, 12, 1219);
			if (img3.src !== (img3_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img3, "src", img3_src_value);
			attr_dev(img3, "alt", "arrow");
			attr_dev(img3, "class", "svelte-pvkdh9");
			add_location(img3, file$h, 43, 20, 1628);
			attr_dev(div6, "class", "arrow svelte-pvkdh9");
			add_location(div6, file$h, 42, 16, 1587);
			attr_dev(div7, "class", "section svelte-pvkdh9");
			add_location(div7, file$h, 45, 16, 1725);
			attr_dev(li3, "class", "svelte-pvkdh9");
			add_location(li3, file$h, 41, 12, 1513);
			if (img4.src !== (img4_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img4, "src", img4_src_value);
			attr_dev(img4, "alt", "arrow");
			attr_dev(img4, "class", "svelte-pvkdh9");
			add_location(img4, file$h, 49, 20, 1907);
			attr_dev(div8, "class", "arrow svelte-pvkdh9");
			add_location(div8, file$h, 48, 16, 1866);
			attr_dev(div9, "class", "section svelte-pvkdh9");
			add_location(div9, file$h, 51, 16, 2004);
			attr_dev(li4, "class", "svelte-pvkdh9");
			add_location(li4, file$h, 47, 12, 1791);
			if (img5.src !== (img5_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img5, "src", img5_src_value);
			attr_dev(img5, "alt", "arrow");
			attr_dev(img5, "class", "svelte-pvkdh9");
			add_location(img5, file$h, 55, 20, 2195);
			attr_dev(div10, "class", "arrow svelte-pvkdh9");
			add_location(div10, file$h, 54, 16, 2154);
			attr_dev(div11, "class", "section svelte-pvkdh9");
			add_location(div11, file$h, 57, 16, 2292);
			attr_dev(li5, "class", "svelte-pvkdh9");
			add_location(li5, file$h, 53, 12, 2079);
			attr_dev(ul, "class", "svelte-pvkdh9");
			add_location(ul, file$h, 22, 8, 634);
			attr_dev(div12, "class", "menu svelte-pvkdh9");
			add_location(div12, file$h, 21, 4, 606);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div12, anchor);
			append_dev(div12, ul);
			append_dev(ul, li0);
			append_dev(li0, div0);
			append_dev(div0, img0);
			append_dev(li0, t0);
			append_dev(li0, div1);
			append_dev(div1, t1);
			append_dev(ul, t2);
			append_dev(ul, li1);
			append_dev(li1, div2);
			append_dev(div2, img1);
			append_dev(li1, t3);
			append_dev(li1, div3);
			append_dev(div3, t4);
			append_dev(ul, t5);
			append_dev(ul, li2);
			append_dev(li2, div4);
			append_dev(div4, img2);
			append_dev(li2, t6);
			append_dev(li2, div5);
			append_dev(div5, t7);
			append_dev(ul, t8);
			append_dev(ul, li3);
			append_dev(li3, div6);
			append_dev(div6, img3);
			append_dev(li3, t9);
			append_dev(li3, div7);
			append_dev(div7, t10);
			append_dev(ul, t11);
			append_dev(ul, li4);
			append_dev(li4, div8);
			append_dev(div8, img4);
			append_dev(li4, t12);
			append_dev(li4, div9);
			append_dev(div9, t13);
			append_dev(ul, t14);
			append_dev(ul, li5);
			append_dev(li5, div10);
			append_dev(div10, img5);
			append_dev(li5, t15);
			append_dev(li5, div11);
			append_dev(div11, t16);
			append_dev(ul, t17);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(li0, "click", /*click_handler*/ ctx[4], false, false, false),
					listen_dev(li1, "click", /*click_handler_1*/ ctx[5], false, false, false),
					listen_dev(li2, "click", /*click_handler_2*/ ctx[6], false, false, false),
					listen_dev(li3, "click", /*click_handler_3*/ ctx[7], false, false, false),
					listen_dev(li4, "click", /*click_handler_4*/ ctx[8], false, false, false),
					listen_dev(li5, "click", /*click_handler_5*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*isLoggedIn*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div12);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(21:0) {#if isOpen}",
		ctx
	});

	return block;
}

// (60:8) {#if isLoggedIn}
function create_if_block_1$5(ctx) {
	let li;
	let div0;
	let img;
	let img_src_value;
	let t0;
	let div1;
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			div0 = element("div");
			img = element("img");
			t0 = space();
			div1 = element("div");
			t1 = text("Log out");
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			div0 = claim_element(li_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(li_nodes);
			div1 = claim_element(li_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t1 = claim_text(div1_nodes, "Log out");
			div1_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "./icons8-collapse-arrow-50.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "arrow");
			attr_dev(img, "class", "svelte-pvkdh9");
			add_location(img, file$h, 62, 20, 2473);
			attr_dev(div0, "class", "arrow svelte-pvkdh9");
			add_location(div0, file$h, 61, 16, 2432);
			attr_dev(div1, "class", "section svelte-pvkdh9");
			add_location(div1, file$h, 64, 16, 2570);
			attr_dev(li, "class", "svelte-pvkdh9");
			add_location(li, file$h, 60, 12, 2392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, div0);
			append_dev(div0, img);
			append_dev(li, t0);
			append_dev(li, div1);
			append_dev(div1, t1);

			if (!mounted) {
				dispose = listen_dev(li, "click", /*logOut*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(60:8) {#if isLoggedIn}",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let if_block_anchor;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { isLoggedIn } = $$props;
	let { isOpen } = $$props;

	function logOut() {
		dispatch("toggleLogIn");
		handleSectionSelection("home");
	}

	function handleSectionSelection(section) {
		$$invalidate(0, isOpen = false);

		if (section == "home") {
			scrollToTop();
			return;
		}

		scrollTo({ element: "." + section, offset: -62.5 });
	}

	const writable_props = ["isLoggedIn", "isOpen"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Menu", $$slots, []);

	const click_handler = () => {
		handleSectionSelection("home");
	};

	const click_handler_1 = () => {
		handleSectionSelection("story");
	};

	const click_handler_2 = () => {
		handleSectionSelection("clan");
	};

	const click_handler_3 = () => {
		handleSectionSelection("toasts");
	};

	const click_handler_4 = () => {
		handleSectionSelection("propose");
	};

	const click_handler_5 = () => {
		handleSectionSelection("blended");
	};

	$$self.$set = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(1, isLoggedIn = $$props.isLoggedIn);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
	};

	$$self.$capture_state = () => ({
		Overlay,
		animateScroll,
		createEventDispatcher,
		dispatch,
		isLoggedIn,
		isOpen,
		logOut,
		handleSectionSelection
	});

	$$self.$inject_state = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(1, isLoggedIn = $$props.isLoggedIn);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		isOpen,
		isLoggedIn,
		logOut,
		handleSectionSelection,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class Menu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { isLoggedIn: 1, isOpen: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment$i.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isLoggedIn*/ ctx[1] === undefined && !("isLoggedIn" in props)) {
			console.warn("<Menu> was created without expected prop 'isLoggedIn'");
		}

		if (/*isOpen*/ ctx[0] === undefined && !("isOpen" in props)) {
			console.warn("<Menu> was created without expected prop 'isOpen'");
		}
	}

	get isLoggedIn() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoggedIn(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var splitOnFirst = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var queryString = createCommonjsModule(function (module, exports) {




const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
			return key => (result, value) => {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
				const newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeUriComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(input, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof input !== 'string') {
		return ret;
	}

	input = input.trim().replace(/^[?#&]/, '');

	if (!input) {
		return ret;
	}

	for (const param of input.split('&')) {
		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (input, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url, hash] = splitOnFirst(input, '#');

	return Object.assign(
		{
			url: url.split('?')[0] || '',
			query: parse(extract(input), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (input, options) => {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	const url = removeHash(input.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(input.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, input.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(input.url);
	if (input.fragmentIdentifier) {
		hash = `#${encode(input.fragmentIdentifier, options)}`;
	}

	return `${url}${queryString}${hash}`;
};
});

var queryString$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign({
    __proto__: null,
    'default': queryString,
    __moduleExports: queryString
}, queryString));

/* src\routes\_components\Nav.svelte generated by Svelte v3.23.2 */
const file$i = "src\\routes\\_components\\Nav.svelte";

function create_fragment$j(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let menuicon;
	let t2;
	let menu;
	let current;

	menuicon = new MenuIcon({
			props: { isOpen: /*isOpen*/ ctx[1] },
			$$inline: true
		});

	menuicon.$on("handleToggle", /*handleToggle*/ ctx[3]);

	menu = new Menu({
			props: {
				isLoggedIn: /*isLoggedIn*/ ctx[0],
				isOpen: /*isOpen*/ ctx[1]
			},
			$$inline: true
		});

	menu.$on("toggleLogIn", /*forward*/ ctx[2]);

	const block = {
		c: function create() {
			div = element("div");
			p = element("p");
			t0 = text("#blameitonfate");
			t1 = space();
			create_component(menuicon.$$.fragment);
			t2 = space();
			create_component(menu.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "#blameitonfate");
			p_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			claim_component(menuicon.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(menu.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "svelte-re6cqn");
			add_location(p, file$i, 16, 4, 419);
			attr_dev(div, "class", "svelte-re6cqn");
			add_location(div, file$i, 15, 0, 408);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, p);
			append_dev(p, t0);
			append_dev(div, t1);
			mount_component(menuicon, div, null);
			append_dev(div, t2);
			mount_component(menu, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const menuicon_changes = {};
			if (dirty & /*isOpen*/ 2) menuicon_changes.isOpen = /*isOpen*/ ctx[1];
			menuicon.$set(menuicon_changes);
			const menu_changes = {};
			if (dirty & /*isLoggedIn*/ 1) menu_changes.isLoggedIn = /*isLoggedIn*/ ctx[0];
			if (dirty & /*isOpen*/ 2) menu_changes.isOpen = /*isOpen*/ ctx[1];
			menu.$set(menu_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuicon.$$.fragment, local);
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuicon.$$.fragment, local);
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(menuicon);
			destroy_component(menu);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { isLoggedIn } = $$props;
	let isOpen = false;

	function forward() {
		dispatch("toggleLogIn");
	}

	function handleToggle() {
		$$invalidate(1, isOpen = !isOpen);
	}

	const writable_props = ["isLoggedIn"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Nav> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Nav", $$slots, []);

	$$self.$set = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
	};

	$$self.$capture_state = () => ({
		MenuIcon,
		Menu,
		queryString: queryString$1,
		createEventDispatcher,
		dispatch,
		isLoggedIn,
		isOpen,
		forward,
		handleToggle
	});

	$$self.$inject_state = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("isOpen" in $$props) $$invalidate(1, isOpen = $$props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [isLoggedIn, isOpen, forward, handleToggle];
}

class Nav extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { isLoggedIn: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav",
			options,
			id: create_fragment$j.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isLoggedIn*/ ctx[0] === undefined && !("isLoggedIn" in props)) {
			console.warn("<Nav> was created without expected prop 'isLoggedIn'");
		}
	}

	get isLoggedIn() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoggedIn(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\index.svelte generated by Svelte v3.23.2 */
const file$j = "src\\routes\\index.svelte";

function create_fragment$k(ctx) {
	let nav;
	let t0;
	let div0;
	let img0;
	let img0_src_value;
	let t1;
	let div1;
	let jumbotron;
	let t2;
	let story;
	let t3;
	let clan;
	let t4;
	let toasts;
	let t5;
	let blended;
	let t6;
	let div2;
	let img1;
	let img1_src_value;
	let current;

	nav = new Nav({
			props: { isLoggedIn: /*isLoggedIn*/ ctx[0] },
			$$inline: true
		});

	nav.$on("toggleLogIn", /*toggleLogIn*/ ctx[2]);
	jumbotron = new Jumbotron({ $$inline: true });
	story = new Story({ $$inline: true });
	clan = new Clan({ $$inline: true });

	toasts = new Toasts({
			props: {
				isLoggedIn: /*isLoggedIn*/ ctx[0],
				facebookUserId: /*facebookUserId*/ ctx[1]
			},
			$$inline: true
		});

	toasts.$on("toggleLogIn", /*toggleLogIn*/ ctx[2]);
	blended = new Blended({ $$inline: true });

	const block = {
		c: function create() {
			create_component(nav.$$.fragment);
			t0 = space();
			div0 = element("div");
			img0 = element("img");
			t1 = space();
			div1 = element("div");
			create_component(jumbotron.$$.fragment);
			t2 = space();
			create_component(story.$$.fragment);
			t3 = space();
			create_component(clan.$$.fragment);
			t4 = space();
			create_component(toasts.$$.fragment);
			t5 = space();
			create_component(blended.$$.fragment);
			t6 = space();
			div2 = element("div");
			img1 = element("img");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(nav.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", {});
			var div0_nodes = children(div0);
			img0 = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(jumbotron.$$.fragment, div1_nodes);
			t2 = claim_space(div1_nodes);
			claim_component(story.$$.fragment, div1_nodes);
			t3 = claim_space(div1_nodes);
			claim_component(clan.$$.fragment, div1_nodes);
			t4 = claim_space(div1_nodes);
			claim_component(toasts.$$.fragment, div1_nodes);
			t5 = claim_space(div1_nodes);
			claim_component(blended.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", {});
			var div2_nodes = children(div2);
			img1 = claim_element(div2_nodes, "IMG", { src: true, alt: true, class: true });
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img0.src !== (img0_src_value = "PageLeftDecorator.png")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "decoration");
			attr_dev(img0, "class", "left pageDecorator");
			add_location(img0, file$j, 46, 5, 1430);
			add_location(div0, file$j, 46, 0, 1425);
			attr_dev(div1, "class", "content");
			add_location(div1, file$j, 47, 0, 1515);
			if (img1.src !== (img1_src_value = "PageRightDecorator.png")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "decoration");
			attr_dev(img1, "class", "right pageDecorator");
			add_location(img1, file$j, 54, 5, 1716);
			add_location(div2, file$j, 54, 0, 1711);
		},
		m: function mount(target, anchor) {
			mount_component(nav, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div0, anchor);
			append_dev(div0, img0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div1, anchor);
			mount_component(jumbotron, div1, null);
			append_dev(div1, t2);
			mount_component(story, div1, null);
			append_dev(div1, t3);
			mount_component(clan, div1, null);
			append_dev(div1, t4);
			mount_component(toasts, div1, null);
			append_dev(div1, t5);
			mount_component(blended, div1, null);
			insert_dev(target, t6, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, img1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const nav_changes = {};
			if (dirty & /*isLoggedIn*/ 1) nav_changes.isLoggedIn = /*isLoggedIn*/ ctx[0];
			nav.$set(nav_changes);
			const toasts_changes = {};
			if (dirty & /*isLoggedIn*/ 1) toasts_changes.isLoggedIn = /*isLoggedIn*/ ctx[0];
			if (dirty & /*facebookUserId*/ 2) toasts_changes.facebookUserId = /*facebookUserId*/ ctx[1];
			toasts.$set(toasts_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(nav.$$.fragment, local);
			transition_in(jumbotron.$$.fragment, local);
			transition_in(story.$$.fragment, local);
			transition_in(clan.$$.fragment, local);
			transition_in(toasts.$$.fragment, local);
			transition_in(blended.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(nav.$$.fragment, local);
			transition_out(jumbotron.$$.fragment, local);
			transition_out(story.$$.fragment, local);
			transition_out(clan.$$.fragment, local);
			transition_out(toasts.$$.fragment, local);
			transition_out(blended.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(nav, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div1);
			destroy_component(jumbotron);
			destroy_component(story);
			destroy_component(clan);
			destroy_component(toasts);
			destroy_component(blended);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function isFacebookConnected() {
	let isConnected = false;

	FB.getLoginStatus(function (response) {
		isConnected = response.status === "connected";
	});

	return isConnected;
}

function instance$k($$self, $$props, $$invalidate) {
	let isLoggedIn = false;
	let facebookUserId;

	onMount(() => {
		FB.init({
			appId: "778058433003434",
			cookie: true,
			xfbml: true,
			version: "v7.0"
		});

		FB.getLoginStatus(function (response) {
			$$invalidate(0, isLoggedIn = response.status === "connected");
			$$invalidate(1, facebookUserId = response.authResponse.userID);
		});
	});

	function toggleLogIn() {
		if (isFacebookConnected()) {
			FB.logout(function (response) {
				$$invalidate(1, facebookUserId = "");
				$$invalidate(0, isLoggedIn = false);
			});
		} else {
			FB.login(function (response) {
				$$invalidate(1, facebookUserId = response.authResponse.userID);
				$$invalidate(0, isLoggedIn = true);
			});
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routes", $$slots, []);

	$$self.$capture_state = () => ({
		onMount,
		SectionHeader,
		Jumbotron,
		Story,
		Blended,
		Clan,
		Toasts,
		Nav,
		isLoggedIn,
		facebookUserId,
		toggleLogIn,
		isFacebookConnected
	});

	$$self.$inject_state = $$props => {
		if ("isLoggedIn" in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
		if ("facebookUserId" in $$props) $$invalidate(1, facebookUserId = $$props.facebookUserId);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [isLoggedIn, facebookUserId, toggleLogIn];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$k.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguOTM5ZjY3NGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvX2NvbXBvbmVudHMvU2VjdGlvbkhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL19jb21wb25lbnRzL1N0b3J5LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvX2NvbXBvbmVudHMvQmxlbmRlZC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2llbWEvZGlzdC9zaWVtYS5taW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJleW9uay9zdmVsdGUtY2Fyb3VzZWwvc3JjL0Nhcm91c2VsLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZmVhdGhlci1pY29ucy9zcmMvaWNvbnMvQ2hldnJvbkxlZnRJY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZmVhdGhlci1pY29ucy9zcmMvaWNvbnMvQ2hldnJvblJpZ2h0SWNvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL19jb21wb25lbnRzL0NsYW4uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fY29tcG9uZW50cy9Ub2FzdEZvcm0uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1jaG90YS9jbXAvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNob3RhL2NtcC9DYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtY2hvdGEvY21wL0ljb24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1jaG90YS9jbXAvQnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvZWFzaW5nL2luZGV4Lm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvdHJhbnNpdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNob3RhL2NtcC9Nb2RhbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL19jb21wb25lbnRzL1RvYXN0c0xpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fY29tcG9uZW50cy9Ub2FzdHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fY29tcG9uZW50cy9NZW51SWNvbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLW92ZXJsYXkvc3JjL2NvbXBvbmVudHMvcG9zaXRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1vdmVybGF5L3NyYy9jb21wb25lbnRzL2hlbHBlcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLW92ZXJsYXkvc3JjL2NvbXBvbmVudHMvT3ZlcmxheS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNjcm9sbHRvL3NyYy9oZWxwZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNjcm9sbHRvL3NyYy9pbmRleC5qcyIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvX2NvbXBvbmVudHMvTWVudS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVjb2RlLXVyaS1jb21wb25lbnQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3BsaXQtb24tZmlyc3QvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fY29tcG9uZW50cy9OYXYuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPSd0eXBlc2NyaXB0Jz5cclxuICAgIGltcG9ydCBIZWFkaW5nRGVjb3JhdG9yIGZyb20gJy4vSGVhZGluZ0RlY29yYXRvci5zdmVsdGUnO1xyXG4gICAgZXhwb3J0IGxldCB0aXRsZTogc3RyaW5nO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXY+XHJcbiAgICA8aDE+e3RpdGxlfTwvaDE+XHJcbiAgICA8SGVhZGluZ0RlY29yYXRvciAvPlxyXG48L2Rpdj5cclxuPHN0eWxlIGxhbmc9J3Njc3MnPlxyXG4gICAgQGltcG9ydCAnLi4vLi4vLi4vc3RhdGljL3RoZW1lLnNjc3MnO1xyXG4gICAgXHJcbiAgICAvKiBTbWFydHBob25lcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDMyMHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDQ4MHB4KSB7ICAgXHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGFkcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDc2OHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDEwMjRweCkge1xyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogRGVza3RvcHMgYW5kIExhcHRvcHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW5cclxuICAgIGFuZCAobWluLXdpZHRoIDogMTIyNHB4KSB7XHJcbiAgICAgICAgZGl2IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGFjY2VudC1jb2xvci1ncmVlbjtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMjBweDtcclxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEyMHB4O1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcclxuICAgICAgICAgICAgcGFkZGluZzogMDtcclxuXHQgICAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDEwcHg7XHJcblx0ICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMTBweDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGhvbmUgNCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbyA6IDEuNSksXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG48L3N0eWxlPiIsIjxzY3JpcHQ+XHJcbiAgICBpbXBvcnQgU2VjdGlvbkhlYWRlciBmcm9tICcuL1NlY3Rpb25IZWFkZXIuc3ZlbHRlJztcclxuPC9zY3JpcHQ+XHJcblxyXG48c2VjdGlvbiBjbGFzcz0nc3RvcnknPlxyXG4gICAgPFNlY3Rpb25IZWFkZXIgdGl0bGU9eydPdXIgU3RvcnknfS8+XHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxwPjxzcGFuPk9uY2UgdXBvbiBhIHRpbWUuLi48L3NwYW4+IHRoZXJlIHdhcyBhIGtpbmcgYW5kIGEgdmlraW5nIHByaW5jZXNzLiBUaGV5IGRpZCBub3Qga25vdyBpdCwgYnV0IHRoZSBnb2RzIGhhZCBzZXQgdGhlIHRhYmxlIGZvciB0aGVtIHRvIGJlIHRvZ2V0aGVyLjwvcD5cclxuICAgICAgICA8cD5BcyB0aGUgZ29kcyBwbGFubmVkIG91dCB0aGVpciBkZXN0aW55LCB0aGV5IGNvdWxkbid0IHF1aXRlIGFncmVlIG9uIHRoZSBwYXRoIHRoZXNlIHR3byBzaG91bGQgdGFrZSB0byBnZXQgdGhlcmUuIE9uZSBvZiB0aGUgZ29kcyBzZXQgdXAgdGhlaXIgZmlyc3QgbWVldGluZy4gQXMgdGhleSB3ZXJlIGJvdGggbG9va2luZyB0byBsZWFybiBtb3JlIGFib3V0IHRoZSB3b3JsZCBhcm91bmQgdGhlbSwgdGhleSBhdHRlbmRlZCB0aGUgQWNhZGVteSBhdCB0aGUgc2FtZSB0aW1lLiBUaGUgZmlyc3QgZ29kIHNldCBpdCB1cCBzbyB0aGF0IHRoZXkgbGl2ZWQgaW4gY2xvc2UgcHJveGltaXR5LiBPbmNlIHRoZSBvdGhlciBnb2RzIG5vdGljZWQsIHRoZXkgaW50ZXJ2ZW5lZCBhbmQga2VwdCB0aGVtIGZyb20gbWVldGluZyBlYWNoIG90aGVyLiBJdCB3YXMgbm90IHRoZWlyIHRpbWUgeWV0LjwvcD5cclxuICAgICAgICA8cD5Cb3RoIHRoZSBraW5nIGFuZCB0aGUgdmlraW5nIHByaW5jZXNzIHdlbnQgb24gdG8gaGF2ZSBmYW1pbGllcyBvZiB0aGVpciBvd24uIEFub3RoZXIgb25lIG9mIHRoZSBnb2RzIHRob3VnaHQgdGhhdCB0aGlzIHdhcyB0aGUgdGltZSBhbmQgbW92ZWQgdGhlbSB0byB0aGUgc2FtZSB0b3duLiBCb3RoIG9mIHRoZWlyIGZhbWlsaWVzIGdyZXcgdXAgYXQgdGhlIHNhbWUgdGltZS4gVGhlIGtpbmcgaGFkIHR3byBkYXVnaHRlcnMgYW5kIHRoZSB2aWtpbmcgcHJpbmNlc3MgaGFkIHR3byBzb25zIGFuZCB0d28gZGF1Z2h0ZXJzLiBUaGUga2lkcyBncmV3IHVwIHdpdGggZWFjaCBvdGhlciBhbmQgYmVjYW1lIGZyaWVuZHMuIFRoZSBlbGRlc3QgdmlraW5nIHNvbiBhbmQgdGhlIGVsZGVzdCBwcmluY2VzcyBvZiB0aGUga2luZyBib3RoIHB1cnN1ZWQgdGhlIGJhcmRpYyBhcnRzIHRvZ2V0aGVyLiBUaGUgeW91bmdlc3QgdmlraW5nIGRhdWdodGVyIGFuZCB0aGUgeW91bmdlc3QgcHJpbmNlc3Mgb2YgdGhlIGtpbmcgYmF0dGxlZCBmb3IgdGhlIHJhaWRlcnMgdGhyb3VnaCB2b2xsZXkgYWZ0ZXIgdm9sbGV5IG9mIGJhbGxzIGZsdW5nIGJ5IHRoZSBpbnZhZGluZyBhcm1pZXMuIFRocm91Z2ggYWxsIG9mIHRoaXMgdGhlIG90aGVyIGdvZHMgZGVjaWRlZCBpdCB3YXMgbm90IHRpbWUgZm9yIHRoZSBraW5nIGFuZCB0aGUgdmlraW5nIHByaW5jZXNzIHRvIG1lZXQsIGFuZCBrZXB0IHRoZW0gYXBhcnQuIEl0IHdhcyBub3QgdGhlaXIgdGltZSB5ZXQuPC9wPlxyXG4gICAgICAgIDxwPkEgdGhpcmQgZ29kIGRlY2lkZWQgdG8gbWFrZSBoaXMgbW92ZSBhbmQgYXJyYW5nZWQgaXQgc28gdGhlIHZpa2luZyBwcmluY2VzcyBqb2luZWQgdGhlIFBhcmVudCBUZWFjaGVyIFN0dWRlbnQgR3VpbGQgYWxvbmcgd2l0aCB0aGUgUXVlZW4uIEJvdGggd2VyZSB2YWxpYW50IGNoYW1waW9ucyBpbiBtYWtpbmcgc3VyZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGtpbmdkb20gd2VyZSBnZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBlZHVjYXRpb24uIFRocm91Z2hvdXQgdGhlaXIgbWFueSBtZWV0aW5ncyBhbmQgcHVibGljIGV2ZW50cywgdGhlIG90aGVyIGdvZHMgZGVjaWRlZCB0byBpbnRlcnZlbmUgYW5kIG5vdCBhbGxvdyB0aGUga2luZyBhbmQgdmlraW5nIHByaW5jZXNzIHRvIGNyb3NzIHBhdGhzLiBJdCB3YXMgbm90IHRoZWlyIHRpbWUgeWV0LjwvcD5cclxuICAgICAgICA8cD5UaGUgdmlraW5nIHByaW5jZXNzIHB1cnN1ZWQgaGVyIGFkdmFuY2VtZW50IGluIHRoZSBQYXJlbnQgVGVhY2hlciBTdHVkZW50IEd1aWxkIHdpdGggZmVydm9yIGFuZCBldmVudHVhbGx5IHJlYWNoZWQgdGhlIHJhbmsgb2YgVGVhY2hlciBvZiBUaGUgTmF0aXZlIFRvbmd1ZS4gQSBmb3VydGggZ29kIGRlY2lkZWQgdGhpcyB3b3VsZCBiZSB0aGUgcGVyZmVjdCB0aW1lIHRvIGludHJvZHVjZSB0aGUga2luZyBhbmQgdGhlIHZpa2luZyBwcmluY2Vzcy4gVGhpcyBnb2QgYXJyYW5nZWQgZm9yIHRoZSBraW5nJ3MgeW91bmdlc3QgcHJpbmNlc3MgdG8gYmVjb21lIGFuIGFwcHJlbnRpY2Ugb2YgdGhlIHZpa2luZyBwcmluY2Vzcy4gQWxhcywgdGhlIG90aGVyIGdvZHMgaW50ZXJ2ZW5lZCB5ZXQgYWdhaW4gYW5kIGRpZCBub3QgbGV0IHRoZWlyIHBhdGhzIGNyb3NzLiBJdCB3YXMgbm90IHRoZWlyIHRpbWUgeWV0LjwvcD5cclxuICAgICAgICA8cD5MaXZpbmcgd2l0aGluIHRoZSBzYW1lIGtpbmdkb20sIHRoZXkgd2VyZSBvZnRlbiBpbiB0aGUgbWFya2V0IGF0IHRoZSBzYW1lIHRpbWUuIE5laXRoZXIgdGFraW5nIG5vdGljZSBvZiBlYWNoIG90aGVyLiBUaGUgZ29kcyBoYWQgYWdhaW4gZGVjaWRlZCB0byBrZWVwIHRoZW0gYXdheSBmcm9tIGVhY2ggb3RoZXIuIEl0IHdhcyBub3QgdGhlaXIgdGltZSB5ZXQuPC9wPlxyXG4gICAgICAgIDxwPkJ5IHRoaXMgcG9pbnQgaW4gdGltZSwgYm90aCBoYWQgbW92ZWQgb24gZnJvbSB0aGVpciBwcmV2aW91cyByZWxhdGlvbnNoaXBzLiBXaGlsZSB0aGVyZSB3ZXJlIHRpbWVzIHdoZXJlIHRoZXkgd2VyZSBoYXBweSwgdGhleSBrbmV3IGRlZXAgZG93biB0aGF0IHNvbWV0aGluZyB3YXMgbWlzc2luZy4gVGhlaXIgc29ucyBhbmQgZGF1Z2h0ZXJzIGhhZCBncm93biB1cCBhbmQgaGFkIGZhbWlsaWVzIG9mIHRoZWlyIG93bi4gVGhlIGdvZHMgZmluYWxseSBkZWNpZGVkIGl0IHdhcyB0aW1lLjwvcD5cclxuICAgICAgICA8cD5PbmUgZmF0ZWZ1bCBkYXksIHRoZXkgYWxpZ25lZCB0aGUgc3RhcnMgdG8gYWxsb3cgdGhlbSB0byBtZWV0LiBUaGUga2luZyB3YXMgZGlzY3Vzc2luZyBsaWZlIHdpdGggYSBub2JsZSBmcmllbmQgb2YgaGlzIGluIHRoZSBtYXJrZXQgd2hlbiB0aGUgdmlraW5nIHByaW5jZXNzIGVudGVyZWQuIFRoZWlyIHBhdGhzIHdvdWxkIGhhdmUgY3Jvc3NlZCB5ZXQgYWdhaW4gd2l0aG91dCBpbnRlcmFjdGlvbiwgYnV0IHRoZSBnb2RzIGhhZCBjYXJlZnVsbHkgbGFpZCBvdXQgdGhpcyBtb21lbnQuIFRoZSBub2JsZSB0aGF0IHRoZSBraW5nIHdhcyB0YWxraW5nIHRvIGhhcHBlbmVkIHRvIGFsc28gYmUgdGhlIGJyb3RoZXIgaW4gbGF3IG9mIHRoZSBlbGRlc3QgdmlraW5nIGRhdWdodGVyLiBUaGUgbm9ibGUgbm90aWNlZCB0aGUgdmlraW5nIHByaW5jZXNzIGFuZCBkZWNpZGVkIHRvIG1ha2UgYW4gaW50cm9kdWN0aW9uLiBBZnRlciB0aGUgbm9ibGUgbGVmdCwgdGhleSBjb250aW51ZWQgdGhlaXIgc2hvcHBpbmcsIGdsYW5jaW5nIGF0IGVhY2ggb3RoZXIgdGhyb3VnaCB0aGUgbWFya2V0IHN0YWxscy4gVGhlIHN0cmFuZHMgb2YgZmF0ZSBzcGlubmluZyBzdHJvbmdlciBhbmQgc3Ryb25nZXIgd2l0aCBlYWNoIHBhc3NpbmcuIEh1bWFucyB0ZW5kIHRvIGJlIHVucHJlZGljdGFibGUgYW5kIHJlc2lzdCB0aGVpciBkZXN0aW5pZXMuIFRoZSB2aWtpbmcgcHJpbmNlc3MgYWJydXB0bHkgbGVmdCB0aGUgbWFya2V0IHdpdGhvdXQgdGFsa2luZyB3aXRoIHRoZSBraW5nIGZ1cnRoZXIuPC9wPlxyXG4gICAgICAgIDxwPlRoZSBnb2RzIGRpZG4ndCBsaWtlIHRoaXMuIFRoZXkgZmlsbGVkIGhlciBoZWFkIHdpdGggZG91YnQgYW5kIGhlciBoZWFydCB3aXRoIGV4Y2l0ZW1lbnQuIFNoZSBrbmV3IHNoZSB2ZWVyZWQgZnJvbSB0aGVpciBwbGFucyBhbmQgZGVjaWRlZCB0byB0YWtlIGhlciBzaG90LiBTaGUgc2VudCBvdXQgbWVzc2VuZ2VycyB0byBmaW5kIHRoZSBraW5nLiBUaGV5IGV2ZW50dWFsbHkgdHJhY2tlZCBoaW0gZG93biBhbmQgYXJyYW5nZWQgZm9yIHRoZW0gdG8gbWVldCBhZ2Fpbi4gQSBxdWljayBtZWV0aW5nIGF0IHRoZSB0YXZlcm4gdHVybmVkIGludG8gYSBsb25nIGNvbnZlcnNhdGlvbnMgbGVhZGluZyBpbnRvIHRoZSBkZWFkIG9mIG5pZ2h0LCB5ZXQgc29tZWhvdyB0aW1lIGZlbHQgbGlrZSBpdCB3YXMgc3RhbmRpbmcgc3RpbGwuIEV2ZXJ5dGhpbmcgd2FzIGZhbGxpbmcgaW50byBwbGFjZSBhbmQgdGhlIG1hdGNoIGZlbHQgbGlrZSBhIHBlcmZlY3QgZml0LiBCdXQgYXMgYSBodW1hbiBoaW1zZWxmLCB0aGUga2luZyB3YXMgc3R1YmJvcm4gYW5kIGRlY2lkZWQgaGUgd2Fzbid0IHJlYWR5IGZvciBoaXMgZGVzdGlueS48L3A+XHJcbiAgICAgICAgPHA+VGhlIGdvZHMgZGlkbid0IGxpa2UgdGhpcy4gT25lIGRheSBhcyB0aGUga2luZyB3YXMgYXQgdGhlIHRoZWF0ZXIgd2F0Y2hpbmcgdGhlIG5ld2VzdCBwbGF5LCBoZSB0b29rIG5vdGUgb2Ygb25lIG9mIHRoZSBjaGFyYWN0ZXJzLiBUaGlzIGNoYXJhY3RlciB3YXMgYSB2aWtpbmcuIEhlIHRob3VnaHQgYmFjayB0byB0aGUgdmlraW5nIHByaW5jZXNzIGFuZCBiZWdhbiB0byBkb3VidCBoaXMgY2hvaWNlcy4gVGhlIGtpbmcgZGVjaWRlZCB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmNlLiBUaGlzIHRpbWUgd2hlbiB0aGV5IG1ldCwgdGhleSB3ZXJlIGJvdGggcmVhZHkgdG8gZW1icmFjZSB0aGVpciBkZXN0aW5pZXMuPC9wPlxyXG4gICAgPC9kaXY+XHJcbjwvc2VjdGlvbj5cclxuXHJcbjxzdHlsZSBsYW5nPSdzY3NzJz5cclxuICAgIEBpbXBvcnQgJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1QcmluY2VzcytTb2ZpYSc7XHJcbiAgICBAaW1wb3J0ICcuLi8uLi8uLi9zdGF0aWMvdGhlbWUuc2Nzcyc7XHJcblxyXG4gICAgLyogU21hcnRwaG9uZXMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiAzMjBweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiA0ODBweCkgeyAgIFxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBhZHMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiA3NjhweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiAxMDI0cHgpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIERlc2t0b3BzIGFuZCBMYXB0b3BzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuXHJcbiAgICBhbmQgKG1pbi13aWR0aCA6IDEyMjRweCkge1xyXG4gICAgICAgIHAge1xyXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDIwcHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcGFuIHtcclxuICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdQcmluY2VzcyBTb2ZpYSc7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGRpdiB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogYXV0bztcclxuICAgICAgICAgICAgcGFkZGluZzogMjBweDtcclxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRiYWNrZ3JvdW5kLWNvbG9yO1xyXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMjRweDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGhvbmUgNCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbyA6IDEuNSksXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG48L3N0eWxlPiIsIjxzY3JpcHQgPlxyXG4gICAgaW1wb3J0IFNlY3Rpb25IZWFkZXIgZnJvbSAnLi9TZWN0aW9uSGVhZGVyLnN2ZWx0ZSc7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHNlY3Rpb24gY2xhc3M9J2JsZW5kZWQnPlxyXG4gICAgPFNlY3Rpb25IZWFkZXIgdGl0bGU9eydCbGVuZGVkIEZhbWlseSBSZWNpcGUnfS8+XHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxwPlB1dCBhIGdvb2QgYW5kIGhvbmVzdCBtYW48L3A+XHJcbiAgICAgICAgPHA+aW50byBhIG1peGluZyBwYW4uPC9wPlxyXG4gICAgICAgIDxwPkNvbWJpbmUgb25lIGxvdmluZyB3b21hbjwvcD5cclxuICAgICAgICA8cD5hbmQgYmxlbmQgd2VsbCB3aXRoIHRoZSBtYW4uPC9wPlxyXG4gICAgICAgIDxici8+XHJcbiAgICAgICAgPHA+QWRkIHRoZSBjaGlsZHJlbiBvZiB0aGUgbWFuLDwvcD5cclxuICAgICAgICA8cD5hbmQgdGhlIHdvbWFuJ3MgY2hpbGRyZW4gdG9vLjwvcD5cclxuICAgICAgICA8cD5NaXggdGhlbSBhbGwgdG9nZXRoZXI8L3A+XHJcbiAgICAgICAgPHA+YXMgeW91IHdvdWxkIGEgcG90IG9mIHN0ZXcuPC9wPlxyXG4gICAgICAgIDxici8+XHJcbiAgICAgICAgPHA+U2xvd2x5IHN0aXIgaW4gcGF0aWVuY2UuPC9wPlxyXG4gICAgICAgIDxwPkl0IHdpbGwgcmVhbGx5IGhlbHAgYSBsb3QuPC9wPlxyXG4gICAgICAgIDxwPklmIHlvdSdyZSBub3Qgc3VyZSBob3cgbXVjaCw8L3A+XHJcbiAgICAgICAgPHA+dGhyb3cgaW4gYWxsIHlvdSd2ZSBnb3QuPC9wPlxyXG4gICAgICAgIDxici8+XHJcbiAgICAgICAgPHA+VGhlbiwgc2l4IGN1cHMgb2Ygc3dlZXRlbmVyPC9wPlxyXG4gICAgICAgIDxwPmFuZCBmb3VydGVlbiBjdXBzIG9mIGxvdmUuPC9wPlxyXG4gICAgICAgIDxwPlNwcmlua2xlIGluIHNvbWUgYmxlc3NpbmdzPC9wPlxyXG4gICAgICAgIDxwPmZyb20gdGhlIGhlYXZlbnMgaGlnaCBhYm92ZS48L3A+XHJcbiAgICAgICAgPGJyLz5cclxuICAgICAgICA8cD5XaGVuIHRoZSBtaXh0dXJlIGlzIGNvbXBsZXRlLDwvcD5cclxuICAgICAgICA8cD53aXRoIGdyZWF0IGpveSB5b3Ugd2lsbCBzZWUuLi48L3A+XHJcbiAgICAgICAgPHA+Y3JlYXRpb24gb2Ygb3VyIGF3ZXNvbWUsPC9wPlxyXG4gICAgICAgIDxwPmxvdmluZyBibGVuZGVkIGZhbWlseS48L3A+XHJcbiAgICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5cclxuPHN0eWxlPlxyXG4gICAgLyogU21hcnRwaG9uZXMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiAzMjBweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiA0ODBweCkgeyAgIFxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBhZHMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiA3NjhweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiAxMDI0cHgpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIERlc2t0b3BzIGFuZCBMYXB0b3BzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuXHJcbiAgICBhbmQgKG1pbi13aWR0aCA6IDEyMjRweCkge1xyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBob25lIDQgLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYVxyXG4gICAgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpLFxyXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvIDogMS41KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIDwvc3R5bGU+IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJTaWVtYVwiLFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuU2llbWE9dCgpOmUuU2llbWE9dCgpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihpW3JdKXJldHVybiBpW3JdLmV4cG9ydHM7dmFyIG49aVtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsdCksbi5sPSEwLG4uZXhwb3J0c312YXIgaT17fTtyZXR1cm4gdC5tPWUsdC5jPWksdC5kPWZ1bmN0aW9uKGUsaSxyKXt0Lm8oZSxpKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBpPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQoaSxcImFcIixpKSxpfSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTApfShbZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxpLHIpe3JldHVybiBpJiZlKHQucHJvdG90eXBlLGkpLHImJmUodCxyKSx0fX0oKSxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgaT10aGlzO2lmKHIodGhpcyxlKSx0aGlzLmNvbmZpZz1lLm1lcmdlU2V0dGluZ3ModCksdGhpcy5zZWxlY3Rvcj1cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5jb25maWcuc2VsZWN0b3I/ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNvbmZpZy5zZWxlY3Rvcik6dGhpcy5jb25maWcuc2VsZWN0b3IsbnVsbD09PXRoaXMuc2VsZWN0b3IpdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdyb25nIHdpdGggeW91ciBzZWxlY3RvciDwn5itXCIpO3RoaXMucmVzb2x2ZVNsaWRlc051bWJlcigpLHRoaXMuc2VsZWN0b3JXaWR0aD10aGlzLnNlbGVjdG9yLm9mZnNldFdpZHRoLHRoaXMuaW5uZXJFbGVtZW50cz1bXS5zbGljZS5jYWxsKHRoaXMuc2VsZWN0b3IuY2hpbGRyZW4pLHRoaXMuY3VycmVudFNsaWRlPXRoaXMuY29uZmlnLmxvb3A/dGhpcy5jb25maWcuc3RhcnRJbmRleCV0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoOk1hdGgubWF4KDAsTWF0aC5taW4odGhpcy5jb25maWcuc3RhcnRJbmRleCx0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoLXRoaXMucGVyUGFnZSkpLHRoaXMudHJhbnNmb3JtUHJvcGVydHk9ZS53ZWJraXRPck5vdCgpLFtcInJlc2l6ZUhhbmRsZXJcIixcInRvdWNoc3RhcnRIYW5kbGVyXCIsXCJ0b3VjaGVuZEhhbmRsZXJcIixcInRvdWNobW92ZUhhbmRsZXJcIixcIm1vdXNlZG93bkhhbmRsZXJcIixcIm1vdXNldXBIYW5kbGVyXCIsXCJtb3VzZWxlYXZlSGFuZGxlclwiLFwibW91c2Vtb3ZlSGFuZGxlclwiLFwiY2xpY2tIYW5kbGVyXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7aVtlXT1pW2VdLmJpbmQoaSl9KSx0aGlzLmluaXQoKX1yZXR1cm4gcyhlLFt7a2V5OlwiYXR0YWNoRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMucmVzaXplSGFuZGxlciksdGhpcy5jb25maWcuZHJhZ2dhYmxlJiYodGhpcy5wb2ludGVyRG93bj0hMSx0aGlzLmRyYWc9e3N0YXJ0WDowLGVuZFg6MCxzdGFydFk6MCxsZXRJdEdvOm51bGwscHJldmVudENsaWNrOiExfSx0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy50b3VjaHN0YXJ0SGFuZGxlciksdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLnRvdWNoZW5kSGFuZGxlciksdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy50b3VjaG1vdmVIYW5kbGVyKSx0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLm1vdXNlZG93bkhhbmRsZXIpLHRoaXMuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm1vdXNldXBIYW5kbGVyKSx0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsdGhpcy5tb3VzZWxlYXZlSGFuZGxlciksdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5tb3VzZW1vdmVIYW5kbGVyKSx0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuY2xpY2tIYW5kbGVyKSl9fSx7a2V5OlwiZGV0YWNoRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMucmVzaXplSGFuZGxlciksdGhpcy5zZWxlY3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMudG91Y2hzdGFydEhhbmRsZXIpLHRoaXMuc2VsZWN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy50b3VjaGVuZEhhbmRsZXIpLHRoaXMuc2VsZWN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMudG91Y2htb3ZlSGFuZGxlciksdGhpcy5zZWxlY3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5tb3VzZWRvd25IYW5kbGVyKSx0aGlzLnNlbGVjdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5tb3VzZXVwSGFuZGxlciksdGhpcy5zZWxlY3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLHRoaXMubW91c2VsZWF2ZUhhbmRsZXIpLHRoaXMuc2VsZWN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMubW91c2Vtb3ZlSGFuZGxlciksdGhpcy5zZWxlY3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrSGFuZGxlcil9fSx7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hdHRhY2hFdmVudHMoKSx0aGlzLnNlbGVjdG9yLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdGhpcy5zZWxlY3Rvci5zdHlsZS5kaXJlY3Rpb249dGhpcy5jb25maWcucnRsP1wicnRsXCI6XCJsdHJcIix0aGlzLmJ1aWxkU2xpZGVyRnJhbWUoKSx0aGlzLmNvbmZpZy5vbkluaXQuY2FsbCh0aGlzKX19LHtrZXk6XCJidWlsZFNsaWRlckZyYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnNlbGVjdG9yV2lkdGgvdGhpcy5wZXJQYWdlLHQ9dGhpcy5jb25maWcubG9vcD90aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoKzIqdGhpcy5wZXJQYWdlOnRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGg7dGhpcy5zbGlkZXJGcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuc2xpZGVyRnJhbWUuc3R5bGUud2lkdGg9ZSp0K1wicHhcIix0aGlzLmVuYWJsZVRyYW5zaXRpb24oKSx0aGlzLmNvbmZpZy5kcmFnZ2FibGUmJih0aGlzLnNlbGVjdG9yLnN0eWxlLmN1cnNvcj1cIi13ZWJraXQtZ3JhYlwiKTt2YXIgaT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYodGhpcy5jb25maWcubG9vcClmb3IodmFyIHI9dGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aC10aGlzLnBlclBhZ2U7cjx0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoO3IrKyl7dmFyIG49dGhpcy5idWlsZFNsaWRlckZyYW1lSXRlbSh0aGlzLmlubmVyRWxlbWVudHNbcl0uY2xvbmVOb2RlKCEwKSk7aS5hcHBlbmRDaGlsZChuKX1mb3IodmFyIHM9MDtzPHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGg7cysrKXt2YXIgbD10aGlzLmJ1aWxkU2xpZGVyRnJhbWVJdGVtKHRoaXMuaW5uZXJFbGVtZW50c1tzXSk7aS5hcHBlbmRDaGlsZChsKX1pZih0aGlzLmNvbmZpZy5sb29wKWZvcih2YXIgbz0wO288dGhpcy5wZXJQYWdlO28rKyl7dmFyIGE9dGhpcy5idWlsZFNsaWRlckZyYW1lSXRlbSh0aGlzLmlubmVyRWxlbWVudHNbb10uY2xvbmVOb2RlKCEwKSk7aS5hcHBlbmRDaGlsZChhKX10aGlzLnNsaWRlckZyYW1lLmFwcGVuZENoaWxkKGkpLHRoaXMuc2VsZWN0b3IuaW5uZXJIVE1MPVwiXCIsdGhpcy5zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlckZyYW1lKSx0aGlzLnNsaWRlVG9DdXJyZW50KCl9fSx7a2V5OlwiYnVpbGRTbGlkZXJGcmFtZUl0ZW1cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiB0LnN0eWxlLmNzc0Zsb2F0PXRoaXMuY29uZmlnLnJ0bD9cInJpZ2h0XCI6XCJsZWZ0XCIsdC5zdHlsZS5mbG9hdD10aGlzLmNvbmZpZy5ydGw/XCJyaWdodFwiOlwibGVmdFwiLHQuc3R5bGUud2lkdGg9KHRoaXMuY29uZmlnLmxvb3A/MTAwLyh0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoKzIqdGhpcy5wZXJQYWdlKToxMDAvdGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aCkrXCIlXCIsdC5hcHBlbmRDaGlsZChlKSx0fX0se2tleTpcInJlc29sdmVTbGlkZXNOdW1iZXJcIix2YWx1ZTpmdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLmNvbmZpZy5wZXJQYWdlKXRoaXMucGVyUGFnZT10aGlzLmNvbmZpZy5wZXJQYWdlO2Vsc2UgaWYoXCJvYmplY3RcIj09PW4odGhpcy5jb25maWcucGVyUGFnZSkpe3RoaXMucGVyUGFnZT0xO2Zvcih2YXIgZSBpbiB0aGlzLmNvbmZpZy5wZXJQYWdlKXdpbmRvdy5pbm5lcldpZHRoPj1lJiYodGhpcy5wZXJQYWdlPXRoaXMuY29uZmlnLnBlclBhZ2VbZV0pfX19LHtrZXk6XCJwcmV2XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MSx0PWFyZ3VtZW50c1sxXTtpZighKHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGg8PXRoaXMucGVyUGFnZSkpe3ZhciBpPXRoaXMuY3VycmVudFNsaWRlO2lmKHRoaXMuY29uZmlnLmxvb3Ape2lmKHRoaXMuY3VycmVudFNsaWRlLWU8MCl7dGhpcy5kaXNhYmxlVHJhbnNpdGlvbigpO3ZhciByPXRoaXMuY3VycmVudFNsaWRlK3RoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgsbj10aGlzLnBlclBhZ2Uscz1yK24sbD0odGhpcy5jb25maWcucnRsPzE6LTEpKnMqKHRoaXMuc2VsZWN0b3JXaWR0aC90aGlzLnBlclBhZ2UpLG89dGhpcy5jb25maWcuZHJhZ2dhYmxlP3RoaXMuZHJhZy5lbmRYLXRoaXMuZHJhZy5zdGFydFg6MDt0aGlzLnNsaWRlckZyYW1lLnN0eWxlW3RoaXMudHJhbnNmb3JtUHJvcGVydHldPVwidHJhbnNsYXRlM2QoXCIrKGwrbykrXCJweCwgMCwgMClcIix0aGlzLmN1cnJlbnRTbGlkZT1yLWV9ZWxzZSB0aGlzLmN1cnJlbnRTbGlkZT10aGlzLmN1cnJlbnRTbGlkZS1lfWVsc2UgdGhpcy5jdXJyZW50U2xpZGU9TWF0aC5tYXgodGhpcy5jdXJyZW50U2xpZGUtZSwwKTtpIT09dGhpcy5jdXJyZW50U2xpZGUmJih0aGlzLnNsaWRlVG9DdXJyZW50KHRoaXMuY29uZmlnLmxvb3ApLHRoaXMuY29uZmlnLm9uQ2hhbmdlLmNhbGwodGhpcyksdCYmdC5jYWxsKHRoaXMpKX19fSx7a2V5OlwibmV4dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjEsdD1hcmd1bWVudHNbMV07aWYoISh0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoPD10aGlzLnBlclBhZ2UpKXt2YXIgaT10aGlzLmN1cnJlbnRTbGlkZTtpZih0aGlzLmNvbmZpZy5sb29wKXtpZih0aGlzLmN1cnJlbnRTbGlkZStlPnRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgtdGhpcy5wZXJQYWdlKXt0aGlzLmRpc2FibGVUcmFuc2l0aW9uKCk7dmFyIHI9dGhpcy5jdXJyZW50U2xpZGUtdGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aCxuPXRoaXMucGVyUGFnZSxzPXIrbixsPSh0aGlzLmNvbmZpZy5ydGw/MTotMSkqcyoodGhpcy5zZWxlY3RvcldpZHRoL3RoaXMucGVyUGFnZSksbz10aGlzLmNvbmZpZy5kcmFnZ2FibGU/dGhpcy5kcmFnLmVuZFgtdGhpcy5kcmFnLnN0YXJ0WDowO3RoaXMuc2xpZGVyRnJhbWUuc3R5bGVbdGhpcy50cmFuc2Zvcm1Qcm9wZXJ0eV09XCJ0cmFuc2xhdGUzZChcIisobCtvKStcInB4LCAwLCAwKVwiLHRoaXMuY3VycmVudFNsaWRlPXIrZX1lbHNlIHRoaXMuY3VycmVudFNsaWRlPXRoaXMuY3VycmVudFNsaWRlK2V9ZWxzZSB0aGlzLmN1cnJlbnRTbGlkZT1NYXRoLm1pbih0aGlzLmN1cnJlbnRTbGlkZStlLHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgtdGhpcy5wZXJQYWdlKTtpIT09dGhpcy5jdXJyZW50U2xpZGUmJih0aGlzLnNsaWRlVG9DdXJyZW50KHRoaXMuY29uZmlnLmxvb3ApLHRoaXMuY29uZmlnLm9uQ2hhbmdlLmNhbGwodGhpcyksdCYmdC5jYWxsKHRoaXMpKX19fSx7a2V5OlwiZGlzYWJsZVRyYW5zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2xpZGVyRnJhbWUuc3R5bGUud2Via2l0VHJhbnNpdGlvbj1cImFsbCAwbXMgXCIrdGhpcy5jb25maWcuZWFzaW5nLHRoaXMuc2xpZGVyRnJhbWUuc3R5bGUudHJhbnNpdGlvbj1cImFsbCAwbXMgXCIrdGhpcy5jb25maWcuZWFzaW5nfX0se2tleTpcImVuYWJsZVRyYW5zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2xpZGVyRnJhbWUuc3R5bGUud2Via2l0VHJhbnNpdGlvbj1cImFsbCBcIit0aGlzLmNvbmZpZy5kdXJhdGlvbitcIm1zIFwiK3RoaXMuY29uZmlnLmVhc2luZyx0aGlzLnNsaWRlckZyYW1lLnN0eWxlLnRyYW5zaXRpb249XCJhbGwgXCIrdGhpcy5jb25maWcuZHVyYXRpb24rXCJtcyBcIit0aGlzLmNvbmZpZy5lYXNpbmd9fSx7a2V5OlwiZ29Ub1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoPD10aGlzLnBlclBhZ2UpKXt2YXIgaT10aGlzLmN1cnJlbnRTbGlkZTt0aGlzLmN1cnJlbnRTbGlkZT10aGlzLmNvbmZpZy5sb29wP2UldGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aDpNYXRoLm1pbihNYXRoLm1heChlLDApLHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgtdGhpcy5wZXJQYWdlKSxpIT09dGhpcy5jdXJyZW50U2xpZGUmJih0aGlzLnNsaWRlVG9DdXJyZW50KCksdGhpcy5jb25maWcub25DaGFuZ2UuY2FsbCh0aGlzKSx0JiZ0LmNhbGwodGhpcykpfX19LHtrZXk6XCJzbGlkZVRvQ3VycmVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsaT10aGlzLmNvbmZpZy5sb29wP3RoaXMuY3VycmVudFNsaWRlK3RoaXMucGVyUGFnZTp0aGlzLmN1cnJlbnRTbGlkZSxyPSh0aGlzLmNvbmZpZy5ydGw/MTotMSkqaSoodGhpcy5zZWxlY3RvcldpZHRoL3RoaXMucGVyUGFnZSk7ZT9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt0LmVuYWJsZVRyYW5zaXRpb24oKSx0LnNsaWRlckZyYW1lLnN0eWxlW3QudHJhbnNmb3JtUHJvcGVydHldPVwidHJhbnNsYXRlM2QoXCIrcitcInB4LCAwLCAwKVwifSl9KTp0aGlzLnNsaWRlckZyYW1lLnN0eWxlW3RoaXMudHJhbnNmb3JtUHJvcGVydHldPVwidHJhbnNsYXRlM2QoXCIrcitcInB4LCAwLCAwKVwifX0se2tleTpcInVwZGF0ZUFmdGVyRHJhZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9KHRoaXMuY29uZmlnLnJ0bD8tMToxKSoodGhpcy5kcmFnLmVuZFgtdGhpcy5kcmFnLnN0YXJ0WCksdD1NYXRoLmFicyhlKSxpPXRoaXMuY29uZmlnLm11bHRpcGxlRHJhZz9NYXRoLmNlaWwodC8odGhpcy5zZWxlY3RvcldpZHRoL3RoaXMucGVyUGFnZSkpOjEscj1lPjAmJnRoaXMuY3VycmVudFNsaWRlLWk8MCxuPWU8MCYmdGhpcy5jdXJyZW50U2xpZGUraT50aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoLXRoaXMucGVyUGFnZTtlPjAmJnQ+dGhpcy5jb25maWcudGhyZXNob2xkJiZ0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoPnRoaXMucGVyUGFnZT90aGlzLnByZXYoaSk6ZTwwJiZ0PnRoaXMuY29uZmlnLnRocmVzaG9sZCYmdGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aD50aGlzLnBlclBhZ2UmJnRoaXMubmV4dChpKSx0aGlzLnNsaWRlVG9DdXJyZW50KHJ8fG4pfX0se2tleTpcInJlc2l6ZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucmVzb2x2ZVNsaWRlc051bWJlcigpLHRoaXMuY3VycmVudFNsaWRlK3RoaXMucGVyUGFnZT50aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoJiYodGhpcy5jdXJyZW50U2xpZGU9dGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aDw9dGhpcy5wZXJQYWdlPzA6dGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aC10aGlzLnBlclBhZ2UpLHRoaXMuc2VsZWN0b3JXaWR0aD10aGlzLnNlbGVjdG9yLm9mZnNldFdpZHRoLHRoaXMuYnVpbGRTbGlkZXJGcmFtZSgpfX0se2tleTpcImNsZWFyRHJhZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kcmFnPXtzdGFydFg6MCxlbmRYOjAsc3RhcnRZOjAsbGV0SXRHbzpudWxsLHByZXZlbnRDbGljazp0aGlzLmRyYWcucHJldmVudENsaWNrfX19LHtrZXk6XCJ0b3VjaHN0YXJ0SGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpey0xIT09W1wiVEVYVEFSRUFcIixcIk9QVElPTlwiLFwiSU5QVVRcIixcIlNFTEVDVFwiXS5pbmRleE9mKGUudGFyZ2V0Lm5vZGVOYW1lKXx8KGUuc3RvcFByb3BhZ2F0aW9uKCksdGhpcy5wb2ludGVyRG93bj0hMCx0aGlzLmRyYWcuc3RhcnRYPWUudG91Y2hlc1swXS5wYWdlWCx0aGlzLmRyYWcuc3RhcnRZPWUudG91Y2hlc1swXS5wYWdlWSl9fSx7a2V5OlwidG91Y2hlbmRIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSx0aGlzLnBvaW50ZXJEb3duPSExLHRoaXMuZW5hYmxlVHJhbnNpdGlvbigpLHRoaXMuZHJhZy5lbmRYJiZ0aGlzLnVwZGF0ZUFmdGVyRHJhZygpLHRoaXMuY2xlYXJEcmFnKCl9fSx7a2V5OlwidG91Y2htb3ZlSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksbnVsbD09PXRoaXMuZHJhZy5sZXRJdEdvJiYodGhpcy5kcmFnLmxldEl0R289TWF0aC5hYnModGhpcy5kcmFnLnN0YXJ0WS1lLnRvdWNoZXNbMF0ucGFnZVkpPE1hdGguYWJzKHRoaXMuZHJhZy5zdGFydFgtZS50b3VjaGVzWzBdLnBhZ2VYKSksdGhpcy5wb2ludGVyRG93biYmdGhpcy5kcmFnLmxldEl0R28pe2UucHJldmVudERlZmF1bHQoKSx0aGlzLmRyYWcuZW5kWD1lLnRvdWNoZXNbMF0ucGFnZVgsdGhpcy5zbGlkZXJGcmFtZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uPVwiYWxsIDBtcyBcIit0aGlzLmNvbmZpZy5lYXNpbmcsdGhpcy5zbGlkZXJGcmFtZS5zdHlsZS50cmFuc2l0aW9uPVwiYWxsIDBtcyBcIit0aGlzLmNvbmZpZy5lYXNpbmc7dmFyIHQ9dGhpcy5jb25maWcubG9vcD90aGlzLmN1cnJlbnRTbGlkZSt0aGlzLnBlclBhZ2U6dGhpcy5jdXJyZW50U2xpZGUsaT10Kih0aGlzLnNlbGVjdG9yV2lkdGgvdGhpcy5wZXJQYWdlKSxyPXRoaXMuZHJhZy5lbmRYLXRoaXMuZHJhZy5zdGFydFgsbj10aGlzLmNvbmZpZy5ydGw/aStyOmktcjt0aGlzLnNsaWRlckZyYW1lLnN0eWxlW3RoaXMudHJhbnNmb3JtUHJvcGVydHldPVwidHJhbnNsYXRlM2QoXCIrKHRoaXMuY29uZmlnLnJ0bD8xOi0xKSpuK1wicHgsIDAsIDApXCJ9fX0se2tleTpcIm1vdXNlZG93bkhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXstMSE9PVtcIlRFWFRBUkVBXCIsXCJPUFRJT05cIixcIklOUFVUXCIsXCJTRUxFQ1RcIl0uaW5kZXhPZihlLnRhcmdldC5ub2RlTmFtZSl8fChlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSx0aGlzLnBvaW50ZXJEb3duPSEwLHRoaXMuZHJhZy5zdGFydFg9ZS5wYWdlWCl9fSx7a2V5OlwibW91c2V1cEhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLHRoaXMucG9pbnRlckRvd249ITEsdGhpcy5zZWxlY3Rvci5zdHlsZS5jdXJzb3I9XCItd2Via2l0LWdyYWJcIix0aGlzLmVuYWJsZVRyYW5zaXRpb24oKSx0aGlzLmRyYWcuZW5kWCYmdGhpcy51cGRhdGVBZnRlckRyYWcoKSx0aGlzLmNsZWFyRHJhZygpfX0se2tleTpcIm1vdXNlbW92ZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlLnByZXZlbnREZWZhdWx0KCksdGhpcy5wb2ludGVyRG93bil7XCJBXCI9PT1lLnRhcmdldC5ub2RlTmFtZSYmKHRoaXMuZHJhZy5wcmV2ZW50Q2xpY2s9ITApLHRoaXMuZHJhZy5lbmRYPWUucGFnZVgsdGhpcy5zZWxlY3Rvci5zdHlsZS5jdXJzb3I9XCItd2Via2l0LWdyYWJiaW5nXCIsdGhpcy5zbGlkZXJGcmFtZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uPVwiYWxsIDBtcyBcIit0aGlzLmNvbmZpZy5lYXNpbmcsdGhpcy5zbGlkZXJGcmFtZS5zdHlsZS50cmFuc2l0aW9uPVwiYWxsIDBtcyBcIit0aGlzLmNvbmZpZy5lYXNpbmc7dmFyIHQ9dGhpcy5jb25maWcubG9vcD90aGlzLmN1cnJlbnRTbGlkZSt0aGlzLnBlclBhZ2U6dGhpcy5jdXJyZW50U2xpZGUsaT10Kih0aGlzLnNlbGVjdG9yV2lkdGgvdGhpcy5wZXJQYWdlKSxyPXRoaXMuZHJhZy5lbmRYLXRoaXMuZHJhZy5zdGFydFgsbj10aGlzLmNvbmZpZy5ydGw/aStyOmktcjt0aGlzLnNsaWRlckZyYW1lLnN0eWxlW3RoaXMudHJhbnNmb3JtUHJvcGVydHldPVwidHJhbnNsYXRlM2QoXCIrKHRoaXMuY29uZmlnLnJ0bD8xOi0xKSpuK1wicHgsIDAsIDApXCJ9fX0se2tleTpcIm1vdXNlbGVhdmVIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wb2ludGVyRG93biYmKHRoaXMucG9pbnRlckRvd249ITEsdGhpcy5zZWxlY3Rvci5zdHlsZS5jdXJzb3I9XCItd2Via2l0LWdyYWJcIix0aGlzLmRyYWcuZW5kWD1lLnBhZ2VYLHRoaXMuZHJhZy5wcmV2ZW50Q2xpY2s9ITEsdGhpcy5lbmFibGVUcmFuc2l0aW9uKCksdGhpcy51cGRhdGVBZnRlckRyYWcoKSx0aGlzLmNsZWFyRHJhZygpKX19LHtrZXk6XCJjbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmRyYWcucHJldmVudENsaWNrJiZlLnByZXZlbnREZWZhdWx0KCksdGhpcy5kcmFnLnByZXZlbnRDbGljaz0hMX19LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGU8MHx8ZT49dGhpcy5pbm5lckVsZW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJdGVtIHRvIHJlbW92ZSBkb2Vzbid0IGV4aXN0IPCfmK1cIik7dmFyIGk9ZTx0aGlzLmN1cnJlbnRTbGlkZSxyPXRoaXMuY3VycmVudFNsaWRlK3RoaXMucGVyUGFnZS0xPT09ZTsoaXx8cikmJnRoaXMuY3VycmVudFNsaWRlLS0sdGhpcy5pbm5lckVsZW1lbnRzLnNwbGljZShlLDEpLHRoaXMuYnVpbGRTbGlkZXJGcmFtZSgpLHQmJnQuY2FsbCh0aGlzKX19LHtrZXk6XCJpbnNlcnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7aWYodDwwfHx0PnRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgrMSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5zZXQgaXQgYXQgdGhpcyBpbmRleCDwn5itXCIpO2lmKC0xIT09dGhpcy5pbm5lckVsZW1lbnRzLmluZGV4T2YoZSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNhbWUgaXRlbSBpbiBhIGNhcm91c2VsPyBSZWFsbHk/IE5vcGUg8J+YrVwiKTt2YXIgcj10PD10aGlzLmN1cnJlbnRTbGlkZT4wJiZ0aGlzLmlubmVyRWxlbWVudHMubGVuZ3RoO3RoaXMuY3VycmVudFNsaWRlPXI/dGhpcy5jdXJyZW50U2xpZGUrMTp0aGlzLmN1cnJlbnRTbGlkZSx0aGlzLmlubmVyRWxlbWVudHMuc3BsaWNlKHQsMCxlKSx0aGlzLmJ1aWxkU2xpZGVyRnJhbWUoKSxpJiZpLmNhbGwodGhpcyl9fSx7a2V5OlwicHJlcGVuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5pbnNlcnQoZSwwKSx0JiZ0LmNhbGwodGhpcyl9fSx7a2V5OlwiYXBwZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmluc2VydChlLHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGgrMSksdCYmdC5jYWxsKHRoaXMpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sdD1hcmd1bWVudHNbMV07aWYodGhpcy5kZXRhY2hFdmVudHMoKSx0aGlzLnNlbGVjdG9yLnN0eWxlLmN1cnNvcj1cImF1dG9cIixlKXtmb3IodmFyIGk9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9MDtyPHRoaXMuaW5uZXJFbGVtZW50cy5sZW5ndGg7cisrKWkuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW1lbnRzW3JdKTt0aGlzLnNlbGVjdG9yLmlubmVySFRNTD1cIlwiLHRoaXMuc2VsZWN0b3IuYXBwZW5kQ2hpbGQoaSksdGhpcy5zZWxlY3Rvci5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKX10JiZ0LmNhbGwodGhpcyl9fV0sW3trZXk6XCJtZXJnZVNldHRpbmdzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e3NlbGVjdG9yOlwiLnNpZW1hXCIsZHVyYXRpb246MjAwLGVhc2luZzpcImVhc2Utb3V0XCIscGVyUGFnZToxLHN0YXJ0SW5kZXg6MCxkcmFnZ2FibGU6ITAsbXVsdGlwbGVEcmFnOiEwLHRocmVzaG9sZDoyMCxsb29wOiExLHJ0bDohMSxvbkluaXQ6ZnVuY3Rpb24oKXt9LG9uQ2hhbmdlOmZ1bmN0aW9uKCl7fX0saT1lO2Zvcih2YXIgciBpbiBpKXRbcl09aVtyXTtyZXR1cm4gdH19LHtrZXk6XCJ3ZWJraXRPck5vdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0/XCJ0cmFuc2Zvcm1cIjpcIldlYmtpdFRyYW5zZm9ybVwifX1dKSxlfSgpO3QuZGVmYXVsdD1sLGUuZXhwb3J0cz10LmRlZmF1bHR9XSl9KTsiLCJcbjxkaXYgY2xhc3M9XCJjYXJvdXNlbFwiPlxuXHQ8ZGl2IGNsYXNzPVwic2xpZGVzXCIgYmluZDp0aGlzPXtzaWVtYX0+XG5cdFx0PHNsb3Q+PC9zbG90PlxuXHQ8L2Rpdj5cblx0eyNpZiBjb250cm9sc31cblx0PGJ1dHRvbiBjbGFzcz1cImxlZnRcIiBvbjpjbGljaz17bGVmdH0gYXJpYS1sYWJlbD1cImxlZnRcIj5cblx0XHQ8c2xvdCBuYW1lPVwibGVmdC1jb250cm9sXCI+PC9zbG90PlxuXHQ8L2J1dHRvbj5cblx0PGJ1dHRvbiBjbGFzcz1cInJpZ2h0XCIgb246Y2xpY2s9e3JpZ2h0fSBhcmlhLWxhYmVsPVwicmlnaHRcIj5cblx0XHQ8c2xvdCBuYW1lPVwicmlnaHQtY29udHJvbFwiPjwvc2xvdD5cblx0PC9idXR0b24+XG5cdHsvaWZ9XG4gICAgeyNpZiBkb3RzfVxuXHQ8dWw+XG5cdFx0eyNlYWNoIHtsZW5ndGg6IHRvdGFsRG90c30gYXMgXywgaX1cblx0XHQ8bGkgb246Y2xpY2s9eygpID0+IGdvKGkqY3VycmVudFBlclBhZ2UpfSBjbGFzcz17aXNEb3RBY3RpdmUoY3VycmVudEluZGV4LCBpKSA/IFwiYWN0aXZlXCIgOiBcIlwifT48L2xpPlxuXHRcdHsvZWFjaH1cblx0PC91bD5cbiAgICB7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cblx0LmNhcm91c2VsIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0fVxuXHRcblx0YnV0dG9uIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDQwcHg7XG5cdFx0aGVpZ2h0OiA0MHB4O1xuXHRcdHRvcDogNTAlO1xuXHRcdHotaW5kZXg6IDUwO1xuXHRcdG1hcmdpbi10b3A6IC0yMHB4O1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0fVxuXG4gIGJ1dHRvbjpmb2N1cyB7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgfVxuXHRcblx0LmxlZnQge1xuXHRcdGxlZnQ6IDJ2dztcblx0fVxuXHRcblx0LnJpZ2h0IHtcblx0XHRyaWdodDogMnZ3O1xuXHR9XG5cblx0dWwge1xuXHRcdGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRtYXJnaW4tdG9wOiAtMzBweDtcblx0XHRwYWRkaW5nOiAwO1xuXHR9XG5cblx0dWwgbGkge1xuXHRcdG1hcmdpbjogNnB4O1xuXHRcdGJvcmRlci1yYWRpdXM6IDEwMCU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjUpO1xuXHRcdGhlaWdodDogOHB4O1xuXHRcdHdpZHRoOiA4cHg7XG5cdH1cblxuXHR1bCBsaTpob3ZlciB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjg1KTtcblx0fVxuXG5cdHVsIGxpLmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwxKTtcblx0fVxuPC9zdHlsZT5cblxuPHNjcmlwdD5cblx0aW1wb3J0IFNpZW1hIGZyb20gJ3NpZW1hJ1xuXHRpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG5cdFxuXHRleHBvcnQgbGV0IHBlclBhZ2UgPSAzXG5cdGV4cG9ydCBsZXQgbG9vcCA9IHRydWVcblx0ZXhwb3J0IGxldCBhdXRvcGxheSA9IDBcblx0ZXhwb3J0IGxldCBkdXJhdGlvbiA9IDIwMFxuXHRleHBvcnQgbGV0IGVhc2luZyA9ICdlYXNlLW91dCdcblx0ZXhwb3J0IGxldCBzdGFydEluZGV4ID0gMFxuXHRleHBvcnQgbGV0IGRyYWdnYWJsZSA9IHRydWVcblx0ZXhwb3J0IGxldCBtdWx0aXBsZURyYWcgPSB0cnVlXHRcblx0ZXhwb3J0IGxldCBkb3RzID0gdHJ1ZVx0XG5cdGV4cG9ydCBsZXQgY29udHJvbHMgPSB0cnVlXG5cdGV4cG9ydCBsZXQgdGhyZXNob2xkID0gMjBcblx0ZXhwb3J0IGxldCBydGwgPSBmYWxzZVxuXHRsZXQgY3VycmVudEluZGV4ID0gc3RhcnRJbmRleDtcblx0XG5cdGxldCBzaWVtYVxuXHRsZXQgY29udHJvbGxlclxuXHRsZXQgdGltZXJcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cblx0JDogcGlwcyA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLmlubmVyRWxlbWVudHMgOiBbXVxuXHQkOiBjdXJyZW50UGVyUGFnZSA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLnBlclBhZ2UgOiBwZXJQYWdlXG5cdCQ6IHRvdGFsRG90cyA9IGNvbnRyb2xsZXIgPyBNYXRoLmNlaWwoY29udHJvbGxlci5pbm5lckVsZW1lbnRzLmxlbmd0aCAvIGN1cnJlbnRQZXJQYWdlKSA6IFtdXG5cdFxuXHRvbk1vdW50KCgpID0+IHtcblx0XHRjb250cm9sbGVyID0gbmV3IFNpZW1hKHtcblx0XHRcdHNlbGVjdG9yOiBzaWVtYSxcblx0XHRcdHBlclBhZ2U6IHR5cGVvZiBwZXJQYWdlID09PSAnb2JqZWN0JyA/IHBlclBhZ2UgOiBOdW1iZXIocGVyUGFnZSksXG5cdFx0XHRsb29wLFxuICBcdFx0XHRkdXJhdGlvbixcbiAgXHRcdFx0ZWFzaW5nLFxuICBcdFx0XHRzdGFydEluZGV4LFxuICBcdFx0XHRkcmFnZ2FibGUsXG4gXHRcdFx0bXVsdGlwbGVEcmFnLFxuICBcdFx0XHR0aHJlc2hvbGQsXG4gIFx0XHRcdHJ0bCxcblx0XHRcdG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2Vcblx0XHR9KVxuXHRcdFxuXHRcdGlmKGF1dG9wbGF5KSB7XG5cdFx0XHR0aW1lciA9IHNldEludGVydmFsKHJpZ2h0LCBhdXRvcGxheSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGF1dG9wbGF5ICYmIGNsZWFySW50ZXJ2YWwodGltZXIpXG5cdFx0XHRjb250cm9sbGVyLmRlc3Ryb3koKVxuXHRcdH1cblx0fSlcblxuXHRleHBvcnQgZnVuY3Rpb24gaXNEb3RBY3RpdmUgKGN1cnJlbnRJbmRleCwgZG90SW5kZXgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IDApIGN1cnJlbnRJbmRleCA9IHBpcHMubGVuZ3RoICsgY3VycmVudEluZGV4O1xuICAgICAgICByZXR1cm4gY3VycmVudEluZGV4ID49IGRvdEluZGV4KmN1cnJlbnRQZXJQYWdlICYmIGN1cnJlbnRJbmRleCA8IChkb3RJbmRleCpjdXJyZW50UGVyUGFnZSkrY3VycmVudFBlclBhZ2VcbiAgICB9XG5cdFxuXHRleHBvcnQgZnVuY3Rpb24gbGVmdCAoKSB7XG5cdFx0Y29udHJvbGxlci5wcmV2KClcblx0fVxuXHRcblx0ZXhwb3J0IGZ1bmN0aW9uIHJpZ2h0ICgpIHtcblx0XHRjb250cm9sbGVyLm5leHQoKVxuXHR9XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIGdvIChpbmRleCkge1xuXHRcdGNvbnRyb2xsZXIuZ29UbyhpbmRleClcblx0fVxuXHRcblx0ZXhwb3J0IGZ1bmN0aW9uIHBhdXNlKCkge1xuXHRcdGNsZWFySW50ZXJ2YWwodGltZXIpO1xuXHR9XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHJlc3VtZSgpIHtcblx0XHRpZiAoYXV0b3BsYXkpIHtcblx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwocmlnaHQsIGF1dG9wbGF5KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVDaGFuZ2UgKGV2ZW50KSB7XG5cdFx0Y3VycmVudEluZGV4ID0gY29udHJvbGxlci5jdXJyZW50U2xpZGVcblxuXHRcdGRpc3BhdGNoKCdjaGFuZ2UnLCB7XG5cdFx0XHRjdXJyZW50U2xpZGU6IGNvbnRyb2xsZXIuY3VycmVudFNsaWRlLFxuXHRcdFx0c2xpZGVDb3VudDogY29udHJvbGxlci5pbm5lckVsZW1lbnRzLmxlbmd0aFxuXHRcdH0gKVxuXHR9XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgc2l6ZSA9IFwiMTAwJVwiO1xuICBsZXQgY3VzdG9tQ2xhc3MgPSBcIlwiO1xuICBleHBvcnQgeyBjdXN0b21DbGFzcyBhcyBjbGFzcyB9O1xuXG4gIGlmIChzaXplICE9PSBcIjEwMCVcIikge1xuICAgIHNpemUgPSBzaXplLnNsaWNlKC0xKSA9PT0gJ3gnIFxuICAgICAgICAgID8gc2l6ZS5zbGljZSgwLCBzaXplLmxlbmd0aCAtMSkgKyAnZW0nXG4gICAgICAgICAgOiBwYXJzZUludChzaXplKSArICdweCc7XG4gIH1cbjwvc2NyaXB0PlxuXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD17c2l6ZX0gaGVpZ2h0PXtzaXplfSBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGNsYXNzPVwiZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tbGVmdCB7Y3VzdG9tQ2xhc3N9XCI+PHBvbHlsaW5lIHBvaW50cz1cIjE1IDE4IDkgMTIgMTUgNlwiPjwvcG9seWxpbmU+PC9zdmc+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IHNpemUgPSBcIjEwMCVcIjtcbiAgbGV0IGN1c3RvbUNsYXNzID0gXCJcIjtcbiAgZXhwb3J0IHsgY3VzdG9tQ2xhc3MgYXMgY2xhc3MgfTtcblxuICBpZiAoc2l6ZSAhPT0gXCIxMDAlXCIpIHtcbiAgICBzaXplID0gc2l6ZS5zbGljZSgtMSkgPT09ICd4JyBcbiAgICAgICAgICA/IHNpemUuc2xpY2UoMCwgc2l6ZS5sZW5ndGggLTEpICsgJ2VtJ1xuICAgICAgICAgIDogcGFyc2VJbnQoc2l6ZSkgKyAncHgnO1xuICB9XG48L3NjcmlwdD5cblxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9e3NpemV9IGhlaWdodD17c2l6ZX0gZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBjbGFzcz1cImZlYXRoZXIgZmVhdGhlci1jaGV2cm9uLXJpZ2h0IHtjdXN0b21DbGFzc31cIj48cG9seWxpbmUgcG9pbnRzPVwiOSAxOCAxNSAxMiA5IDZcIj48L3BvbHlsaW5lPjwvc3ZnPlxuIiwiPHNjcmlwdD5cclxuICAgIGltcG9ydCBTZWN0aW9uSGVhZGVyIGZyb20gJy4vU2VjdGlvbkhlYWRlci5zdmVsdGUnO1xyXG5cdGltcG9ydCBDYXJvdXNlbCBmcm9tICdAYmV5b25rL3N2ZWx0ZS1jYXJvdXNlbCc7XHJcbiAgICBpbXBvcnQgeyBDaGV2cm9uTGVmdEljb24sIENoZXZyb25SaWdodEljb24gfSBmcm9tICdzdmVsdGUtZmVhdGhlci1pY29ucyc7XHJcblxyXG5cdGxldCBjYXJvdXNlbHMgPSBbXHJcblx0XHR7XHJcblx0XHRcdHBlclBhZ2U6IDFcclxuXHRcdH1cclxuICAgIF1cclxuICAgIFxyXG4gICAgbGV0IHBob3RvcyA9IFtcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9HcmFuZGNoaWxkcmVuV2l0aEJhcmIuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9DaGVlc2UuanBnJyxcdFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL01vdmluZ0RheS5qcGcnLFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL0ZpcmVBbmRJY2UuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9XaXRoTGlhbS5qcGcnLFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL0xha2UuanBnJyxcdFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL1dpdGhOb3JhLmpwZycsXHJcbiAgICAgICAgJ2h0dHBzOi8vbGlzYWFuZHRpbXBpY3R1cmVzLnMzLmFtYXpvbmF3cy5jb20vTWFza3MuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9DYXJlbmFBbmREb2cuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9NYXNrczIuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9SaGlhbm5haEFuZEFkYW0uanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9TcG9ydHNCYXIuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9TdW1tZXJBbmRDbGFuLmpwZycsXHJcbiAgICAgICAgJ2h0dHBzOi8vbGlzYWFuZHRpbXBpY3R1cmVzLnMzLmFtYXpvbmF3cy5jb20vU3RQYXRyaWNrc0RheS5qcGcnLFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL1RvcnlBbmRDYXJlbmFBbmRCcmkuanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9Ub3J5QW5kQ2xhbi5qcGcnLFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL0F1c3RpbkFuZENsYW4uanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9HcmFuZGNoaWxkcmVuLmpwZycsXHJcbiAgICAgICAgJ2h0dHBzOi8vbGlzYWFuZHRpbXBpY3R1cmVzLnMzLmFtYXpvbmF3cy5jb20vU2hhbm5vbkFuZENsYW4uanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9XaXRoUmhpYW5uYWguanBnJyxcclxuICAgICAgICAnaHR0cHM6Ly9saXNhYW5kdGltcGljdHVyZXMuczMuYW1hem9uYXdzLmNvbS9MaXNhQW5kQWRhbS5qcGcnLFxyXG4gICAgICAgICdodHRwczovL2xpc2FhbmR0aW1waWN0dXJlcy5zMy5hbWF6b25hd3MuY29tL05hbmFBbmRQb3Bwb3AuanBnJ1xyXG4gICAgXTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c2VjdGlvbiBjbGFzcz0nY2xhbic+XHJcbiAgICA8U2VjdGlvbkhlYWRlciB0aXRsZT17J091ciBDbGFuJ30vPlxyXG4gICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cclxuICAgICAgICB7I2VhY2ggY2Fyb3VzZWxzIGFzIGNhcm91c2VsfVxyXG4gICAgICAgIDxDYXJvdXNlbCB7Li4uY2Fyb3VzZWx9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNvbnRyb2xcIiBzbG90PVwibGVmdC1jb250cm9sXCI+XHJcbiAgICAgICAgICAgICAgICA8Q2hldnJvbkxlZnRJY29uIC8+XHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgeyNlYWNoIHBob3RvcyBhcyBwaG90b31cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNsaWRlLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtwaG90b30gYWx0PSdwaWMnPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNvbnRyb2xcIiBzbG90PVwicmlnaHQtY29udHJvbFwiPlxyXG4gICAgICAgICAgICAgICAgPENoZXZyb25SaWdodEljb24gLz5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDwvQ2Fyb3VzZWw+XHJcbiAgICAgICAgPGJyLz5cclxuICAgICAgICA8YnIvPlxyXG4gICAgICAgIHsvZWFjaH1cclxuICAgIDwvZGl2PlxyXG48L3NlY3Rpb24+XHJcblxyXG48c3R5bGUgbGFuZz0nc2Nzcyc+XHJcbiAgICAgICAgQGltcG9ydCAnLi4vLi4vLi4vc3RhdGljL3RoZW1lLnNjc3MnO1xyXG5cclxuXHQuZGVtbywuY2Fyb3VzZWwge1xyXG5cdFx0bWFyZ2luOiAwIGF1dG87XHJcblx0XHRoZWlnaHQ6IDYwMHB4O1xyXG5cdFx0d2lkdGg6IDYwMHB4O1xyXG4gICAgICAgIG92ZXJmbG93OmhpZGRlbjtcclxuXHR9XHJcblx0XHJcblx0LmNvbnRyb2wgOmdsb2JhbChzdmcpIHtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0aGVpZ2h0OiAxMDAlO1xyXG5cdFx0Y29sb3I6ICNmZmY7XHJcblx0XHRib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMzJweDtcclxuXHR9XHJcblx0XHJcblx0LnNsaWRlLWNvbnRlbnQge1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgI2VlZTtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG5cdFx0aGVpZ2h0OiA2MDBweDtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYWNjZW50LWNvbG9yLWdyZWVuO1xyXG5cdH1cclxuXHRcclxuICAgIGltZyB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIHRvcDogNTAlO1xyXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcclxuICAgIH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdCBsYW5nPSd0eXBlc2NyaXB0Jz4gXHJcbiAgICBpbXBvcnQgeyBUb2FzdE1vZGVsIH0gZnJvbSAnLi4vX21vZGVscy9Ub2FzdE1vZGVsJztcclxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgXHJcbiAgICBleHBvcnQgbGV0IGlzTG9nZ2VkSW46IGJvb2xlYW47XHJcbiAgICBleHBvcnQgbGV0IGZhY2Vib29rVXNlcklkOiBzdHJpbmc7XHJcbiAgICBleHBvcnQgbGV0IHRvYXN0OiBUb2FzdE1vZGVsO1xyXG4gICAgZXhwb3J0IGxldCBpc0VkaXR0aW5nVG9hc3Q6IGJvb2xlYW47XHJcbiAgICBcclxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb3Bvc2VUb2FzdCAoKSB7XHJcbiAgICAgICAgaWYgKHRvYXN0LnRvYXN0ZXJOYW1lID09ICcnIHx8IHRvYXN0LnRvYXN0Q29udGVudCA9PSAnJyl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvYXN0LnRvYXN0ZXJGYWNlYm9va0lkID0gZmFjZWJvb2tVc2VySWQ7XHJcbiAgICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvdG9hc3RDb250cm9sbGVyJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywgXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt0b2FzdH0pLCBcclxuICAgICAgICAgICAgaGVhZGVyczoge1wiQ29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwifVxyXG4gICAgICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVG9hc3QgKCkge1xyXG4gICAgICAgIGlmICh0b2FzdC50b2FzdGVyTmFtZSA9PSAnJyB8fCB0b2FzdC50b2FzdENvbnRlbnQgPT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvdG9hc3RDb250cm9sbGVyJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7dG9hc3R9KSxcclxuICAgICAgICAgICAgaGVhZGVyczoge1wiQ29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwifVxyXG4gICAgICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2dJbiAoKSB7XHJcbiAgICAgICAgZGlzcGF0Y2goXCJ0b2dnbGVMb2dJblwiKTtcclxuICAgIH1cclxuXHJcbjwvc2NyaXB0PlxyXG5cclxuPHNlY3Rpb24gY2xhc3M9J3Byb3Bvc2UnPlxyXG4gICAgPGRpdiBjbGFzcz0nZm9ybSc+XHJcbiAgICAgICAgPGRpdiBjbGFzcz0naGVhZGVyJz5cclxuICAgICAgICAgICAgeyNpZiBpc0VkaXR0aW5nVG9hc3R9XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz0naGVhZGluZyc+RWRpdHRpbmcgVG9hc3QuLi48L3A+XHJcbiAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPSdoZWFkaW5nJz5Qcm9wb3NlIGEgVG9hc3QuLi48L3A+XHJcbiAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGlucHV0IHR5cGU9J3RleHQnIGRpc2FibGVkPXshaXNMb2dnZWRJbn0gcGxhY2Vob2xkZXI9J05hbWUnIGJpbmQ6dmFsdWU9e3RvYXN0LnRvYXN0ZXJOYW1lfS8+XHJcbiAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyJz5cclxuICAgICAgICA8ZGl2IGNsYXNzPSdzZWxlY3RzdHVmZic+XHJcbiAgICAgICAgICAgIDxzZWxlY3QgZGlzYWJsZWQ9eyFpc0xvZ2dlZElufSBiaW5kOnZhbHVlPXt0b2FzdC50b2FzdGVyUmVsYXRpb25zaGlwfT5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J0ZhdGhlcicgc2VsZWN0ZWQ+RmF0aGVyPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSdNb3RoZXInPk1vdGhlcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nQnJvdGhlcic+QnJvdGhlcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nU2lzdGVyJz5TaXN0ZXI8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J1Nvbic+U29uPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSdEYXVnaHRlcic+RGF1Z2h0ZXI8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J1JlbGF0aXZlJz5SZWxhdGl2ZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nRnJpZW5kJz5GcmllbmQ8L29wdGlvbj5cclxuICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz0nc2VsZWN0c3R1ZmYnPm9mIHRoZTwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9J3NlbGVjdHN0dWZmJz5cclxuICAgICAgICAgICAgPHNlbGVjdCBkaXNhYmxlZD17IWlzTG9nZ2VkSW59IGJpbmQ6dmFsdWU9e3RvYXN0LnRvYXN0ZXJBc3NvY2lhdGlvbn0+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSdHcm9vbScgc2VsZWN0ZWQ+R3Jvb208L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J0JyaWRlJz5CcmlkZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8dGV4dGFyZWEgZGlzYWJsZWQ9eyFpc0xvZ2dlZElufSBiaW5kOnZhbHVlPXt0b2FzdC50b2FzdENvbnRlbnR9IHJvd3M9JzcnIHBsYWNlaG9sZGVyPSdNZXNzYWdlJz48L3RleHRhcmVhPlxyXG4gICAgICAgIDxici8+XHJcbiAgICAgICAgeyNpZiAhaXNMb2dnZWRJbn1cclxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0nZmFjZWJvb2stYnV0dG9uJyBvbjpjbGljaz17bG9nSW59PkxvZyBpbiB3aXRoIEZhY2Vib29rIHRvIFByb3Bvc2U8L2J1dHRvbj5cclxuICAgICAgICB7L2lmfVxyXG4gICAgICAgIHsjaWYgaXNMb2dnZWRJbn1cclxuICAgICAgICAgICAgeyNpZiBpc0VkaXR0aW5nVG9hc3R9XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSdwcm9wb3NlLWJ1dHRvbicgb246Y2xpY2s9e3VwZGF0ZVRvYXN0fT5VcGRhdGUhPC9idXR0b24+XHJcbiAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9J3Byb3Bvc2UtYnV0dG9uJyBvbjpjbGljaz17cHJvcG9zZVRvYXN0fT5Qcm9wb3NlITwvYnV0dG9uPlxyXG4gICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgIHsvaWZ9XHJcbiAgICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5cclxuPHN0eWxlIGxhbmc9J3Njc3MnPlxyXG4gICAgQGltcG9ydCAnLi4vLi4vLi4vc3RhdGljL3RoZW1lLnNjc3MnO1xyXG5cclxuICAgIGRpdiB7XHJcbiAgICAgICAgcGFkZGluZzogMDtcclxuICAgIH1cclxuXHJcbiAgICAuZm9ybSB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGFjY2VudC1jb2xvci1jcmVhbS0yO1xyXG4gICAgICAgIGhlaWdodDogJGZ1bGwtc2l6ZTtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgLmhlYWRlciB7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMjBweCAyMHB4IDAgMDtcclxuICAgICAgICBoZWlnaHQ6IDc1cHg7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGFjY2VudC1jb2xvci1ncmVlbjtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLmhlYWRpbmcge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMzJweDtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIHRvcDogNTAlO1xyXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xyXG4gICAgICAgIHBhZGRpbmctbGVmdDogMTBweDtcclxuICAgICAgICBjb2xvcjogJGFjY2VudC1jb2xvci1jcmVhbTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dCwgdGV4dGFyZWEge1xyXG4gICAgICAgIHdpZHRoOiA4MCU7XHJcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xyXG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6ICRkZWZhdWx0LWxpbmUtaGVpZ2h0O1xyXG4gICAgICAgIGZvbnQtc2l6ZTogJHNtYWxsLWZvbnQtc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dCB7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMjVweDtcclxuICAgIH1cclxuXHJcbiAgICB0ZXh0YXJlYSB7XHJcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjVweDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLnNlbGVjdHN0dWZmIHtcclxuICAgICAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xyXG4gICAgICAgIGZvbnQtc2l6ZTogJHNtYWxsLWZvbnQtc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAuY29udGFpbmVyIHtcclxuICAgICAgICBkaXNwbGF5OiB0YWJsZTtcclxuICAgICAgICB3aWR0aDogJGZ1bGwtc2l6ZTtcclxuICAgICAgICB0YWJsZS1sYXlvdXQ6IGZpeGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdCB7XHJcbiAgICAgICAgd2lkdGg6IDY1cHg7XHJcbiAgICB9XHJcblxyXG4gICAgYnV0dG9uIHtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiA1cHg7XHJcbiAgICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICAgIGNvbG9yOiAkYWNjZW50LWNvbG9yLWNyZWFtO1xyXG4gICAgICAgIHBhZGRpbmc6IDZweCAzMnB4O1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxuICAgIH1cclxuXHJcbiAgICAuZmFjZWJvb2stYnV0dG9uIHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzU3OGU1O1xyXG4gICAgfVxyXG5cclxuICAgIC5wcm9wb3NlLWJ1dHRvbiB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGFjY2VudC1jb2xvci1ncmVlbjtcclxuICAgIH1cclxuXHJcbiAgICAvKiBTbWFydHBob25lcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDMyMHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDQ4MHB4KSB7ICAgXHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGFkcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDc2OHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDEwMjRweCkge1xyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogRGVza3RvcHMgYW5kIExhcHRvcHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW5cclxuICAgIGFuZCAobWluLXdpZHRoIDogMTIyNHB4KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGhvbmUgNCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbyA6IDEuNSksXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG48L3N0eWxlPiIsImV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbmltcG9ydCB7YnViYmxlLCBsaXN0ZW59IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRzQWN0aW9uKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudC4kJC5jYWxsYmFja3MpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG5cbiAgICAgIGV2ZW50cy5mb3JFYWNoKFxuICAgICAgICAgIGV2ZW50ID0+IGxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgICBsaXN0ZW4obm9kZSwgZXZlbnQsIGUgPT4gIGJ1YmJsZShjb21wb25lbnQsIGUpKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0+IGxpc3RlbmVyKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xufSIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7Z2V0RXZlbnRzQWN0aW9ufSBmcm9tICcuL3V0aWxzJztcbiAgICBpbXBvcnQge2N1cnJlbnRfY29tcG9uZW50fSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuXG5cdGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG5cdFxuICAgIGxldCBpc19oZWFkZXIgPSAkJHByb3BzLiQkc2xvdHMgJiYgJCRwcm9wcy4kJHNsb3RzLmhlYWRlciAhPT0gdW5kZWZpbmVkO1xuICAgIGxldCBpc19mb290ZXIgPSAkJHByb3BzLiQkc2xvdHMgJiYgJCRwcm9wcy4kJHNsb3RzLmZvb3RlciAhPT0gdW5kZWZpbmVkO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M6Y2FyZD17MX0gdXNlOmV2ZW50cyB7Li4uJCRyZXN0UHJvcHN9PlxueyNpZiBpc19oZWFkZXJ9XG5cdDxoZWFkZXI+XG4gICAgXHQ8c2xvdCBuYW1lPVwiaGVhZGVyXCI+PC9zbG90PlxuICBcdDwvaGVhZGVyPlxuey9pZn1cblx0PHNsb3Q+PC9zbG90PlxueyNpZiBpc19mb290ZXJ9XG5cdDxmb290ZXI+XG4gICAgXHQ8c2xvdCBuYW1lPVwiZm9vdGVyXCI+PC9zbG90PlxuICBcdDwvZm9vdGVyPlxuey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cblx0aW1wb3J0IHtnZXRFdmVudHNBY3Rpb259IGZyb20gJy4vdXRpbHMnO1xuXHRpbXBvcnQge2N1cnJlbnRfY29tcG9uZW50fSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuXG5cdGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG5cblx0ZXhwb3J0IGxldCBzcmMgPSBudWxsO1xuXHRleHBvcnQgbGV0IHNpemUgPSAxO1xuXHRleHBvcnQgbGV0IGNvbG9yID0gbnVsbDtcblx0ZXhwb3J0IGxldCBmbGlwSCA9IG51bGw7XG5cdGV4cG9ydCBsZXQgZmxpcFYgPSBudWxsO1xuXHRleHBvcnQgbGV0IHJvdGF0ZSA9IDA7XG5cdGV4cG9ydCBsZXQgc3BpbiA9IGZhbHNlO1xuXG5cdGxldCBwYXRoID0gZmFsc2U7XG5cdGxldCB1c2UgPSBmYWxzZTtcblx0bGV0IHVybCA9IGZhbHNlO1xuXG5cdC8vSWNvbiBzb3VyY2Vcblx0JDogaWYoISFzcmMgJiYgc3JjLnRvTG93ZXJDYXNlKCkudHJpbSgpLmVuZHNXaXRoKCcuc3ZnJykpIHtcblx0XHR1cmwgPSBzcmM7XG5cdFx0cGF0aCA9IHVzZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYoISFzcmMgJiYgc3JjLnRvTG93ZXJDYXNlKCkudHJpbSgpLmluY2x1ZGVzKCcuc3ZnIycpKSB7XG5cdFx0dXNlID0gc3JjO1xuXHRcdHVybCA9IHBhdGggPSBmYWxzZTtcblx0fSBlbHNlIGlmKCEhc3JjKSB7XG5cdFx0cGF0aCA9IHNyYztcblx0XHR1cmwgPSB1c2UgPSBmYWxzZTtcblx0fVxuXG5cdC8vIFNQSU4gcHJvcGVydGllc1xuXHQkOiBpbnZlcnNlID0gKHR5cGVvZiBzcGluICE9PSBcImJvb2xlYW5cIiAmJiBzcGluIDwgMCkgPyB0cnVlIDogZmFsc2U7XG5cdCQ6IHNwaW50aW1lID0gTWF0aC5hYnMoc3BpbiA9PT0gdHJ1ZSA/IDIgOiBzcGluKTtcblx0JDogc3BpbkNXID0gKCEhc3BpbiAmJiAhaW52ZXJzZSk7XG5cdCQ6IHNwaW5DQ1cgPSAoISFzcGluICYmIGludmVyc2UpO1xuXG5cdC8vIHNpemVcblx0aWYoTnVtYmVyKHNpemUpKSBzaXplID0gTnVtYmVyKHNpemUpO1xuXHRcblx0Ly8gc3R5bGVzXG5cdGNvbnN0IGdldFN0eWxlcyA9ICgpID0+IHtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBbXTtcblx0XHRjb25zdCBzdHlsZXMgPSBbXTtcblx0XHRpZiAoc2l6ZSAhPT0gbnVsbCkge1xuXHRcdFx0Y29uc3Qgd2lkdGggPSAodHlwZW9mIHNpemUgPT09IFwic3RyaW5nXCIpID8gc2l6ZSA6IGAke3NpemUgKiAxLjV9cmVtYDtcblx0XHRcdHN0eWxlcy5wdXNoKFsnd2lkdGgnLHdpZHRoXSk7XG5cdFx0XHRzdHlsZXMucHVzaChbJ2hlaWdodCcsd2lkdGhdKTtcblx0XHR9XG5cdFx0c3R5bGVzLnB1c2goIFsnZmlsbCcsIChjb2xvciAhPT0gbnVsbCkgPyBjb2xvcjogJ2N1cnJlbnRDb2xvciddICk7XG5cdFx0aWYgKGZsaXBIKSB7XG5cdFx0XHR0cmFuc2Zvcm0ucHVzaChcInNjYWxlWCgtMSlcIik7XG5cdFx0fVxuXHRcdGlmIChmbGlwVikge1xuXHRcdFx0dHJhbnNmb3JtLnB1c2goXCJzY2FsZVkoLTEpXCIpO1xuXHRcdH1cblx0XHRpZiAocm90YXRlICE9IDApIHtcblx0XHRcdHRyYW5zZm9ybS5wdXNoKGByb3RhdGUoJHtyb3RhdGV9ZGVnKWApO1xuXHRcblx0XHR9XG5cdFx0aWYodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcblx0XHRcdHN0eWxlcy5wdXNoKCBbJ3RyYW5zZm9ybScsIHRyYW5zZm9ybS5qb2luKCcgJyldICk7XG5cdFx0XHRzdHlsZXMucHVzaCggWyd0cmFuc2Zvcm0tb3JpZ2luJywgJ2NlbnRlciddICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHlsZXMucmVkdWNlKChjdXIsaXRlbSk9Pntcblx0XHRcdHJldHVybiBgJHtjdXJ9ICR7aXRlbVswXX06JHtpdGVtWzFdfTtgO1xuXHRcdH0sJycpO1xuXHR9XG5cdCQ6IHN0eWxlID0gZ2V0U3R5bGVzKHNpemUsY29sb3IsZmxpcEgsZmxpcFYscm90YXRlKTtcblx0JDogYW5pU3R5bGUgPSAoISFzcGluKSA/IGBhbmltYXRpb24tZHVyYXRpb246ICR7c3BpbnRpbWV9c2AgOiB1bmRlZmluZWQ7XG48L3NjcmlwdD5cblxueyNpZiB1cmx9XG5cdDxzcGFuIHtzdHlsZX0gdXNlOmV2ZW50cyB7Li4uJCRyZXN0UHJvcHN9PlxuXHRcdDxpbWcgc3JjPVwie3VybH1cIiBhbHQ9XCJcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgY2xhc3M6c3BpbkNXIGNsYXNzOnNwaW5DQ1cgc3R5bGU9e2FuaVN0eWxlfSAvPlxuXHQ8L3NwYW4+XG57OmVsc2UgaWYgdXNlfVxuXHQ8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB7c3R5bGV9IHVzZTpldmVudHMgey4uLiQkcmVzdFByb3BzfT5cblx0XHQ8dXNlIHhsaW5rOmhyZWY9e3VzZX0gY2xhc3M6c3BpbkNXIGNsYXNzOnNwaW5DQ1cgc3R5bGU9e2FuaVN0eWxlfT48L3VzZT5cblx0PC9zdmc+XG57OmVsc2V9XG5cdDxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiIHtzdHlsZX0gdXNlOmV2ZW50cyB7Li4uJCRyZXN0UHJvcHN9PlxuXHR7I2lmIHNwaW4gIT09IGZhbHNlfVxuXHRcdDxnIGNsYXNzOnNwaW5DVyBjbGFzczpzcGluQ0NXIHN0eWxlPXthbmlTdHlsZX0+XG5cdFx0XHQ8cGF0aCBkPXtwYXRofT48L3BhdGg+XG5cdFx0PC9nPlxuXHR7OmVsc2V9XG5cdFx0PHBhdGggZD17cGF0aH0+PC9wYXRoPlxuXHR7L2lmfSBcblx0PC9zdmc+XG57L2lmfVxuXG5cbjxzdHlsZT5cblx0QGtleWZyYW1lcyBzcGluIHsgdG8geyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpIH0gfVxuXHRAa2V5ZnJhbWVzIHNwaW4taW52ZXJzZSB7IHRvIHsgdHJhbnNmb3JtOiByb3RhdGUoLTM2MGRlZykgfSB9XG5cblx0c3Zne1xuXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdH1cblxuXHRzcGFue1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRsaW5lLWhlaWdodDoxO1xuXHR9XG5cblx0c3BhbiBpbWd7XG5cdFx0cGFkZGluZzowcHg7XG5cdFx0bWFyZ2luOjBweDtcblx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHR9XG5cblx0LnNwaW5DV3tcblx0XHRhbmltYXRpb246IHNwaW4gbGluZWFyIDJzIGluZmluaXRlO1xuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcblx0fVxuXG5cdC5zcGluQ0NXe1xuXHRcdGFuaW1hdGlvbjogc3Bpbi1pbnZlcnNlIGxpbmVhciAycyBpbmZpbml0ZTtcblx0XHR0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG5cdH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQge2dldEV2ZW50c0FjdGlvbn0gZnJvbSAnLi91dGlscyc7XG4gICAgaW1wb3J0IHtjdXJyZW50X2NvbXBvbmVudH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgICBpbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQuc3ZlbHRlJztcbiAgICBpbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uc3ZlbHRlJztcblxuICAgIGV4cG9ydCBsZXQgb3V0bGluZSA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBwcmltYXJ5ID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IHNlY29uZGFyeSA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBkYXJrID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IGVycm9yID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IHN1Y2Nlc3MgPSBudWxsO1xuICAgIGV4cG9ydCBsZXQgY2xlYXIgPSBudWxsO1xuICAgIGV4cG9ydCBsZXQgbG9hZGluZyA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBpY29uID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IGljb25SaWdodCA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBkcm9wZG93biA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgb3BlbiA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgYXV0b2Nsb3NlID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBzdWJtaXQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG5cbiAgICBjb25zdCBoYXNTbG90ID0gJCRwcm9wcy4kJHNsb3RzICYmICQkcHJvcHMuJCRzbG90cyAhPT0gdW5kZWZpbmVkO1xuXG4gICAgZnVuY3Rpb24gZHJvcGRvd25BY3Rpb24obm9kZSxwYXJhbSkge1xuXG4gICAgICBsZXQgYXV0b2Nsb3NlID0gcGFyYW07XG4gICAgICBsZXQgYnV0dG9uID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3VtbWFyeScpWzBdO1xuXG4gICAgICBjb25zdCBjbGlja091dHNpZGUgPSAoKSA9PiB7XG4gICAgICAgIGlmKCEhbm9kZS5vcGVuKSBub2RlLm9wZW49ZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsaWNrQnV0dG9uID0gKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xpY2tJbkREID0gKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYoYXV0b2Nsb3NlKSBub2RlLm9wZW49ZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSW5ERCk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrQnV0dG9uKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tPdXRzaWRlKTtcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHBhcmFtID0+IGF1dG9jbG9zZSA9IHBhcmFtLFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja091dHNpZGUpO1xuICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSW5ERCk7XG4gICAgICAgICAgYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0J1dHRvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAkOiBjbEljb24gPSAoIChpY29uICE9PSBudWxsIHx8IGljb25SaWdodCAhPT0gbnVsbCkgJiYgaGFzU2xvdCk7XG4gICAgJDogY2xJY29ub25seSA9IChkcm9wZG93bikgPyAoaWNvbiAhPT0gbnVsbCAmJiBkcm9wZG93bj09PXRydWUpIDogKGljb24gIT09IG51bGwgJiYgIWhhc1Nsb3QpO1xuPC9zY3JpcHQ+XG5cblxueyNpZiBkcm9wZG93biA9PT0gZmFsc2V9XG48YnV0dG9uICBcbiAgICBjbGFzczpidXR0b249ezF9XG4gICAgY2xhc3M6b3V0bGluZVxuICAgIGNsYXNzOnByaW1hcnlcbiAgICBjbGFzczpzZWNvbmRhcnlcbiAgICBjbGFzczpkYXJrXG4gICAgY2xhc3M6ZXJyb3JcbiAgICBjbGFzczpzdWNjZXNzXG4gICAgY2xhc3M6Y2xlYXJcbiAgICBjbGFzczpsb2FkaW5nXG4gICAgY2xhc3M6aWNvbj17Y2xJY29ufVxuICAgIGNsYXNzOmljb24tb25seT17Y2xJY29ub25seX1cblxuICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICB1c2U6ZXZlbnRzXG5cbiAgICB0eXBlPXtzdWJtaXQgPyAnc3VibWl0JyA6IG51bGx9XG4+XG57I2lmIGljb259IDxzcGFuIGNsYXNzPVwibGVmdGljb25cIj4gPEljb24gc3JjPXtpY29ufSBzaXplPVwiMjRweFwiLz4gPC9zcGFuPnsvaWZ9XG48c2xvdD48L3Nsb3Q+XG57I2lmIGljb25SaWdodH0gPHNwYW4gY2xhc3M9XCJyaWdodGljb25cIj4gPEljb24gc3JjPXtpY29uUmlnaHR9IHNpemU9XCIyNHB4XCIvPiA8L3NwYW4+ey9pZn1cbjwvYnV0dG9uPlxuezplbHNlfVxuICA8ZGV0YWlscyBjbGFzcz1cImRyb3Bkb3duXCIgYmluZDpvcGVuIHVzZTpkcm9wZG93bkFjdGlvbj17YXV0b2Nsb3NlfT5cbiAgICA8c3VtbWFyeVxuICAgICAgICBjbGFzczpidXR0b249ezF9XG4gICAgICAgIGNsYXNzOm91dGxpbmVcbiAgICAgICAgY2xhc3M6cHJpbWFyeVxuICAgICAgICBjbGFzczpzZWNvbmRhcnlcbiAgICAgICAgY2xhc3M6ZGFya1xuICAgICAgICBjbGFzczplcnJvclxuICAgICAgICBjbGFzczpzdWNjZXNzXG4gICAgICAgIGNsYXNzOmNsZWFyXG4gICAgICAgIGNsYXNzOmxvYWRpbmdcbiAgICAgICAgXG4gICAgICAgIGNsYXNzOmljb249e2NsSWNvbn1cbiAgICAgICAgY2xhc3M6aWNvbi1vbmx5PXtjbEljb25vbmx5fVxuXG4gICAgICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICAgICAgdXNlOmV2ZW50c1xuICAgID5cbiAgICB7I2lmIGljb259IDxzcGFuIGNsYXNzPVwibGVmdGljb25cIj4gPEljb24gc3JjPXtpY29ufSBzaXplPVwiMjRweFwiLz4gPC9zcGFuPnsvaWZ9XG4gICAgICB7KGRyb3Bkb3duICE9PSB0cnVlKSA/IGRyb3Bkb3duIDogJyd9XG4gICAgeyNpZiBpY29uUmlnaHR9IDxzcGFuIGNsYXNzPVwicmlnaHRpY29uXCI+IDxJY29uIHNyYz17aWNvblJpZ2h0fSBzaXplPVwiMjRweFwiLz4gPC9zcGFuPnsvaWZ9XG4gICAgPC9zdW1tYXJ5PlxuICAgIDxDYXJkIHN0eWxlPVwiei1pbmRleDoxXCI+PHNsb3Q+PC9zbG90PjwvQ2FyZD5cbiAgPC9kZXRhaWxzPlxuey9pZn1cblxuXG48c3R5bGU+XG5Aa2V5ZnJhbWVzIGxvYWRpbmcge1xuICAgIDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgIH1cbiAgICAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgfVxufVxuXG4ubG9hZGluZyB7XG4gICAgY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgbWluLWhlaWdodDogLjhyZW07XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4ubG9hZGluZzo6YWZ0ZXIge1xuICAgIGFuaW1hdGlvbjogbG9hZGluZyA1MDBtcyBpbmZpbml0ZSBsaW5lYXI7XG4gICAgYm9yZGVyOiAuMnJlbSBzb2xpZCAjRkZGRkZGO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBib3JkZXItcmlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlci10b3AtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgaGVpZ2h0OiAuOHJlbTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgbWFyZ2luLWxlZnQ6IC0uNHJlbTtcbiAgICBtYXJnaW4tdG9wOiAtLjRyZW07XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIHdpZHRoOiAuOHJlbTtcbiAgICB6LWluZGV4OiAxO1xufVxuXG5cbi5pY29uID4gLmxlZnRpY29ue1xuICBtYXJnaW46IC0xMHB4IDEwcHggLTEwcHggMHB4O1xufVxuXG4uaWNvbiA+IC5yaWdodGljb257XG4gIG1hcmdpbjogLTEwcHggMHB4IC0xMHB4IDEwcHg7XG59XG5cblxuLmljb24tb25seXtcbiAgcGFkZGluZzouNXJlbSAuNjVyZW07XG59XG5cbnN1bW1hcnksIGJ1dHRvbntcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbn1cblxuc3VtbWFyeTo6LXdlYmtpdC1kZXRhaWxzLW1hcmtlciB7XG4gIGRpc3BsYXk6bm9uZTtcbn1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIgfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cbmZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5mdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbn1cbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gICAgY29uc3QgYSA9IDQuMCAvIDExLjA7XG4gICAgY29uc3QgYiA9IDguMCAvIDExLjA7XG4gICAgY29uc3QgYyA9IDkuMCAvIDEwLjA7XG4gICAgY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbiAgICBjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG4gICAgY29uc3QgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgcmV0dXJuIHQgPCBhXG4gICAgICAgID8gNy41NjI1ICogdDJcbiAgICAgICAgOiB0IDwgYlxuICAgICAgICAgICAgPyA5LjA3NSAqIHQyIC0gOS45ICogdCArIDMuNFxuICAgICAgICAgICAgOiB0IDwgY1xuICAgICAgICAgICAgICAgID8gY2EgKiB0MiAtIGNiICogdCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCAqIDIuMCkpXG4gICAgICAgIDogMC41ICogYm91bmNlT3V0KHQgKiAyLjAgLSAxLjApICsgMC41O1xufVxuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5mdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcbn1cbmZ1bmN0aW9uIGNpcmNJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5mdW5jdGlvbiBjaXJjT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGN1YmljSW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gICAgY29uc3QgZiA9IHQgLSAxLjA7XG4gICAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG4gICAgICAgIDogMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG4gICAgICAgICAgICAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAoTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMCk7XG59XG5mdW5jdGlvbiBleHBvSW5PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG4gICAgICAgID8gdFxuICAgICAgICA6IHQgPCAwLjVcbiAgICAgICAgICAgID8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuICAgICAgICAgICAgOiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuZnVuY3Rpb24gZXhwb0luKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBleHBvT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMS4wID8gdCA6IDEuMCAtIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KTtcbn1cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gICAgdCAvPSAwLjU7XG4gICAgaWYgKHQgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQ7XG4gICAgdC0tO1xuICAgIHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICAgIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICAgIHJldHVybiAtdCAqICh0IC0gMi4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gKzguMCAqIE1hdGgucG93KHQsIDQuMClcbiAgICAgICAgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xufVxuZnVuY3Rpb24gcXVpbnRJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5mdW5jdGlvbiBxdWludEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWludE91dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcbiAgICByZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cbmZ1bmN0aW9uIHNpbmVJbih0KSB7XG4gICAgY29uc3QgdiA9IE1hdGguY29zKHQgKiBNYXRoLlBJICogMC41KTtcbiAgICBpZiAoTWF0aC5hYnModikgPCAxZS0xNClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gMSAtIHY7XG59XG5mdW5jdGlvbiBzaW5lT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKHQgKiBNYXRoLlBJKSAvIDIpO1xufVxuXG5leHBvcnQgeyBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBjdWJpY0luLCBjdWJpY0luT3V0LCBjdWJpY091dCwgZWxhc3RpY0luLCBlbGFzdGljSW5PdXQsIGVsYXN0aWNPdXQsIGV4cG9JbiwgZXhwb0luT3V0LCBleHBvT3V0LCBxdWFkSW4sIHF1YWRJbk91dCwgcXVhZE91dCwgcXVhcnRJbiwgcXVhcnRJbk91dCwgcXVhcnRPdXQsIHF1aW50SW4sIHF1aW50SW5PdXQsIHF1aW50T3V0LCBzaW5lSW4sIHNpbmVJbk91dCwgc2luZU91dCB9O1xuIiwiaW1wb3J0IHsgY3ViaWNJbk91dCwgbGluZWFyLCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZyc7XG5pbXBvcnQgeyBpc19mdW5jdGlvbiwgYXNzaWduIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogYW1vdW50fXB4KTtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIgfSkge1xuICAgIGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuICAgIH07XG59XG5mdW5jdGlvbiBmbHkobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHh9cHgsICR7KDEgLSB0KSAqIHl9cHgpO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCk7XG4gICAgY29uc3QgcGFkZGluZ190b3AgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApO1xuICAgIGNvbnN0IHBhZGRpbmdfYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICBjb25zdCBtYXJnaW5fdG9wID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApO1xuICAgIGNvbnN0IG1hcmdpbl9ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkJvdHRvbSk7XG4gICAgY29uc3QgYm9yZGVyX3RvcF93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICAgIGNvbnN0IGJvcmRlcl9ib3R0b21fd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiB0ID0+IGBvdmVyZmxvdzogaGlkZGVuO2AgK1xuICAgICAgICAgICAgYG9wYWNpdHk6ICR7TWF0aC5taW4odCAqIDIwLCAxKSAqIG9wYWNpdHl9O2AgK1xuICAgICAgICAgICAgYGhlaWdodDogJHt0ICogaGVpZ2h0fXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctdG9wOiAke3QgKiBwYWRkaW5nX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLWJvdHRvbTogJHt0ICogcGFkZGluZ19ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLXRvcDogJHt0ICogbWFyZ2luX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tYm90dG9tOiAke3QgKiBtYXJnaW5fYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci10b3Atd2lkdGg6ICR7dCAqIGJvcmRlcl90b3Bfd2lkdGh9cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLWJvdHRvbS13aWR0aDogJHt0ICogYm9yZGVyX2JvdHRvbV93aWR0aH1weDtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNjYWxlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSAoc2QgKiB1KX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfVxuXHRcdGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0pIHtcbiAgICBjb25zdCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYHN0cm9rZS1kYXNoYXJyYXk6ICR7dCAqIGxlbn0gJHt1ICogbGVufWBcbiAgICB9O1xufVxuZnVuY3Rpb24gY3Jvc3NmYWRlKF9hKSB7XG4gICAgdmFyIHsgZmFsbGJhY2sgfSA9IF9hLCBkZWZhdWx0cyA9IF9fcmVzdChfYSwgW1wiZmFsbGJhY2tcIl0pO1xuICAgIGNvbnN0IHRvX3JlY2VpdmUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbSwgbm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMzAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuICAgICAgICBjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgY29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7dCArICgxIC0gdCkgKiBkaH0pO1xuXHRcdFx0YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG4gICAgICAgIHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5zZXQocGFyYW1zLmtleSwge1xuICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3QgfSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2ZhZGUocmVjdCwgbm9kZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG4gICAgICAgICAgICAgICAgaXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLFxuICAgICAgICB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXG4gICAgXTtcbn1cblxuZXhwb3J0IHsgYmx1ciwgY3Jvc3NmYWRlLCBkcmF3LCBmYWRlLCBmbHksIHNjYWxlLCBzbGlkZSB9O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQge2dldEV2ZW50c0FjdGlvbn0gZnJvbSAnLi91dGlscyc7XG4gICAgaW1wb3J0IHtmYWRlfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG4gICAgaW1wb3J0IHtjdXJyZW50X2NvbXBvbmVudH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgICBcbiAgICBleHBvcnQgbGV0IG9wZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG5cbiAgICBsZXQgaXNfaGVhZGVyID0gJCRwcm9wcy4kJHNsb3RzICYmICQkcHJvcHMuJCRzbG90cy5oZWFkZXIgIT09IHVuZGVmaW5lZDtcbiAgICBsZXQgaXNfZm9vdGVyID0gJCRwcm9wcy4kJHNsb3RzICYmICQkcHJvcHMuJCRzbG90cy5mb290ZXIgIT09IHVuZGVmaW5lZDtcbjwvc2NyaXB0PlxuXG5cbnsjaWYgb3Blbn1cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIiB0cmFuc2l0aW9uOmZhZGU9e3sgZHVyYXRpb246IDIwMCB9fT5cbiAgICA8ZGl2IGNsYXNzPVwiYmFja2dyb3VuZFwiIG9uOmNsaWNrPXtlID0+IG9wZW49ZmFsc2V9Lz5cbiAgICA8ZGl2IGNsYXNzOm1vZGFsPXsxfSB1c2U6ZXZlbnRzIHsuLi4kJHJlc3RQcm9wc30+PHNsb3Q+PC9zbG90PjwvZGl2PlxuPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4uY29udGFpbmVye1xuICAgIHBvc2l0aW9uOmZpeGVkO1xuICAgIHRvcDowcHg7XG4gICAgbGVmdDowcHg7XG4gICAgd2lkdGg6MTAwdnc7XG4gICAgaGVpZ2h0OjEwMHZoO1xuICAgIHotaW5kZXg6MTAwMDA7XG59XG5cbi5iYWNrZ3JvdW5ke1xuICAgIHBvc2l0aW9uOmZpeGVkO1xuICAgIHRvcDowcHg7XG4gICAgbGVmdDogMHB4O1xuICAgIHdpZHRoOjEwMHZ3O1xuICAgIGhlaWdodDoxMDB2aDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrO1xuICAgIG9wYWNpdHk6IDAuNTtcbn1cblxuLm1vZGFse1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgbWluLXdpZHRoOjQwMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xufVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQgbGFuZz0ndHlwZXNjcmlwdCc+XHJcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gICAgaW1wb3J0IHsgVG9hc3RNb2RlbCB9IGZyb20gJy4uL19tb2RlbHMvVG9hc3RNb2RlbCc7XHJcbiAgICBpbXBvcnQgU2VjdGlvbkhlYWRlciBmcm9tICcuL1NlY3Rpb25IZWFkZXIuc3ZlbHRlJztcclxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcbiAgICBpbXBvcnQge01vZGFsLCBCdXR0b24sIENhcmR9IGZyb20gJ3N2ZWx0ZS1jaG90YSc7XHJcblxyXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG5sZXQgb3Blbjpib29sZWFuID0gZmFsc2U7XHJcbiAgICBsZXQgdG9hc3RzOiBUb2FzdE1vZGVsW10gPSBbXTtcclxuICAgIFxyXG4gICAgZXhwb3J0IGxldCBpc0xvZ2dlZEluOiBib29sZWFuO1xyXG4gICAgZXhwb3J0IGxldCBmYWNlYm9va1VzZXJJZDogc3RyaW5nO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXV0aG9yKHRvYXN0ZXJGYWNlYm9va0lkOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFjZWJvb2tVc2VySWQgPT09IHRvYXN0ZXJGYWNlYm9va0lkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVkaXRUb2FzdCh0b2FzdCkge1xyXG4gICAgICAgIGRpc3BhdGNoKCdlZGl0VG9hc3QnLCB0b2FzdCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VudChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZmV0Y2goJ2FwaS90b2FzdENvbnRyb2xsZXInLCB7IG1ldGhvZDogJ0dFVCcgfSlcclxuICAgICAgICAudGhlbih0b2FzdHMgPT4gdG9hc3RzLmpzb24oKSlcclxuICAgICAgICAudGhlbih0b2FzdHNEYXRhID0+IHtcclxuICAgICAgICAgICAgdG9hc3RzID0gdG9hc3RzRGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVG9hc3QgKHRvYXN0SWQpIHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS90b2FzdENvbnRyb2xsZXInLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt0b2FzdElkfSksXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcIkNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIn1cclxuICAgICAgICB9KS50aGVuKHJlc3BvbnNlID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSk7XHJcbiAgICB9XHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxzZWN0aW9uIGNsYXNzPSd0b2FzdHMnPlxyXG4gICAgPFNlY3Rpb25IZWFkZXIgdGl0bGU9eydUb2FzdHMnfS8+XHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIHsjZWFjaCB0b2FzdHMgYXMgdG9hc3R9XHJcbiAgICAgICAgICAgIDxwPnt0b2FzdC50b2FzdENvbnRlbnR9PC9wPlxyXG4gICAgICAgICAgICA8cD4gLSB7dG9hc3QudG9hc3Rlck5hbWV9LCB7dG9hc3QudG9hc3RlclJlbGF0aW9uc2hpcH0gb2YgdGhlIHt0b2FzdC50b2FzdGVyQXNzb2NpYXRpb259XHJcbiAgICAgICAgICAgIHsjaWYgaXNMb2dnZWRJbiAmJiBpc0F1dGhvcih0b2FzdC50b2FzdGVyRmFjZWJvb2tJZCl9XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiB7ZWRpdFRvYXN0KHRvYXN0KX19PkVkaXQ8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gb246Y2xpY2s9e2UgPT4gb3Blbj10cnVlfT5EZWxldGU8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxNb2RhbCBiaW5kOm9wZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPENhcmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyB0b2FzdD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbjpjbGljaz17ZGVsZXRlVG9hc3QodG9hc3QudG9hc3RJZCl9PkRlbGV0ZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uOmNsaWNrPXtlID0+IG9wZW49ZmFsc2V9PkNhbmNlbDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQ2FyZD5cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgIDwvcD4gXHJcbiAgICAgICAgey9lYWNofVxyXG4gICAgPC9kaXY+XHJcbjwvc2VjdGlvbj5cclxuXHJcbjxzdHlsZSBsYW5nPSdzY3NzJz4gICAgXHJcbiAgICBAaW1wb3J0ICcuLi8uLi8uLi9zdGF0aWMvdGhlbWUuc2Nzcyc7XHJcblxyXG4gICAgLyogU21hcnRwaG9uZXMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiAzMjBweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiA0ODBweCkgeyAgIFxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBhZHMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiA3NjhweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiAxMDI0cHgpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIERlc2t0b3BzIGFuZCBMYXB0b3BzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuXHJcbiAgICBhbmQgKG1pbi13aWR0aCA6IDEyMjRweCkge1xyXG4gICAgICAgIGJ1dHRvbiB7XHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcclxuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzc1NjM3O1xyXG4gICAgICAgICAgICBjb2xvcjogI2RkZDQ5OTtcclxuICAgICAgICAgICAgcGFkZGluZzogNnB4IDEycHg7XHJcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGl2IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGJhY2tncm91bmQtY29sb3I7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBob25lIDQgLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYVxyXG4gICAgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpLFxyXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvIDogMS41KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuPC9zdHlsZT4iLCI8c2NyaXB0IGxhbmc9J3R5cGVzY3JpcHQnPlxyXG4gICAgaW1wb3J0IFRvYXN0Rm9ybSBmcm9tICcuL1RvYXN0Rm9ybS5zdmVsdGUnO1xyXG4gICAgaW1wb3J0IFRvYXN0c0xpc3QgZnJvbSAnLi9Ub2FzdHNMaXN0LnN2ZWx0ZSc7XHJcbiAgICBpbXBvcnQgeyBUb2FzdE1vZGVsIH0gZnJvbSAnLi4vX21vZGVscy9Ub2FzdE1vZGVsJztcclxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcblxyXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gICAgZXhwb3J0IGxldCBpc0xvZ2dlZEluOiBib29sZWFuO1xyXG4gICAgZXhwb3J0IGxldCBmYWNlYm9va1VzZXJJZDogc3RyaW5nO1xyXG4gICAgbGV0IGlzRWRpdHRpbmdUb2FzdCA9IGZhbHNlO1xyXG5cclxuICAgIGxldCB0b2FzdDogVG9hc3RNb2RlbCA9IHtcclxuICAgICAgICB0b2FzdElkOiBudWxsLFxyXG4gICAgICAgIHRvYXN0ZXJOYW1lOiAnJyxcclxuICAgICAgICB0b2FzdGVyUmVsYXRpb25zaGlwOiAnJyxcclxuICAgICAgICB0b2FzdGVyQXNzb2NpYXRpb246ICcnLFxyXG4gICAgICAgIHRvYXN0Q29udGVudDogJycsXHJcbiAgICAgICAgdG9hc3RlckZhY2Vib29rSWQ6ICcnXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGZvcndhcmQoKSB7XHJcbiAgICAgICAgZGlzcGF0Y2goJ3RvZ2dsZUxvZ0luJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZWRpdFRvYXN0KGV2ZW50KSB7XHJcbiAgICAgICAgdG9hc3QgPSB7Li4uZXZlbnQuZGV0YWlsfTtcclxuICAgICAgICBpc0VkaXR0aW5nVG9hc3QgPSB0cnVlO1xyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxUb2FzdHNMaXN0IGZhY2Vib29rVXNlcklkPXtmYWNlYm9va1VzZXJJZH0gaXNMb2dnZWRJbj17aXNMb2dnZWRJbn0gb246ZWRpdFRvYXN0PXtlZGl0VG9hc3R9Lz5cclxuPFRvYXN0Rm9ybSBpc0VkaXR0aW5nVG9hc3Q9e2lzRWRpdHRpbmdUb2FzdH0gdG9hc3Q9e3RvYXN0fSBmYWNlYm9va1VzZXJJZD17ZmFjZWJvb2tVc2VySWR9IGlzTG9nZ2VkSW49e2lzTG9nZ2VkSW59IG9uOnRvZ2dsZUxvZ0luPXtmb3J3YXJkfS8+XHJcblxyXG48c3R5bGU+XHJcbiAgICAvKiBTbWFydHBob25lcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDMyMHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDQ4MHB4KSB7ICAgXHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGFkcyAocG9ydHJhaXQgYW5kIGxhbmRzY2FwZSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBcclxuICAgIGFuZCAobWluLWRldmljZS13aWR0aCA6IDc2OHB4KSBcclxuICAgIGFuZCAobWF4LWRldmljZS13aWR0aCA6IDEwMjRweCkge1xyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogRGVza3RvcHMgYW5kIExhcHRvcHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW5cclxuICAgIGFuZCAobWluLXdpZHRoIDogMTIyNHB4KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGhvbmUgNCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbyA6IDEuNSksXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG48L3N0eWxlPiIsIjxzY3JpcHQgbGFuZz0ndHlwZXNjcmlwdCc+XHJcbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICBsZXQgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlVG9nZ2xlKCk6IHZvaWQge1xyXG4gICAgICAgIGRpc3BhdGNoKCdoYW5kbGVUb2dnbGUnKTtcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48aW1nIG9uOmNsaWNrPXtoYW5kbGVUb2dnbGV9IHNyYz0nLi8xMzQyMTYtMzIucG5nJyBhbHQ9J2hhbWJ1cmdlciBtZW51Jy8+ICAgICBcclxuXHJcbjxzdHlsZSBsYW5nPSdzY3NzJz5cclxuICAgIEBpbXBvcnQgJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1QcmluY2VzcytTb2ZpYSc7XHJcbiAgICBAaW1wb3J0ICcuLi8uLi8uLi9zdGF0aWMvdGhlbWUuc2Nzcyc7XHJcblxyXG4gICAgLyogU21hcnRwaG9uZXMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiAzMjBweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiA0ODBweCkgeyAgIFxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBhZHMgKHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gXHJcbiAgICBhbmQgKG1pbi1kZXZpY2Utd2lkdGggOiA3NjhweCkgXHJcbiAgICBhbmQgKG1heC1kZXZpY2Utd2lkdGggOiAxMDI0cHgpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIERlc2t0b3BzIGFuZCBMYXB0b3BzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuXHJcbiAgICBhbmQgKG1pbi13aWR0aCA6IDEyMjRweCkge1xyXG4gICAgICAgIGltZyB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICAgICAgcmlnaHQ6IDMwcHg7XHJcbiAgICAgICAgICAgIHRvcDogMTcuNXB4O1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDMwcHg7XHJcbiAgICAgICAgICAgIHdpZHRoOiAzMHB4O1xyXG4gICAgICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbWc6aG92ZXIge1xyXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBob25lIDQgLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYVxyXG4gICAgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpLFxyXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvIDogMS41KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuPC9zdHlsZT4iLCJleHBvcnQgZGVmYXVsdCBbXG4gIFwiYm90dG9tLXJpZ2h0XCIsXG4gIFwiYm90dG9tLWNlbnRlclwiLFxuICBcImJvdHRvbS1sZWZ0XCIsXG4gIFwidG9wLXJpZ2h0XCIsXG4gIFwidG9wLWNlbnRlclwiLFxuICBcInRvcC1sZWZ0XCIsXG4gIFwicmlnaHQtYm90dG9tXCIsXG4gIFwicmlnaHQtY2VudGVyXCIsXG4gIFwicmlnaHQtdG9wXCIsXG4gIFwibGVmdC1ib3R0b21cIixcbiAgXCJsZWZ0LWNlbnRlclwiLFxuICBcImxlZnQtdG9wXCJcbl1cbiIsImNvbnN0IFJJR0hUID0gXCJyaWdodFwiO1xuY29uc3QgTEVGVCA9IFwibGVmdFwiO1xuY29uc3QgVE9QID0gXCJ0b3BcIjtcbmNvbnN0IENFTlRFUiA9IFwiY2VudGVyXCI7XG5jb25zdCBCT1RUT00gPSBcImJvdHRvbVwiO1xuXG4vLyBmb3IgU1NSXG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGNvbnN0IGdldE5leHRQb3NpdGlvbiA9IChwb3NpdGlvbiwgZGltZW5zaW9ucykgPT4ge1xuICBjb25zdCBjbGllbnRIZWlnaHQgPSBNYXRoLm1pbihkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gIGNvbnN0IGNsaWVudFdpZHRoID0gTWF0aC5taW4oZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgT2JqZWN0LmFzc2lnbihkaW1lbnNpb25zLCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSk7XG5cbiAgY29uc3QgW21haW5Qb3NpdGlvbiwgc2Vjb25kYXJ5UG9zaXRpb25dID0gcG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgY29uc3QgbmV4dE1haW5Qb3NpdGlvbiA9IGdldE1haW5Qb3NpdGlvbihtYWluUG9zaXRpb24sIGRpbWVuc2lvbnMpO1xuICBjb25zdCBuZXh0U2Vjb25kYXJ5UG9zaXRpb24gPSBnZXRTZWNvbmRhcnlQb3NpdGlvbihzZWNvbmRhcnlQb3NpdGlvbiwgZGltZW5zaW9ucyk7XG5cbiAgcmV0dXJuIGAke25leHRNYWluUG9zaXRpb259LSR7bmV4dFNlY29uZGFyeVBvc2l0aW9ufWA7XG59XG5cbmNvbnN0IGdldE1haW5Qb3NpdGlvbiA9IChcbiAgcG9zaXRpb24sXG4gIHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGNsaWVudFdpZHRoLFxuICAgIGNsaWVudEhlaWdodCxcbiAgfSxcbikgPT4ge1xuXG4gIGNvbnN0IGZpdHNPblRvcCA9IHRvcCA+IGhlaWdodDtcbiAgY29uc3QgZml0c09uQm90dG9tID0gYm90dG9tICsgaGVpZ2h0IDwgY2xpZW50SGVpZ2h0O1xuXG4gIGNvbnN0IGZpdHNPbkxlZnQgPSBsZWZ0ID4gd2lkdGg7XG4gIGNvbnN0IGZpdHNPblJpZ2h0ID0gcmlnaHQgKyB3aWR0aCA8IGNsaWVudFdpZHRoO1xuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IHtcbiAgICB0b3A6ICgpID0+ICFmaXRzT25Ub3AgJiYgZml0c09uQm90dG9tID8gQk9UVE9NIDogVE9QLFxuICAgIGJvdHRvbTogKCkgPT4gZml0c09uVG9wICYmICFmaXRzT25Cb3R0b20gPyBUT1AgOiBCT1RUT00sXG4gICAgbGVmdDogKCkgPT4gIWZpdHNPbkxlZnQgJiYgZml0c09uUmlnaHQgPyBSSUdIVCA6IExFRlQsXG4gICAgcmlnaHQ6ICgpID0+ICFmaXRzT25SaWdodCAmJiBmaXRzT25MZWZ0ID8gTEVGVCA6IFJJR0hULFxuICB9O1xuXG4gIHJldHVybiBwb3NpdGlvbnNbcG9zaXRpb25dKCk7XG59O1xuXG5jb25zdCBnZXRTZWNvbmRhcnlQb3NpdGlvbiA9IChcbiAgcG9zaXRpb24sXG4gIHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGNsaWVudFdpZHRoLFxuICAgIGNsaWVudEhlaWdodCxcbiAgfVxuKSA9PiB7XG4gIGNvbnN0IHBhcmVudEhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3QgcGFyZW50Q2VudGVyID0gdG9wICsgcGFyZW50SGVpZ2h0IC8gMjtcblxuICBjb25zdCBmaXRzT25Ub3AgPSBib3R0b20gPiBoZWlnaHQ7XG4gIGNvbnN0IGZpdHNPbkJvdHRvbSA9IHRvcCArIGhlaWdodCA8IGNsaWVudEhlaWdodDtcbiAgY29uc3QgZml0c0NlbnRlciA9IChwYXJlbnRDZW50ZXIgLSBoZWlnaHQgLyAyKSA+IDAgJiYgKHBhcmVudENlbnRlciArIGhlaWdodCAvIDIpIDwgY2xpZW50SGVpZ2h0O1xuICBjb25zdCBmaXRzT25MZWZ0ID0gcmlnaHQgPiB3aWR0aDtcbiAgY29uc3QgZml0c09uUmlnaHQgPSBsZWZ0ICsgd2lkdGggPCBjbGllbnRXaWR0aDtcblxuICBjb25zdCBwb3NpdGlvbnMgPSB7XG4gICAgdG9wOiAoKSA9PiAhZml0c09uVG9wICYmIGZpdHNPbkJvdHRvbSA/IEJPVFRPTSA6IFRPUCxcbiAgICBjZW50ZXI6ICgpID0+IGZpdHNDZW50ZXIgPyBDRU5URVIgOiBwb3NpdGlvbnMudG9wKCksXG4gICAgYm90dG9tOiAoKSA9PiAhZml0c09uQm90dG9tICYmIGZpdHNPblRvcCA/IFRPUCA6IEJPVFRPTSxcbiAgICBsZWZ0OiAoKSA9PiAhZml0c09uTGVmdCAmJiBmaXRzT25SaWdodCA/IFJJR0hUIDogTEVGVCxcbiAgICByaWdodDogKCkgPT4gIWZpdHNPblJpZ2h0ICYmIGZpdHNPbkxlZnQgPyBMRUZUIDogUklHSFQsXG4gIH07XG5cbiAgcmV0dXJuIHBvc2l0aW9uc1twb3NpdGlvbl0oKTtcbn07XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQge1xuXHRcdGJlZm9yZVVwZGF0ZSxcblx0XHRvbk1vdW50LFxuXHRcdG9uRGVzdHJveSxcblx0XHR0aWNrLFxuXHRcdGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcixcblx0fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgUE9TSVRJT05TIGZyb20gJy4vcG9zaXRpb25zJztcblx0aW1wb3J0IHsgaXNCcm93c2VyLCBnZXROZXh0UG9zaXRpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG5cdGNvbnN0IERFRkFVTFRfUE9TSVRJT04gPSBQT1NJVElPTlNbMF07XG5cblx0ZXhwb3J0IGxldCBpc09wZW4gPSBmYWxzZTtcblx0ZXhwb3J0IGxldCB1cGRhdGVPblNjcm9sbCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGNsb3NlT25TY3JvbGwgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBwb3NpdGlvbiA9IERFRkFVTFRfUE9TSVRJT047XG5cdGV4cG9ydCBsZXQgY2xvc2VPbkNsaWNrT3V0c2lkZSA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHpJbmRleCA9IDE7XG5cdGV4cG9ydCBsZXQgb25XaW5kb3dLZXlEb3duID0gKCkgPT4ge307XG5cdGV4cG9ydCBsZXQgc3R5bGUgPSAnJztcblxuXHQkOiBjbGFzc05hbWUgPSAkJHJlc3RQcm9wc1snY2xhc3MnXSB8fCAnJztcblxuXHRsZXQgY3VycmVudFBvc2l0aW9uID0gbnVsbDtcblx0bGV0IHBhcmVudDtcblx0bGV0IGNvbnRlbnQ7XG5cdGxldCB0YXJnZXQ7XG5cblx0bGV0IHRvcFN0eWxlID0gMDtcblx0bGV0IGxlZnRTdHlsZSA9IDA7XG5cdGxldCB3aWR0aFN0eWxlID0gMDtcblx0bGV0IGhlaWdodFN0eWxlID0gMDtcblxuXHQkOiBoYXNQYXJlbnQgPSAhcGFyZW50IHx8ICEhcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuXHQkOiBoYXNDb250ZW50ID0gIWNvbnRlbnQgfHwgISFjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuXG5cdCQ6IGlmKCFoYXNQYXJlbnQpIHRocm93IG5ldyBFcnJvcigncGFyZW50IHNsb3QgaXMgcmVxdWlyZWQnKTtcblx0JDogaWYoIWhhc0NvbnRlbnQpIHRocm93IG5ldyBFcnJvcignY29udGVudCBzbG90IGlzIHJlcXVpcmVkJyk7XG5cblx0JDogb3BlbmVkU3RhdGUgPSBpc09wZW4gJiYgaGFzUGFyZW50ICYmIGhhc0NvbnRlbnQ7XG5cblx0ZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuXHRcdGlmICghaXNCcm93c2VyKCkpIHJldHVybjtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUG9zaXRpb24pO1xuXHRcdGlmIChjbG9zZU9uU2Nyb2xsKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgY2xvc2UpO1xuXHRcdGVsc2UgaWYgKHVwZGF0ZU9uU2Nyb2xsKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlUG9zaXRpb24pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuXHRcdGlmICghaXNCcm93c2VyKCkpIHJldHVybjtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUG9zaXRpb24pO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVQb3NpdGlvbik7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGNsb3NlKTtcblx0fVxuXG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdGlmIChvcGVuZWRTdGF0ZSkge1xuXHRcdFx0YWRkTGlzdGVuZXJzKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdGlmICghaXNCcm93c2VyKCkpIHJldHVybjtcblx0XHRyZW1vdmVMaXN0ZW5lcnMoKTtcblx0fSk7XG5cblxuXHRiZWZvcmVVcGRhdGUodXBkYXRlUG9zaXRpb24pO1xuXG5cdGZ1bmN0aW9uIHRvZ2dsZSh2YWx1ZSkge1xuXHRcdGNvbnN0IHByZXZPcGVuID0gaXNPcGVuO1xuXHRcdGNvbnN0IG5leHRPcGVuID0gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlID8gdmFsdWUgOiAhaXNPcGVuO1xuXG5cdFx0aWYgKG5leHRPcGVuICYmIGhhc1BhcmVudCAmJiBoYXNDb250ZW50IHx8ICFuZXh0T3BlbikgaXNPcGVuID0gbmV4dE9wZW47XG5cblx0XHRpZihwcmV2T3BlbiAhPT0gaXNPcGVuKSB7XG5cdFx0XHRkaXNwYXRjaCgndG9nZ2xlJywgaXNPcGVuKTtcblx0XHRcdGlmIChpc09wZW4pIHtcblx0XHRcdFx0YWRkTGlzdGVuZXJzKCk7XG5cdFx0XHRcdGRpc3BhdGNoKCdvcGVuJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNwYXRjaCgnY2xvc2UnKTtcblx0XHRcdFx0cmVtb3ZlTGlzdGVuZXJzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvcGVuKCkge1xuXHRcdGlmICghb3BlbmVkU3RhdGUpIHRvZ2dsZSh0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb3NlKCkge1xuXHRcdGlmIChvcGVuZWRTdGF0ZSkgdG9nZ2xlKGZhbHNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnRhaW5zIChldmVudCkge1xuXHRcdGNvbnN0IHBhdGggPSBldmVudC5wYXRoIHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoLmluY2x1ZGVzKHBhcmVudCkgfHwgcGF0aC5pbmNsdWRlcyhjb250ZW50KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0NsaWNrKGV2ZW50KSB7XG5cdFx0aWYgKCFjbG9zZU9uQ2xpY2tPdXRzaWRlIHx8ICFvcGVuZWRTdGF0ZSB8fCBjb250YWlucyhldmVudCkpIHJldHVybjtcblx0XHRjbG9zZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlV2luZG93S2V5RG93bihldmVudCkge1xuXHRcdGlmICghb25XaW5kb3dLZXlEb3duIHx8ICFvcGVuZWRTdGF0ZSkgcmV0dXJuO1xuXHRcdG9uV2luZG93S2V5RG93bihldmVudCwgeyBpc09wZW46IG9wZW5lZFN0YXRlLCBvcGVuLCBjbG9zZSwgdG9nZ2xlLCBjb250YWlucyB9KTtcblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdGF3YWl0IHRpY2soKTtcblx0XHRpZiAoIW9wZW5lZFN0YXRlKSByZXR1cm47XG5cdFx0aWYgKCFQT1NJVElPTlMuaW5jbHVkZXMocG9zaXRpb24pKSBwb3NpdGlvbiA9IERFRkFVTFRfUE9TSVRJT047XG5cblx0XHRjb25zdCB7XG5cdFx0XHR0b3AsXG5cdFx0XHRib3R0b20sXG5cdFx0XHRsZWZ0LFxuXHRcdFx0cmlnaHQsXG5cdFx0XHR3aWR0aDogcGFyZW50V2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHBhcmVudEhlaWdodCxcblx0XHR9ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdGNvbnN0IGRpbWVuc2lvbnMgPSB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgaGVpZ2h0LCB3aWR0aCB9O1xuXHRcdGNvbnN0IG5leHRQb3NpdGlvbiA9IGdldE5leHRQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyk7XG5cblx0XHRpZiAoY3VycmVudFBvc2l0aW9uICE9PSBuZXh0UG9zaXRpb24pIHtcblx0XHRcdGN1cnJlbnRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbjtcblx0XHR9XG5cblx0XHR0b3BTdHlsZSA9IHRvcDtcblx0XHRsZWZ0U3R5bGUgPSBsZWZ0O1xuXHRcdHdpZHRoU3R5bGUgPSBwYXJlbnRXaWR0aDtcblx0XHRoZWlnaHRTdHlsZSA9IHBhcmVudEhlaWdodDtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6d2luZG93XG5cdG9uOm1vdXNlZG93bj17aGFuZGxlV2luZG93Q2xpY2t9XG5cdG9uOmtleWRvd249e2hhbmRsZVdpbmRvd0tleURvd259IC8+XG5cbjxkaXYgYmluZDp0aGlzPXt0YXJnZXR9IGNsYXNzPXtgb3ZlcmxheSAke2NsYXNzTmFtZX1gfSBzdHlsZT17YHotaW5kZXg6JHt6SW5kZXh9OyAke3N0eWxlfWB9PlxuXHQ8ZGl2IGJpbmQ6dGhpcz17cGFyZW50fT5cblx0XHQ8c2xvdCBuYW1lPVwicGFyZW50XCIge3RvZ2dsZX0gaXNPcGVuPXtvcGVuZWRTdGF0ZX0ge29wZW59IHtjbG9zZX0gLz5cblx0PC9kaXY+XG5cdDxkaXZcblx0XHRjbGFzcz1cImNvbnRlbnQtd3JhcHBlclwiXG5cdFx0c3R5bGU9e2B0b3A6ICR7dG9wU3R5bGV9cHg7IGxlZnQ6ICR7bGVmdFN0eWxlfXB4OyB3aWR0aDogJHt3aWR0aFN0eWxlfXB4OyBoZWlnaHQ6ICR7aGVpZ2h0U3R5bGV9cHg7IHotaW5kZXg6JHt6SW5kZXh9O2B9XG5cdD5cblx0XHR7I2lmIG9wZW5lZFN0YXRlfVxuXHRcdFx0PGRpdiBjbGFzcz17YGNvbnRlbnQgJHtjdXJyZW50UG9zaXRpb24gfHwgJyd9YH0gYmluZDp0aGlzPXtjb250ZW50fT5cblx0XHRcdFx0XHQ8c2xvdCBuYW1lPVwiY29udGVudFwiIHt0b2dnbGV9IGlzT3Blbj17b3BlbmVkU3RhdGV9IHtvcGVufSB7Y2xvc2V9IC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5vdmVybGF5IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAuY29udGVudC13cmFwcGVyIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgd2lkdGg6IG1heC1jb250ZW50O1xuICB9XG5cbiAgLmNvbnRlbnQtd3JhcHBlciA+ICoge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIH1cblxuICAuY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIG1pbi13aWR0aDogMTAwJTtcbiAgfVxuXG4gIC50b3AtbGVmdCxcbiAgLnRvcC1jZW50ZXIsXG4gIC50b3AtcmlnaHQge1xuICAgIGJvdHRvbTogMTAwJTtcbiAgfVxuXG4gIC5ib3R0b20tbGVmdCxcbiAgLmJvdHRvbS1jZW50ZXIsXG4gIC5ib3R0b20tcmlnaHQge1xuICAgIHRvcDogMTAwJTtcbiAgfVxuXG4gIC50b3AtbGVmdCxcbiAgLmJvdHRvbS1sZWZ0IHtcbiAgICByaWdodDogMDtcbiAgfVxuXG4gIC50b3AtY2VudGVyLFxuICAuYm90dG9tLWNlbnRlciB7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgfVxuXG4gIC50b3AtcmlnaHQsXG4gIC5ib3R0b20tcmlnaHQge1xuICAgIGxlZnQ6IDA7XG4gIH1cblxuICAubGVmdC10b3AsXG4gIC5sZWZ0LWJvdHRvbSxcbiAgLmxlZnQtY2VudGVyIHtcbiAgICByaWdodDogMTAwJTtcbiAgfVxuXG4gIC5yaWdodC10b3AsXG4gIC5yaWdodC1ib3R0b20sXG4gIC5yaWdodC1jZW50ZXIge1xuICAgIGxlZnQ6IDEwMCU7XG4gIH1cblxuICAubGVmdC1jZW50ZXIsXG4gIC5yaWdodC1jZW50ZXIge1xuICAgIHRvcDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgfVxuXG4gIC5sZWZ0LXRvcCxcbiAgLnJpZ2h0LXRvcCB7XG4gICAgYm90dG9tOiAwO1xuICB9XG5cbiAgLmxlZnQtYm90dG9tLFxuICAucmlnaHQtYm90dG9tIHtcbiAgICB0b3A6IDA7XG4gIH1cbjwvc3R5bGU+XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gICQoc2VsZWN0b3IpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfSxcbiAgZXh0ZW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbiguLi5hcmdzKTtcbiAgfSxcbiAgY3VtdWxhdGl2ZU9mZnNldChlbGVtZW50KSB7XG4gICAgbGV0IHRvcCA9IDA7XG4gICAgbGV0IGxlZnQgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgdG9wICs9IGVsZW1lbnQub2Zmc2V0VG9wIHx8IDA7XG4gICAgICBsZWZ0ICs9IGVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdFxuICAgIH07XG4gIH0sXG4gIGRpcmVjdFNjcm9sbChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keTtcbiAgfSxcbiAgc2Nyb2xsVG9wKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgbGV0IGluU2V0dGVyID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5kaXJlY3RTY3JvbGwoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBpblNldHRlciA/IChlbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlKSA6IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5TZXR0ZXJcbiAgICAgICAgPyAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gdmFsdWUpXG4gICAgICAgIDogd2luZG93LnBhZ2VZT2Zmc2V0IHx8XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fFxuICAgICAgICAgICAgMDtcbiAgICB9XG4gIH0sXG4gIHNjcm9sbExlZnQoZWxlbWVudCwgdmFsdWUpIHtcbiAgICBsZXQgaW5TZXR0ZXIgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmRpcmVjdFNjcm9sbChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGluU2V0dGVyID8gKGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlKSA6IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluU2V0dGVyXG4gICAgICAgID8gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gdmFsdWUpXG4gICAgICAgIDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8XG4gICAgICAgICAgICAwO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCAqIGFzIGVhc2luZ3MgZnJvbSBcInN2ZWx0ZS9lYXNpbmdcIjtcbmltcG9ydCB7IG5vb3AsIGxvb3AsIG5vdyB9IGZyb20gXCJzdmVsdGUvaW50ZXJuYWxcIjtcbmltcG9ydCBfIGZyb20gXCIuL2hlbHBlclwiO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZHVyYXRpb246IDUwMCxcbiAgZGVsYXk6IDAsXG4gIG9mZnNldDogMCxcbiAgZWFzaW5nOiBcImN1YmljSW5PdXRcIixcbiAgb25TdGFydDogbm9vcCxcbiAgb25Eb25lOiBub29wLFxuICBvbkFib3J0aW5nOiBub29wLFxuICBzY3JvbGxYOiBmYWxzZSxcbiAgc2Nyb2xsWTogdHJ1ZVxufTtcblxuY29uc3QgX3Njcm9sbFRvID0gb3B0aW9ucyA9PiB7XG4gIGxldCB7XG4gICAgb2Zmc2V0LFxuICAgIGR1cmF0aW9uLFxuICAgIGRlbGF5LFxuICAgIGVhc2luZyxcbiAgICB4PTAsXG4gICAgeT0wLFxuICAgIHNjcm9sbFgsXG4gICAgc2Nyb2xsWSxcbiAgICBvblN0YXJ0LFxuICAgIG9uRG9uZSxcbiAgICBjb250YWluZXIsXG4gICAgb25BYm9ydGluZyxcbiAgICBlbGVtZW50XG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICh0eXBlb2YgZWFzaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWFzaW5nID0gZWFzaW5nc1tlYXNpbmddO1xuICB9XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQoKTtcbiAgfVxuXG4gIHZhciBjdW11bGF0aXZlT2Zmc2V0Q29udGFpbmVyID0gXy5jdW11bGF0aXZlT2Zmc2V0KGNvbnRhaW5lcik7XG4gIHZhciBjdW11bGF0aXZlT2Zmc2V0VGFyZ2V0ID0gZWxlbWVudFxuICAgID8gXy5jdW11bGF0aXZlT2Zmc2V0KGVsZW1lbnQpXG4gICAgOiB7IHRvcDogeSwgbGVmdDogeCB9O1xuXG4gIHZhciBpbml0aWFsWCA9IF8uc2Nyb2xsTGVmdChjb250YWluZXIpO1xuICB2YXIgaW5pdGlhbFkgPSBfLnNjcm9sbFRvcChjb250YWluZXIpO1xuXG4gIHZhciB0YXJnZXRYID1cbiAgICBjdW11bGF0aXZlT2Zmc2V0VGFyZ2V0LmxlZnQgLSBjdW11bGF0aXZlT2Zmc2V0Q29udGFpbmVyLmxlZnQgKyBvZmZzZXQ7XG4gIHZhciB0YXJnZXRZID1cbiAgICBjdW11bGF0aXZlT2Zmc2V0VGFyZ2V0LnRvcCAtIGN1bXVsYXRpdmVPZmZzZXRDb250YWluZXIudG9wICsgb2Zmc2V0O1xuXG4gIHZhciBkaWZmWCA9IHRhcmdldFggLSBpbml0aWFsWDtcblx0dmFyIGRpZmZZID0gdGFyZ2V0WSAtIGluaXRpYWxZO1xuXG4gIGxldCBzY3JvbGxpbmcgPSB0cnVlO1xuICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICBsZXQgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gIGxldCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblxuICBmdW5jdGlvbiBzY3JvbGxUb1RvcExlZnQoZWxlbWVudCwgdG9wLCBsZWZ0KSB7XG4gICAgaWYgKHNjcm9sbFgpIF8uc2Nyb2xsTGVmdChlbGVtZW50LCBsZWZ0KTtcbiAgICBpZiAoc2Nyb2xsWSkgXy5zY3JvbGxUb3AoZWxlbWVudCwgdG9wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGRlbGF5U3RhcnQpIHtcbiAgICBpZiAoIWRlbGF5U3RhcnQpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgb25TdGFydChlbGVtZW50LCB7eCwgeX0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2socHJvZ3Jlc3MpIHtcbiAgICBzY3JvbGxUb1RvcExlZnQoXG4gICAgICBjb250YWluZXIsXG4gICAgICBpbml0aWFsWSArIGRpZmZZICogcHJvZ3Jlc3MsXG4gICAgICBpbml0aWFsWCArIGRpZmZYICogcHJvZ3Jlc3NcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzY3JvbGxpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGxvb3Aobm93ID0+IHtcbiAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgIHN0YXJ0KGZhbHNlKVxuICAgIH1cblxuICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgdGljaygxKTtcbiAgICAgIHN0b3AoKTtcbiAgICAgIG9uRG9uZShlbGVtZW50LCB7eCwgeX0pO1xuICAgIH1cblxuICAgIGlmICghc2Nyb2xsaW5nKSB7XG4gICAgICBvbkFib3J0aW5nKGVsZW1lbnQsIHt4LCB5fSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgdGljayh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgc3RhcnQoZGVsYXkpO1xuXG4gIHRpY2soMCk7XG5cbiAgcmV0dXJuIHN0b3A7XG59O1xuXG5jb25zdCBwcm9jZWVkT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuXHRsZXQgb3B0cyA9IF8uZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gIG9wdHMuY29udGFpbmVyID0gXy4kKG9wdHMuY29udGFpbmVyKTtcbiAgb3B0cy5lbGVtZW50ID0gXy4kKG9wdHMuZWxlbWVudCk7XG4gIHJldHVybiBvcHRzO1xufTtcblxuY29uc3Qgc2Nyb2xsQ29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyRWxlbWVudCA9PiB7XG4gIGlmIChcbiAgICBjb250YWluZXJFbGVtZW50ICYmXG4gICAgY29udGFpbmVyRWxlbWVudCAhPT0gZG9jdW1lbnQgJiZcbiAgICBjb250YWluZXJFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5XG4gICkge1xuICAgIHJldHVybiBjb250YWluZXJFbGVtZW50LnNjcm9sbEhlaWdodCAtIGNvbnRhaW5lckVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxldCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBsZXQgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIGJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgYm9keS5vZmZzZXRIZWlnaHQsXG4gICAgICBodG1sLmNsaWVudEhlaWdodCxcbiAgICAgIGh0bWwuc2Nyb2xsSGVpZ2h0LFxuICAgICAgaHRtbC5vZmZzZXRIZWlnaHRcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0R2xvYmFsT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuXHRfLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2Nyb2xsVG8gPSBvcHRpb25zID0+IHtcbiAgcmV0dXJuIF9zY3JvbGxUbyhwcm9jZWVkT3B0aW9ucyhvcHRpb25zKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSBvcHRpb25zID0+IHtcbiAgb3B0aW9ucyA9IHByb2NlZWRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBfc2Nyb2xsVG8oXG4gICAgXy5leHRlbmQob3B0aW9ucywge1xuICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgIHk6IHNjcm9sbENvbnRhaW5lckhlaWdodChvcHRpb25zLmNvbnRhaW5lcilcbiAgICB9KVxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHNjcm9sbFRvVG9wID0gb3B0aW9ucyA9PiB7XG4gIG9wdGlvbnMgPSBwcm9jZWVkT3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gX3Njcm9sbFRvKFxuICAgIF8uZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICB5OiAwXG4gICAgfSlcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYWtlU2Nyb2xsVG9BY3Rpb24gPSBzY3JvbGxUb0Z1bmMgPT4ge1xuICByZXR1cm4gKG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IG9wdGlvbnM7XG4gICAgY29uc3QgaGFuZGxlID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzY3JvbGxUb0Z1bmMoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8geyBlbGVtZW50OiBjdXJyZW50IH0gOiBjdXJyZW50XG4gICAgICApO1xuICAgIH07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGN1cnJlbnQgPSBvcHRpb25zO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZSk7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNjcm9sbHRvID0gbWFrZVNjcm9sbFRvQWN0aW9uKHNjcm9sbFRvKTtcbmV4cG9ydCBjb25zdCBzY3JvbGx0b3RvcCA9IG1ha2VTY3JvbGxUb0FjdGlvbihzY3JvbGxUb1RvcCk7XG5leHBvcnQgY29uc3Qgc2Nyb2xsdG9ib3R0b20gPSBtYWtlU2Nyb2xsVG9BY3Rpb24oc2Nyb2xsVG9Cb3R0b20pO1xuIiwiPHNjcmlwdCBsYW5nPSd0eXBlc2NyaXB0Jz5cclxuICAgIGltcG9ydCBPdmVybGF5IGZyb20gJ3N2ZWx0ZS1vdmVybGF5JztcclxuICAgIGltcG9ydCAqIGFzIGFuaW1hdGVTY3JvbGwgZnJvbSAnc3ZlbHRlLXNjcm9sbHRvJztcclxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcblxyXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIGV4cG9ydCBsZXQgaXNMb2dnZWRJbjogYm9vbGVhbjtcclxuICAgIGV4cG9ydCBsZXQgaXNPcGVuOiBib29sZWFuO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvZ091dCgpIHtcclxuICAgICAgICBkaXNwYXRjaChcInRvZ2dsZUxvZ0luXCIpO1xyXG4gICAgICAgIGhhbmRsZVNlY3Rpb25TZWxlY3Rpb24oJ2hvbWUnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVTZWN0aW9uU2VsZWN0aW9uKHNlY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBpc09wZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoc2VjdGlvbiA9PSAnaG9tZScpIHtcclxuICAgICAgICAgICAgYW5pbWF0ZVNjcm9sbC5zY3JvbGxUb1RvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuaW1hdGVTY3JvbGwuc2Nyb2xsVG8oe2VsZW1lbnQ6ICcuJyArIHNlY3Rpb24sIG9mZnNldDogLTYyLjV9KTtcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG57I2lmIGlzT3Blbn1cclxuICAgIDxkaXYgY2xhc3M9J21lbnUnPlxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpIGNsYXNzPSdob21lJyBvbjpjbGljaz17KCkgPT4ge2hhbmRsZVNlY3Rpb25TZWxlY3Rpb24oJ2hvbWUnKX19PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nYXJyb3cnPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPScuL2ljb25zOC1jb2xsYXBzZS1hcnJvdy01MC5wbmcnIGFsdD0nYXJyb3cnLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nc2VjdGlvbic+SG9tZTwvZGl2PlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGkgb246Y2xpY2s9eygpID0+IHtoYW5kbGVTZWN0aW9uU2VsZWN0aW9uKCdzdG9yeScpfX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdhcnJvdyc+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9Jy4vaWNvbnM4LWNvbGxhcHNlLWFycm93LTUwLnBuZycgYWx0PSdhcnJvdycvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdzZWN0aW9uJz5PdXIgU3Rvcnk8L2Rpdj5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpIG9uOmNsaWNrPXsoKSA9PiB7aGFuZGxlU2VjdGlvblNlbGVjdGlvbignY2xhbicpfX0+ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nYXJyb3cnPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPScuL2ljb25zOC1jb2xsYXBzZS1hcnJvdy01MC5wbmcnIGFsdD0nYXJyb3cnLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nc2VjdGlvbic+T3VyIENsYW48L2Rpdj5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpIG9uOmNsaWNrPXsoKSA9PiB7aGFuZGxlU2VjdGlvblNlbGVjdGlvbigndG9hc3RzJyl9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Fycm93Jz5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0nLi9pY29uczgtY29sbGFwc2UtYXJyb3ctNTAucG5nJyBhbHQ9J2Fycm93Jy8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3NlY3Rpb24nPlRvYXN0czwvZGl2PlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGkgb246Y2xpY2s9eygpID0+IHtoYW5kbGVTZWN0aW9uU2VsZWN0aW9uKCdwcm9wb3NlJyl9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Fycm93Jz5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0nLi9pY29uczgtY29sbGFwc2UtYXJyb3ctNTAucG5nJyBhbHQ9J2Fycm93Jy8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3NlY3Rpb24nPlByb3Bvc2UgYSBUb2FzdDwvZGl2PlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGkgb246Y2xpY2s9eygpID0+IHtoYW5kbGVTZWN0aW9uU2VsZWN0aW9uKCdibGVuZGVkJyl9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Fycm93Jz5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0nLi9pY29uczgtY29sbGFwc2UtYXJyb3ctNTAucG5nJyBhbHQ9J2Fycm93Jy8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3NlY3Rpb24nPkJsZW5kZWQgRmFtaWx5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgeyNpZiBpc0xvZ2dlZElufVxyXG4gICAgICAgICAgICA8bGkgb246Y2xpY2s9e2xvZ091dH0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdhcnJvdyc+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9Jy4vaWNvbnM4LWNvbGxhcHNlLWFycm93LTUwLnBuZycgYWx0PSdhcnJvdycvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdzZWN0aW9uJz5Mb2cgb3V0PC9kaXY+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgey9pZn1cclxuICAgICAgICA8L3VsPlxyXG4gICAgPC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c3R5bGUgbGFuZz0nc2Nzcyc+XHJcbiAgICBAaW1wb3J0ICdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9UHJpbmNlc3MrU29maWEnO1xyXG4gICAgQGltcG9ydCAnLi4vLi4vLi4vc3RhdGljL3RoZW1lLnNjc3MnO1xyXG5cclxuICAgIC8qIFNtYXJ0cGhvbmVzIChwb3J0cmFpdCBhbmQgbGFuZHNjYXBlKSAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIFxyXG4gICAgYW5kIChtaW4tZGV2aWNlLXdpZHRoIDogMzIwcHgpIFxyXG4gICAgYW5kIChtYXgtZGV2aWNlLXdpZHRoIDogNDgwcHgpIHsgICBcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIGlQYWRzIChwb3J0cmFpdCBhbmQgbGFuZHNjYXBlKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIFxyXG4gICAgYW5kIChtaW4tZGV2aWNlLXdpZHRoIDogNzY4cHgpIFxyXG4gICAgYW5kIChtYXgtZGV2aWNlLXdpZHRoIDogMTAyNHB4KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBEZXNrdG9wcyBhbmQgTGFwdG9wcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlblxyXG4gICAgYW5kIChtaW4td2lkdGggOiAxMjI0cHgpIHtcclxuICAgICAgICAubWVudSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgdG9wOiA2NXB4O1xyXG4gICAgICAgICAgICByaWdodDogMDtcclxuICAgICAgICAgICAgd2lkdGg6IDI1JTtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGFjY2VudC1jb2xvci1ncmVlbjtcclxuICAgICAgICAgICAgY29sb3I6ICRhY2NlbnQtY29sb3ItY3JlYW07XHJcbiAgICAgICAgICAgIHotaW5kZXg6IDk5OTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVsIHtcclxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDM1cHg7XHJcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGk6aG92ZXIge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMkU0QTJFO1xyXG4gICAgICAgICAgICBkaXYge1xyXG4gICAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpIGRpdiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDE1MHB4O1xyXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMTUwcHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAuYXJyb3cge1xyXG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcclxuICAgICAgICAgICAgd2lkdGg6Ni4yNSU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbWcge1xyXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogNTBweDtcclxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLnNlY3Rpb24ge1xyXG4gICAgICAgICAgICB3aWR0aDogOTMuNzUlO1xyXG4gICAgICAgICAgICBmbG9hdDogcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgLyogaVBob25lIDQgLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYVxyXG4gICAgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpLFxyXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvIDogMS41KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuPC9zdHlsZT4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHN0ciA9PiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIHggPT4gYCUke3guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1gKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b2tlbiA9ICclW2EtZjAtOV17Mn0nO1xudmFyIHNpbmdsZU1hdGNoZXIgPSBuZXcgUmVnRXhwKHRva2VuLCAnZ2knKTtcbnZhciBtdWx0aU1hdGNoZXIgPSBuZXcgUmVnRXhwKCcoJyArIHRva2VuICsgJykrJywgJ2dpJyk7XG5cbmZ1bmN0aW9uIGRlY29kZUNvbXBvbmVudHMoY29tcG9uZW50cywgc3BsaXQpIHtcblx0dHJ5IHtcblx0XHQvLyBUcnkgdG8gZGVjb2RlIHRoZSBlbnRpcmUgc3RyaW5nIGZpcnN0XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjb21wb25lbnRzLmpvaW4oJycpKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gRG8gbm90aGluZ1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHRzcGxpdCA9IHNwbGl0IHx8IDE7XG5cblx0Ly8gU3BsaXQgdGhlIGFycmF5IGluIDIgcGFydHNcblx0dmFyIGxlZnQgPSBjb21wb25lbnRzLnNsaWNlKDAsIHNwbGl0KTtcblx0dmFyIHJpZ2h0ID0gY29tcG9uZW50cy5zbGljZShzcGxpdCk7XG5cblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgZGVjb2RlQ29tcG9uZW50cyhsZWZ0KSwgZGVjb2RlQ29tcG9uZW50cyhyaWdodCkpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0dmFyIHRva2VucyA9IGlucHV0Lm1hdGNoKHNpbmdsZU1hdGNoZXIpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlucHV0ID0gZGVjb2RlQ29tcG9uZW50cyh0b2tlbnMsIGkpLmpvaW4oJycpO1xuXG5cdFx0XHR0b2tlbnMgPSBpbnB1dC5tYXRjaChzaW5nbGVNYXRjaGVyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3VzdG9tRGVjb2RlVVJJQ29tcG9uZW50KGlucHV0KSB7XG5cdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHRoZSByZXBsYWNlbWVudHMgYW5kIHByZWZpbGwgdGhlIG1hcCB3aXRoIHRoZSBgQk9NYFxuXHR2YXIgcmVwbGFjZU1hcCA9IHtcblx0XHQnJUZFJUZGJzogJ1xcdUZGRkRcXHVGRkZEJyxcblx0XHQnJUZGJUZFJzogJ1xcdUZGRkRcXHVGRkZEJ1xuXHR9O1xuXG5cdHZhciBtYXRjaCA9IG11bHRpTWF0Y2hlci5leGVjKGlucHV0KTtcblx0d2hpbGUgKG1hdGNoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIERlY29kZSBhcyBiaWcgY2h1bmtzIGFzIHBvc3NpYmxlXG5cdFx0XHRyZXBsYWNlTWFwW21hdGNoWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFswXSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gZGVjb2RlKG1hdGNoWzBdKTtcblxuXHRcdFx0aWYgKHJlc3VsdCAhPT0gbWF0Y2hbMF0pIHtcblx0XHRcdFx0cmVwbGFjZU1hcFttYXRjaFswXV0gPSByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWF0Y2ggPSBtdWx0aU1hdGNoZXIuZXhlYyhpbnB1dCk7XG5cdH1cblxuXHQvLyBBZGQgYCVDMmAgYXQgdGhlIGVuZCBvZiB0aGUgbWFwIHRvIG1ha2Ugc3VyZSBpdCBkb2VzIG5vdCByZXBsYWNlIHRoZSBjb21iaW5hdG9yIGJlZm9yZSBldmVyeXRoaW5nIGVsc2Vcblx0cmVwbGFjZU1hcFsnJUMyJ10gPSAnXFx1RkZGRCc7XG5cblx0dmFyIGVudHJpZXMgPSBPYmplY3Qua2V5cyhyZXBsYWNlTWFwKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHQvLyBSZXBsYWNlIGFsbCBkZWNvZGVkIGNvbXBvbmVudHNcblx0XHR2YXIga2V5ID0gZW50cmllc1tpXTtcblx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UobmV3IFJlZ0V4cChrZXksICdnJyksIHJlcGxhY2VNYXBba2V5XSk7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVuY29kZWRVUkkpIHtcblx0aWYgKHR5cGVvZiBlbmNvZGVkVVJJICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBlbmNvZGVkVVJJYCB0byBiZSBvZiB0eXBlIGBzdHJpbmdgLCBnb3QgYCcgKyB0eXBlb2YgZW5jb2RlZFVSSSArICdgJyk7XG5cdH1cblxuXHR0cnkge1xuXHRcdGVuY29kZWRVUkkgPSBlbmNvZGVkVVJJLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuXG5cdFx0Ly8gVHJ5IHRoZSBidWlsdCBpbiBkZWNvZGVyIGZpcnN0XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkVVJJKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gRmFsbGJhY2sgdG8gYSBtb3JlIGFkdmFuY2VkIGRlY29kZXJcblx0XHRyZXR1cm4gY3VzdG9tRGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRVUkkpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChzdHJpbmcsIHNlcGFyYXRvcikgPT4ge1xuXHRpZiAoISh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VwYXJhdG9yID09PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgYXJndW1lbnRzIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2AnKTtcblx0fVxuXG5cdGlmIChzZXBhcmF0b3IgPT09ICcnKSB7XG5cdFx0cmV0dXJuIFtzdHJpbmddO1xuXHR9XG5cblx0Y29uc3Qgc2VwYXJhdG9ySW5kZXggPSBzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuXG5cdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gW3N0cmluZ107XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdHN0cmluZy5zbGljZSgwLCBzZXBhcmF0b3JJbmRleCksXG5cdFx0c3RyaW5nLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aClcblx0XTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xuY29uc3QgZGVjb2RlQ29tcG9uZW50ID0gcmVxdWlyZSgnZGVjb2RlLXVyaS1jb21wb25lbnQnKTtcbmNvbnN0IHNwbGl0T25GaXJzdCA9IHJlcXVpcmUoJ3NwbGl0LW9uLWZpcnN0Jyk7XG5cbmNvbnN0IGlzTnVsbE9yVW5kZWZpbmVkID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpIHtcblx0c3dpdGNoIChvcHRpb25zLmFycmF5Rm9ybWF0KSB7XG5cdFx0Y2FzZSAnaW5kZXgnOlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwTnVsbCAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwRW1wdHlTdHJpbmcgJiYgdmFsdWUgPT09ICcnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJ1snLCBpbmRleCwgJ10nXS5qb2luKCcnKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdC4uLnJlc3VsdCxcblx0XHRcdFx0XHRbZW5jb2RlKGtleSwgb3B0aW9ucyksICdbJywgZW5jb2RlKGluZGV4LCBvcHRpb25zKSwgJ109JywgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJylcblx0XHRcdFx0XTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdHJldHVybiBrZXkgPT4gKHJlc3VsdCwgdmFsdWUpID0+IHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwTnVsbCAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwRW1wdHlTdHJpbmcgJiYgdmFsdWUgPT09ICcnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJ1tdJ10uam9pbignJyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJ1tdPScsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4oJycpXTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdjb21tYSc6XG5cdFx0Y2FzZSAnc2VwYXJhdG9yJzpcblx0XHRcdHJldHVybiBrZXkgPT4gKHJlc3VsdCwgdmFsdWUpID0+IHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtbZW5jb2RlKGtleSwgb3B0aW9ucyksICc9JywgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtbcmVzdWx0LCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpXTtcblx0XHRcdH07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgZW5jb2RlKGtleSwgb3B0aW9ucyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJz0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKV07XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpIHtcblx0bGV0IHJlc3VsdDtcblxuXHRzd2l0Y2ggKG9wdGlvbnMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdHJlc3VsdCA9IC9cXFsoXFxkKilcXF0kLy5leGVjKGtleSk7XG5cblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW1xcZCpcXF0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldW3Jlc3VsdFsxXV0gPSB2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdHJldHVybiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpID0+IHtcblx0XHRcdFx0cmVzdWx0ID0gLyhcXFtcXF0pJC8uZXhlYyhrZXkpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFt2YWx1ZV07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnY29tbWEnOlxuXHRcdGNhc2UgJ3NlcGFyYXRvcic6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGlzQXJyYXkgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnNwbGl0KCcnKS5pbmRleE9mKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpID4gLTE7XG5cdFx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gaXNBcnJheSA/IHZhbHVlLnNwbGl0KG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpLm1hcChpdGVtID0+IGRlY29kZShpdGVtLCBvcHRpb25zKSkgOiB2YWx1ZSA9PT0gbnVsbCA/IHZhbHVlIDogZGVjb2RlKHZhbHVlLCBvcHRpb25zKTtcblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IG5ld1ZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3IodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUubGVuZ3RoICE9PSAxKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXlGb3JtYXRTZXBhcmF0b3IgbXVzdCBiZSBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZycpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5lbmNvZGUpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5zdHJpY3QgPyBzdHJpY3RVcmlFbmNvZGUodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHZhbHVlLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zLmRlY29kZSkge1xuXHRcdHJldHVybiBkZWNvZGVDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dC5zb3J0KCk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBrZXlzU29ydGVyKE9iamVjdC5rZXlzKGlucHV0KSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpXG5cdFx0XHQubWFwKGtleSA9PiBpbnB1dFtrZXldKTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFzaChpbnB1dCkge1xuXHRjb25zdCBoYXNoU3RhcnQgPSBpbnB1dC5pbmRleE9mKCcjJyk7XG5cdGlmIChoYXNoU3RhcnQgIT09IC0xKSB7XG5cdFx0aW5wdXQgPSBpbnB1dC5zbGljZSgwLCBoYXNoU3RhcnQpO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNoKHVybCkge1xuXHRsZXQgaGFzaCA9ICcnO1xuXHRjb25zdCBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xuXHRpZiAoaGFzaFN0YXJ0ICE9PSAtMSkge1xuXHRcdGhhc2ggPSB1cmwuc2xpY2UoaGFzaFN0YXJ0KTtcblx0fVxuXG5cdHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0KGlucHV0KSB7XG5cdGlucHV0ID0gcmVtb3ZlSGFzaChpbnB1dCk7XG5cdGNvbnN0IHF1ZXJ5U3RhcnQgPSBpbnB1dC5pbmRleE9mKCc/Jyk7XG5cdGlmIChxdWVyeVN0YXJ0ID09PSAtMSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHJldHVybiBpbnB1dC5zbGljZShxdWVyeVN0YXJ0ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMucGFyc2VOdW1iZXJzICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpICE9PSAnJykpIHtcblx0XHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5wYXJzZUJvb2xlYW5zICYmIHZhbHVlICE9PSBudWxsICYmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZhbHNlJykpIHtcblx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGRlY29kZTogdHJ1ZSxcblx0XHRzb3J0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJyxcblx0XHRwYXJzZU51bWJlcnM6IGZhbHNlLFxuXHRcdHBhcnNlQm9vbGVhbnM6IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3Iob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0aW9ucyk7XG5cblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxuXHRjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGlucHV0ID0gaW5wdXQudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sICcnKTtcblxuXHRpZiAoIWlucHV0KSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZvciAoY29uc3QgcGFyYW0gb2YgaW5wdXQuc3BsaXQoJyYnKSkge1xuXHRcdGxldCBba2V5LCB2YWx1ZV0gPSBzcGxpdE9uRmlyc3Qob3B0aW9ucy5kZWNvZGUgPyBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKSA6IHBhcmFtLCAnPScpO1xuXG5cdFx0Ly8gTWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFsnY29tbWEnLCAnc2VwYXJhdG9yJ10uaW5jbHVkZXMob3B0aW9ucy5hcnJheUZvcm1hdCkgPyB2YWx1ZSA6IGRlY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0Zm9ybWF0dGVyKGRlY29kZShrZXksIG9wdGlvbnMpLCB2YWx1ZSwgcmV0KTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHJldFtrZXldO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlW2tdID0gcGFyc2VWYWx1ZSh2YWx1ZVtrXSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gcGFyc2VWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc29ydCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0cmV0dXJuIChvcHRpb25zLnNvcnQgPT09IHRydWUgPyBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKSA6IE9iamVjdC5rZXlzKHJldCkuc29ydChvcHRpb25zLnNvcnQpKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0Y29uc3QgdmFsdWUgPSByZXRba2V5XTtcblx0XHRpZiAoQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdC8vIFNvcnQgb2JqZWN0IGtleXMsIG5vdCB2YWx1ZXNcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gKG9iamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoIW9iamVjdCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJ1xuXHR9LCBvcHRpb25zKTtcblxuXHR2YWxpZGF0ZUFycmF5Rm9ybWF0U2VwYXJhdG9yKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuXG5cdGNvbnN0IHNob3VsZEZpbHRlciA9IGtleSA9PiAoXG5cdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0W2tleV0pKSB8fFxuXHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiBvYmplY3Rba2V5XSA9PT0gJycpXG5cdCk7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpO1xuXG5cdGNvbnN0IG9iamVjdENvcHkgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG5cdFx0aWYgKCFzaG91bGRGaWx0ZXIoa2V5KSkge1xuXHRcdFx0b2JqZWN0Q29weVtrZXldID0gb2JqZWN0W2tleV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdENvcHkpO1xuXG5cdGlmIChvcHRpb25zLnNvcnQgIT09IGZhbHNlKSB7XG5cdFx0a2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG5cdH1cblxuXHRyZXR1cm4ga2V5cy5tYXAoa2V5ID0+IHtcblx0XHRjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0XHQucmVkdWNlKGZvcm1hdHRlcihrZXkpLCBbXSlcblx0XHRcdFx0LmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0aW9ucykgKyAnPScgKyBlbmNvZGUodmFsdWUsIG9wdGlvbnMpO1xuXHR9KS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLmpvaW4oJyYnKTtcbn07XG5cbmV4cG9ydHMucGFyc2VVcmwgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGRlY29kZTogdHJ1ZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCBbdXJsLCBoYXNoXSA9IHNwbGl0T25GaXJzdChpbnB1dCwgJyMnKTtcblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcblx0XHR7XG5cdFx0XHR1cmw6IHVybC5zcGxpdCgnPycpWzBdIHx8ICcnLFxuXHRcdFx0cXVlcnk6IHBhcnNlKGV4dHJhY3QoaW5wdXQpLCBvcHRpb25zKVxuXHRcdH0sXG5cdFx0b3B0aW9ucyAmJiBvcHRpb25zLnBhcnNlRnJhZ21lbnRJZGVudGlmaWVyICYmIGhhc2ggPyB7ZnJhZ21lbnRJZGVudGlmaWVyOiBkZWNvZGUoaGFzaCwgb3B0aW9ucyl9IDoge31cblx0KTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5VXJsID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHVybCA9IHJlbW92ZUhhc2goaW5wdXQudXJsKS5zcGxpdCgnPycpWzBdIHx8ICcnO1xuXHRjb25zdCBxdWVyeUZyb21VcmwgPSBleHBvcnRzLmV4dHJhY3QoaW5wdXQudXJsKTtcblx0Y29uc3QgcGFyc2VkUXVlcnlGcm9tVXJsID0gZXhwb3J0cy5wYXJzZShxdWVyeUZyb21VcmwsIHtzb3J0OiBmYWxzZX0pO1xuXG5cdGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbihwYXJzZWRRdWVyeUZyb21VcmwsIGlucHV0LnF1ZXJ5KTtcblx0bGV0IHF1ZXJ5U3RyaW5nID0gZXhwb3J0cy5zdHJpbmdpZnkocXVlcnksIG9wdGlvbnMpO1xuXHRpZiAocXVlcnlTdHJpbmcpIHtcblx0XHRxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gO1xuXHR9XG5cblx0bGV0IGhhc2ggPSBnZXRIYXNoKGlucHV0LnVybCk7XG5cdGlmIChpbnB1dC5mcmFnbWVudElkZW50aWZpZXIpIHtcblx0XHRoYXNoID0gYCMke2VuY29kZShpbnB1dC5mcmFnbWVudElkZW50aWZpZXIsIG9wdGlvbnMpfWA7XG5cdH1cblxuXHRyZXR1cm4gYCR7dXJsfSR7cXVlcnlTdHJpbmd9JHtoYXNofWA7XG59O1xuIiwiPHNjcmlwdCBsYW5nPSd0eXBlc2NyaXB0Jz5cclxuICAgIGltcG9ydCBNZW51SWNvbiBmcm9tICcuL01lbnVJY29uLnN2ZWx0ZSc7XHJcbiAgICBpbXBvcnQgTWVudSBmcm9tICcuL01lbnUuc3ZlbHRlJztcclxuICAgIGltcG9ydCAqIGFzIHF1ZXJ5U3RyaW5nIGZyb20gJ3F1ZXJ5LXN0cmluZyc7XHJcblx0aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcclxuXHJcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICBleHBvcnQgbGV0IGlzTG9nZ2VkSW46IGJvb2xlYW47XHJcbiAgICBsZXQgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZm9yd2FyZCgpIHtcclxuXHRcdGRpc3BhdGNoKCd0b2dnbGVMb2dJbicpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVUb2dnbGUoKSB7XHJcbiAgICAgICAgaXNPcGVuID0gIWlzT3BlbjtcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2PlxyXG4gICAgPHA+I2JsYW1laXRvbmZhdGU8L3A+XHJcbiAgICA8TWVudUljb24gb246aGFuZGxlVG9nZ2xlPXtoYW5kbGVUb2dnbGV9IGlzT3Blbj17aXNPcGVufS8+XHJcbiAgICA8TWVudSBpc0xvZ2dlZEluPXtpc0xvZ2dlZElufSBvbjp0b2dnbGVMb2dJbj17Zm9yd2FyZH0gaXNPcGVuPXtpc09wZW59Lz5cclxuPC9kaXY+XHJcblxyXG48c3R5bGUgbGFuZz0nc2Nzcyc+XHJcbiAgICBAaW1wb3J0ICcuLi8uLi8uLi9zdGF0aWMvdGhlbWUuc2Nzcyc7XHJcbiAgICBcclxuICAgIC8qIFNtYXJ0cGhvbmVzIChwb3J0cmFpdCBhbmQgbGFuZHNjYXBlKSAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIFxyXG4gICAgYW5kIChtaW4tZGV2aWNlLXdpZHRoIDogMzIwcHgpIFxyXG4gICAgYW5kIChtYXgtZGV2aWNlLXdpZHRoIDogNDgwcHgpIHsgICBcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIGlQYWRzIChwb3J0cmFpdCBhbmQgbGFuZHNjYXBlKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIFxyXG4gICAgYW5kIChtaW4tZGV2aWNlLXdpZHRoIDogNzY4cHgpIFxyXG4gICAgYW5kIChtYXgtZGV2aWNlLXdpZHRoIDogMTAyNHB4KSB7XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBEZXNrdG9wcyBhbmQgTGFwdG9wcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIEBtZWRpYSBvbmx5IHNjcmVlblxyXG4gICAgYW5kIChtaW4td2lkdGggOiAxMjI0cHgpIHtcclxuICAgICAgICBkaXYge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYWNjZW50LWNvbG9yLWdyZWVuO1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDY1cHg7XHJcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgIHRvcDogMDtcclxuICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDEvNDtcclxuICAgICAgICAgICAgZ3JpZC1jb2x1bW4tc3RhcnQ6IDE7XHJcbiAgZ3JpZC1jb2x1bW4tZW5kOiA0O1xyXG4gIGdyaWQtcm93LXN0YXJ0OiAxO1xyXG4gIGdyaWQtcm93LWVuZDogMztcclxuICBkaXNwbGF5OiBncmlkO1xyXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIDFmcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwIHtcclxuICAgICAgICAgICAgY29sb3I6ICRhY2NlbnQtY29sb3ItY3JlYW07XHJcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDMwcHg7XHJcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAzMHB4O1xyXG4gICAgICAgICAgICBtYXJnaW46IDE3LjVweCAwIDAgMzBweDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAvKiBpUGhvbmUgNCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgQG1lZGlhXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbyA6IDEuNSksXHJcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW8gOiAxLjUpIHtcclxuICAgIH1cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG48L3N0eWxlPiIsIjxzY3JpcHQgbGFuZz0ndHlwZXNjcmlwdCc+XHJcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcclxuICAgIGltcG9ydCBTZWN0aW9uSGVhZGVyIGZyb20gJy4vX2NvbXBvbmVudHMvU2VjdGlvbkhlYWRlci5zdmVsdGUnO1xyXG4gICAgaW1wb3J0IEp1bWJvdHJvbiBmcm9tICcuL19jb21wb25lbnRzL0p1bWJvdHJvbi5zdmVsdGUnO1xyXG4gICAgaW1wb3J0IFN0b3J5IGZyb20gJy4vX2NvbXBvbmVudHMvU3Rvcnkuc3ZlbHRlJztcclxuICAgIGltcG9ydCBCbGVuZGVkIGZyb20gJy4vX2NvbXBvbmVudHMvQmxlbmRlZC5zdmVsdGUnO1xyXG4gICAgaW1wb3J0IENsYW4gZnJvbSAnLi9fY29tcG9uZW50cy9DbGFuLnN2ZWx0ZSc7XHJcbiAgICBpbXBvcnQgVG9hc3RzIGZyb20gJy4vX2NvbXBvbmVudHMvVG9hc3RzLnN2ZWx0ZSc7XHJcbiAgICBpbXBvcnQgTmF2IGZyb20gJy4vX2NvbXBvbmVudHMvTmF2LnN2ZWx0ZSc7XHJcblxyXG4gICAgZGVjbGFyZSBjb25zdCBGQjogYW55O1xyXG4gICAgbGV0IGlzTG9nZ2VkSW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIGxldCBmYWNlYm9va1VzZXJJZDogc3RyaW5nO1xyXG5cclxuICAgIG9uTW91bnQoICgpID0+IHtcclxuICAgICAgICAgICAgRkIuaW5pdCh7XHJcbiAgICAgICAgICAgICAgICBhcHBJZCAgICAgIDogJzc3ODA1ODQzMzAwMzQzNCcsXHJcbiAgICAgICAgICAgICAgICBjb29raWUgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHhmYm1sICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbiAgICA6ICd2Ny4wJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIEZCLmdldExvZ2luU3RhdHVzKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpc0xvZ2dlZEluID0gKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgZmFjZWJvb2tVc2VySWQgPSByZXNwb25zZS5hdXRoUmVzcG9uc2UudXNlcklEO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHRvZ2dsZUxvZ0luKCkge1xyXG4gICAgICAgIGlmIChpc0ZhY2Vib29rQ29ubmVjdGVkKCkpIHtcclxuICAgICAgICAgICAgRkIubG9nb3V0KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBmYWNlYm9va1VzZXJJZCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaXNMb2dnZWRJbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTsgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgRkIubG9naW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGZhY2Vib29rVXNlcklkID0gcmVzcG9uc2UuYXV0aFJlc3BvbnNlLnVzZXJJRDtcclxuICAgICAgICAgICAgICAgIGlzTG9nZ2VkSW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0ZhY2Vib29rQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBpc0Nvbm5lY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIEZCLmdldExvZ2luU3RhdHVzKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGlzQ29ubmVjdGVkID0gKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZDtcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48TmF2IGlzTG9nZ2VkSW49e2lzTG9nZ2VkSW59IG9uOnRvZ2dsZUxvZ0luPXt0b2dnbGVMb2dJbn0vPlxyXG48ZGl2PjxpbWcgc3JjPSdQYWdlTGVmdERlY29yYXRvci5wbmcnIGFsdD0nZGVjb3JhdGlvbicgY2xhc3M9J2xlZnQgcGFnZURlY29yYXRvcic+PC9kaXY+XHJcbjxkaXYgY2xhc3M9J2NvbnRlbnQnPlxyXG4gICAgPEp1bWJvdHJvbiAvPlxyXG4gICAgPFN0b3J5IC8+XHJcbiAgICA8Q2xhbiAvPlxyXG4gICAgPFRvYXN0cyBpc0xvZ2dlZEluPXtpc0xvZ2dlZElufSBmYWNlYm9va1VzZXJJZD17ZmFjZWJvb2tVc2VySWR9IG9uOnRvZ2dsZUxvZ0luPXt0b2dnbGVMb2dJbn0vPlxyXG4gICAgPEJsZW5kZWQgLz5cclxuPC9kaXY+XHJcbjxkaXY+PGltZyBzcmM9J1BhZ2VSaWdodERlY29yYXRvci5wbmcnIGFsdD0nZGVjb3JhdGlvbicgY2xhc3M9J3JpZ2h0IHBhZ2VEZWNvcmF0b3InPjwvZGl2PlxyXG48c3R5bGUgZ2xvYmFsIGxhbmc9J3Njc3MnPlxyXG4gICAgQGltcG9ydCAnLi4vLi4vc3RhdGljL2dsb2JhbC5zY3NzJztcclxuXHJcbiAgICAucGFnZURlY29yYXRvciB7XHJcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5sZWZ0IHtcclxuICAgICAgICB0b3A6IDY1cHg7XHJcbiAgICAgICAgbGVmdDowcHg7XHJcbiAgICB9XHJcblxyXG4gICAgLnJpZ2h0IHtcclxuICAgICAgICBib3R0b206IDBweDtcclxuICAgICAgICByaWdodDogMHB4O1xyXG4gICAgfVxyXG48L3N0eWxlPiJdLCJuYW1lcyI6WyJ0aGlzIiwibGluZWFyIiwiYW5pbWF0ZVNjcm9sbC5zY3JvbGxUb1RvcCIsImFuaW1hdGVTY3JvbGwuc2Nyb2xsVG8iLCJkZWNvZGVDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBS1MsR0FBSzs7Ozs7Ozs7Ozt1Q0FBTCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUVBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FKSCxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJDSVUsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJDQVgsdUJBQXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMakQsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUFrRCxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQWtILENBQUMsQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDQSxjQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBYSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLE1BQU0sRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsZUFBZSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLHNCQUFzQixFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBVyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxZQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFD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QUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFDRCxTQUFTLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFDckIsSUFBSSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3BELENBQUM7QUFDRCxTQUFTLFVBQVUsQ0FBQyxDQUFDLEVBQUU7QUFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ3BCLFFBQVEsT0FBTyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDaEQsQ0FBQztBQUNELFNBQVMsT0FBTyxDQUFDLENBQUMsRUFBRTtBQUNwQixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBQ0QsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQ3JCLElBQUksT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFDRCxTQUFTLFNBQVMsQ0FBQyxDQUFDLEVBQUU7QUFDdEIsSUFBSSxPQUFPLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBQ0QsU0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFO0FBQ25CLElBQUksTUFBTSxDQUFDLEdB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
